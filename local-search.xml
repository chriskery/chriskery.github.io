<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>容器网络模型</title>
    <link href="/2023/11/29/%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/"/>
    <url>/2023/11/29/%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="构建容器网络模型"><a href="#构建容器网络模型" class="headerlink" title="构建容器网络模型"></a>构建容器网络模型</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>在上一节中，通过 Linux 的网络虚拟化技术构建了一个网络，连接了容器的网络Namespace 和宿主机网络，其中做了命名空间创建、设备创建、地址分配、挂载设备和地址转换配置等操作，本节会将这些操作抽象出网络的模型以便于用代码实现上面一系列流程。</p><h2 id="2-模型"><a href="#2-模型" class="headerlink" title="2. 模型"></a>2. 模型</h2><p>首先，需要抽象出容器网络的两个对象：网络和网络端点。</p><h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><p>网络是容器的一个集合，在这个网络上的容器可以通过这个网络互相通信，就像挂载到同一个 Linux Bridge 设备上的网络设备一样， 可以直接通过 Bridge 设备实现网络互连;连接到同一个网络中的容器也可以通过这个网络和网络中别的容器互连。网络中会包括这个网络相关的配置，比如网络的容器地址段、网络操作所调用的网络驱动等信息。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Network <span class="hljs-keyword">struct</span> &#123;<br>Name    <span class="hljs-type">string</span>     <span class="hljs-comment">// 网络名</span><br>IPRange *net.IPNet <span class="hljs-comment">// 地址段</span><br>Driver  <span class="hljs-type">string</span>     <span class="hljs-comment">// 网络驱动名</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="网络端点"><a href="#网络端点" class="headerlink" title="网络端点"></a>网络端点</h3><p>网络端点是用于连接容器与网络的，保证容器内部与网络的通信。像上一节中用到的 Veth 设备，一端挂载到容器内部，另一端挂载到 Bridge 上，就能使得容器和网络的通信。</p><p>网络端点中会包括连接到网络的一些信息，比如地址、Veth 设备、端口映射、连接的容器和网络等信息。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Endpoint <span class="hljs-keyword">struct</span> &#123;<br>ID          <span class="hljs-type">string</span>           <span class="hljs-string">`json:&quot;id&quot;`</span><br>Device      netlink.Veth     <span class="hljs-string">`json:&quot;dev&quot;`</span><br>IPAddress   net.IP           <span class="hljs-string">`json:&quot;ip&quot;`</span><br>MacAddress  net.HardwareAddr <span class="hljs-string">`json:&quot;mac&quot;`</span><br>Network     *Network<br>PortMapping []<span class="hljs-type">string</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="网络驱动"><a href="#网络驱动" class="headerlink" title="网络驱动"></a>网络驱动</h3><p>网络驱动(Network Driver) 是一个网络功能中的组件，不同的驱动对网络的创建、连接、销毁的策略不同，通过在创建网络时指定不同的网络驱动来定义使用哪个驱动做网络的配置。</p><p>它的接口定义如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Driver <span class="hljs-keyword">interface</span> &#123;<br>Name() <span class="hljs-type">string</span><br>Create(subnet <span class="hljs-type">string</span>, name <span class="hljs-type">string</span>) (*Network, <span class="hljs-type">error</span>)<br>Delete(network Network) <span class="hljs-type">error</span><br>Connect(network *Network, endpoint *Endpoint) <span class="hljs-type">error</span><br>Disconnect(network Network, endpoint *Endpoint) <span class="hljs-type">error</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="IPAM"><a href="#IPAM" class="headerlink" title="IPAM"></a>IPAM</h3><p>IPAM(IP Address Management) 也是网络功能中的一个组件，用于网络 IP 地址的分配和释放，包括容器的IP地址和网络网关的IP地址，它的主要功能如下。</p><ul><li>IPAM.Allocate(subnet *net.IPNet) 从指定的 subnet 网段中分配 IP 地址</li><li>IPAM.Release(subnet net.IPNet, ipaddr net.IP) 从指定的 subnet 网段中释放掉指定的 IP 地址。</li></ul><h2 id="3-调用关系"><a href="#3-调用关系" class="headerlink" title="3. 调用关系"></a>3. 调用关系</h2><h3 id="创建网络"><a href="#创建网络" class="headerlink" title="创建网络"></a>创建网络</h3><p>通过<code>mydocker network create</code>命令创建一个容器网络：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mydocker network create --subset 192.168.0.0/24 --deive bridge testbr<br></code></pre></td></tr></table></figure><p>通过 Bridge 网络驱动创建一个网络，网段是 192.168.0.0&#x2F;24。</p><p>具体流程如下图所示：</p><!-- ![](/source/_posts/容器网络模型/网络创建流程.png) --><img src="/2023/11/29/%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/11/29/%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/%E7%BD%91%E7%BB%9C%E5%88%9B%E5%BB%BA%E6%B5%81%E7%A8%8B.png" class title="This is an example image"><p>在调用命令创建网络时，先通过 IPAM 获取网络的网关 IP,然后再调用网络驱动去设置网络的信息，比如 Bridge 的驱动将会创建 Linux Bridge 网络设备和相应的<br>iptables规则，最终将网络的信息返回给调用者。</p><p>上图中的 IPAM 和 Network Driver 是两个组件，IPAM 负责通过传入的IP网段去分配一个可用的 IP 地址给容器和网络的网关，比如网络的网段是 192.168.0.0&#x2F;16， 那么通过 IPAM 获取这个网段的容器地址就是在这个网段中的一个 IP 地址，然后用于分配给容器的连接端点，保证网络中的容器 IP 不会冲突。</p><p>而 Network Driver 是用于网络的管理的，例如在创建网络时完成网络初始化动作及在容器启动时完成网络端点配置。像 Bridge 的驱动对应的动作就是创建 Linux Bridge 和挂载 Veth 设备。</p><h3 id="创建容器并连接网络"><a href="#创建容器并连接网络" class="headerlink" title="创建容器并连接网络"></a>创建容器并连接网络</h3><p>通过创建容器时指定<code>-net</code> 参数，指定容器启动时连接的网络。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mydocker run -it -p 80:80 --net testbridgenet xxxx<br></code></pre></td></tr></table></figure><p>这样创建出的容器便可以通过 testbridgenet 这个网络与网络中的其他容器进行通信了。</p><p>具体流程图如下：</p><!-- ![](assets/容器加入网络流程.png) --><img src="/2023/11/29/%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/11/29/%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/%E5%AE%B9%E5%99%A8%E5%8A%A0%E5%85%A5%E7%BD%91%E7%BB%9C%E6%B5%81%E7%A8%8B.png" class title="This is an example image"><p>在调用创建容器时指定网络，首先会调用IPAM,通过网络中定义的网段找到未分配的 IP 分配给容器，然后创建容器的网络端点，并调用这个网络的网络驱动连接网络与网络端点，最终完成网络端点的连接和配置。比如在 Bridge 驱动中就会将Veth 设备挂载到 Linux Bridge 网桥上。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Connect</span><span class="hljs-params">(networkName <span class="hljs-type">string</span>, info *container.Info)</span></span> <span class="hljs-type">error</span> &#123;<br><span class="hljs-comment">// 从networks字典中取到容器连接的网络的信息，networks字典中保存了当前己经创建的网络</span><br>network, ok := networks[networkName]<br><span class="hljs-keyword">if</span> !ok &#123;<br><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;no Such Network: %s&quot;</span>, networkName)<br>&#125;<br><br><span class="hljs-comment">// 分配容器IP地址</span><br>ip, err := ipAllocator.Allocate(network.IpRange)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><br><span class="hljs-comment">// 创建网络端点</span><br>ep := &amp;Endpoint&#123;<br>ID:          fmt.Sprintf(<span class="hljs-string">&quot;%s-%s&quot;</span>, cinfo.Id, networkName),<br>IPAddress:   ip,<br>Network:     network,<br>PortMapping: info.PortMapping,<br>&#125;<br><span class="hljs-comment">// 调用网络驱动挂载和配置网络端点</span><br><span class="hljs-keyword">if</span> err = drivers[network.Driver].Connect(network, ep); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><span class="hljs-comment">// 到容器的namespace配置容器网络设备IP地址</span><br><span class="hljs-keyword">if</span> err = configEndpointIpAddressAndRoute(ep, info); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><br><span class="hljs-keyword">return</span> configPortMapping(ep, info)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="展示网络列表"><a href="#展示网络列表" class="headerlink" title="展示网络列表"></a>展示网络列表</h3><p>通过 <code>mydocker network list</code>命令显示当前创建了哪些网络。</p><p>首先从网络配置的目录中加载所有的网络配置信息到 networks 字典中，如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Init</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span> &#123;<br><span class="hljs-comment">// 加载网络驱动</span><br><span class="hljs-keyword">var</span> bridgeDriver = BridgeNetworkDriver&#123;&#125;<br>drivers[bridgeDriver.Name()] = &amp;bridgeDriver<br><span class="hljs-comment">// 文件不存在则创建</span><br><span class="hljs-keyword">if</span> _, err := os.Stat(defaultNetworkPath); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">if</span> !os.IsNotExist(err) &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><span class="hljs-keyword">if</span> err = os.MkdirAll(defaultNetworkPath, constant.Perm0644); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br>&#125;<br><span class="hljs-comment">// 检查网络配置目录中的所有文件,并执行第二个参数中的函数指针去处理目录下的每一个文件</span><br>err := filepath.Walk(defaultNetworkPath, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(nwPath <span class="hljs-type">string</span>, info os.FileInfo, err <span class="hljs-type">error</span>)</span></span> <span class="hljs-type">error</span> &#123;<br><span class="hljs-comment">// 如果是目录则跳过</span><br><span class="hljs-keyword">if</span> info.IsDir() &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><span class="hljs-comment">// if strings.HasSuffix(nwPath, &quot;/&quot;) &#123;</span><br><span class="hljs-comment">// return nil</span><br><span class="hljs-comment">// &#125;</span><br><span class="hljs-comment">//  加载文件名作为网络名</span><br>_, nwName := path.Split(nwPath)<br>nw := &amp;Network&#123;<br>Name: nwName,<br>&#125;<br><span class="hljs-comment">// 调用前面介绍的 Network.load 方法加载网络的配置信息</span><br><span class="hljs-keyword">if</span> err = nw.load(nwPath); err != <span class="hljs-literal">nil</span> &#123;<br>logrus.Errorf(<span class="hljs-string">&quot;error load network: %s&quot;</span>, err)<br>&#125;<br><span class="hljs-comment">// 将网络的配置信息加入到 networks 字典中</span><br>networks[nwName] = nw<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;)<br><span class="hljs-keyword">return</span> err<br>&#125;<br></code></pre></td></tr></table></figure><p>上面己经把网络配置目录中的所有网络配置加载到了 networks 典中， 然后通过遍历这个字典来展示创建的网络，如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ListNetwork</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 通过tabwriter库把信息打印到屏幕上</span><br>w := tabwriter.NewWriter(os.Stdout, <span class="hljs-number">12</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-number">0</span>)<br>fmt.Fprint(w, <span class="hljs-string">&quot;NAME\tIpRange\tDriver\n&quot;</span>)<br><span class="hljs-keyword">for</span> _, nw := <span class="hljs-keyword">range</span> networks &#123;<br>fmt.Fprintf(w, <span class="hljs-string">&quot;%s\t%s\t%s\n&quot;</span>,<br>nw.Name,<br>nw.IPRange.String(),<br>nw.Driver,<br>)<br>&#125;<br><span class="hljs-keyword">if</span> err := w.Flush(); err != <span class="hljs-literal">nil</span> &#123;<br>logrus.Errorf(<span class="hljs-string">&quot;Flush error %v&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="删除网络"><a href="#删除网络" class="headerlink" title="删除网络"></a>删除网络</h3><p>通过使用命令 <code>mydocker network remove</code>命令删除己经创建的网络。</p><p>具体流程如下图：</p><!-- ![](assets/网络删除流程.png) --><img src="/2023/11/29/%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/11/29/%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/%E7%BD%91%E7%BB%9C%E5%88%A0%E9%99%A4%E6%B5%81%E7%A8%8B.png" class title="This is an example image"><ul><li>1）先调用 IPAM 去释放网络所占用的网关 IP</li><li>2）然后调用网络驱动去删除该网络创建的一些设备与配置</li><li>3）最终从网络配置目录中删除网络对应的配置文</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">DeleteNetwork</span><span class="hljs-params">(networkName <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">error</span> &#123;<br><span class="hljs-comment">// 网络不存在直接返回一个error</span><br>nw, ok := networks[networkName]<br><span class="hljs-keyword">if</span> !ok &#123;<br><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;no Such Network: %s&quot;</span>, networkName)<br>&#125;<br><span class="hljs-comment">// 调用IPAM的实例ipAllocator释放网络网关的IP</span><br><span class="hljs-keyword">if</span> err := ipAllocator.Release(nw.IpRange, &amp;nw.IpRange.IP); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> errors.Wrap(err, <span class="hljs-string">&quot;remove Network gateway ip failed&quot;</span>)<br>&#125;<br><span class="hljs-comment">// 调用网络驱动删除网络创建的设备与配置 后面会以 Bridge 驱动删除网络为例子介绍如何实现网络驱动删除网络</span><br><span class="hljs-keyword">if</span> err := drivers[nw.Driver].Delete(*nw); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> errors.Wrap(err, <span class="hljs-string">&quot;remove Network DriverError failed&quot;</span>)<br>&#125;<br><span class="hljs-comment">// 最后从网络的配直目录中删除该网络对应的配置文件</span><br><span class="hljs-keyword">return</span> nw.remove(defaultNetworkPath)<br>&#125;<br><br></code></pre></td></tr></table></figure><p>其中 network remove 会从网络配置目录中删除网络的配置文件。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(nw *Network)</span></span> remove(dumpPath <span class="hljs-type">string</span>) <span class="hljs-type">error</span> &#123;<br><span class="hljs-comment">// 检查网络对应的配置文件状态，如果文件己经不存在就直接返回</span><br>fullPath := path.Join(dumpPath, nw.Name)<br><span class="hljs-keyword">if</span> _, err := os.Stat(fullPath); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">if</span> !os.IsNotExist(err) &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><span class="hljs-comment">// 否则删除这个网络对应的配置文件</span><br><span class="hljs-keyword">return</span> os.Remove(fullPath)<br>&#125;<br></code></pre></td></tr></table></figure><p>转载自：<a href="https://github.com/lixd/mydocker">https://github.com/lixd/mydocker</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>container</tag>
      
      <tag>virtual network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux虚拟网络设备</title>
    <link href="/2023/11/29/linux%E8%99%9A%E6%8B%9F%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/"/>
    <url>/2023/11/29/linux%E8%99%9A%E6%8B%9F%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/</url>
    
    <content type="html"><![CDATA[<h2 id="Linux-虚拟网络设备"><a href="#Linux-虚拟网络设备" class="headerlink" title="Linux 虚拟网络设备"></a>Linux 虚拟网络设备</h2><h3 id="Linux-Veth"><a href="#Linux-Veth" class="headerlink" title="Linux Veth"></a>Linux Veth</h3><h4 id="veth-pair"><a href="#veth-pair" class="headerlink" title="veth-pair"></a>veth-pair</h4><p>顾名思义，veth-pair 就是一对的虚拟设备接口，和 tap&#x2F;tun 设备不同的是，它都是成对出现的。一端连着协议栈，一端彼此相连着。</p><p>一般用于跨 namespace 通信。</p><blockquote><p>Linux 中默认不同 net namespace 设备无法通信。</p></blockquote><h4 id="网络命名空间"><a href="#网络命名空间" class="headerlink" title="网络命名空间"></a>网络命名空间</h4><p>为了支持网络协议栈的多个实例，Linux在网络栈中引入了网络命名空间。这些独立的协议栈被隔离到不同的命名空间中。</p><h4 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h4><p>本次演示中，先创建一个网络命名空间，然后创建一个 veth 设备对，将设备对分别切换到不同的命名空间中，实现不同命名空间的互相通信。</p><p>准备一个 net namespace</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 1创建 namespace</span><br>$ ip netns add netns1<br><span class="hljs-comment"># 查询</span><br>$ ip netns list<br>netns1 (<span class="hljs-built_in">id</span>: 0)<br></code></pre></td></tr></table></figure><p>创建两个Veth设备对</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># ip link add &lt;veth name&gt; type veth peer name &lt;peer name&gt;</span><br>$ ip <span class="hljs-built_in">link</span> add veth0 <span class="hljs-built_in">type</span> veth peer name veth1<br><span class="hljs-comment"># 查询</span><br>$ ip <span class="hljs-built_in">link</span> show<br></code></pre></td></tr></table></figure><p>此时两个 veth 都在默认 net namespace 中，为了测试，先将其中一个切换到 netns1</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> veth1 netns netns1<br><span class="hljs-comment"># 此时再看就只能看到一个了</span><br>$ ip <span class="hljs-built_in">link</span> show<br><span class="hljs-comment"># 去 netns 中查询</span><br>$ ip netns <span class="hljs-built_in">exec</span> netns1 ip <span class="hljs-built_in">link</span> show<br></code></pre></td></tr></table></figure><p>至此，两个不同的命名空间各自有一个Veth，不过还不能通信，因为我们还没给它们分配IP</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ ip netns <span class="hljs-built_in">exec</span> netns1 ip addr add 10.1.1.1/24 dev veth1<br>$ ip addr add 10.1.1.2/24 dev veth0<br></code></pre></td></tr></table></figure><p>再启动它们</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ ip netns <span class="hljs-built_in">exec</span> netns1 ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> dev veth1 up<br>$ ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> dev veth0 up<br></code></pre></td></tr></table></figure><p>现在两个网络命名空间可以互相通信了</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ ping 10.1.1.1<br></code></pre></td></tr></table></figure><p>至此，Veth设备对的基本原理和用法演示结束。</p><blockquote><p>Docker 内部，Veth设备对也是连通容器与宿主机的主要网络设备。</p></blockquote><h3 id="Linux-Bridge"><a href="#Linux-Bridge" class="headerlink" title="Linux Bridge"></a>Linux Bridge</h3><p>Bridge 虚拟设备是用来桥接的网络设备，它相当于现实世界中的交换机，可以连接不同的网络设备，当请求到达 Bridge 设备时，可以通过报文中的 Mac 地址进行广播或转发。</p><p>例如，我们可以创建一个 Bridge 设备来连接 Namespace 中的网络设备和宿主机上的网络。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">创建veth设备并将一端移动到指定Namespace中</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo ip netns add ns1</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo ip <span class="hljs-built_in">link</span> add veth0 <span class="hljs-built_in">type</span> veth peer name veth1</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> veth1 netns ns1</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">先安装bridge-utils</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo apt-get install bridge-utils</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">创建网桥,</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo brctl addbr br0</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">挂载网络设备</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo brctl addif br0 eth0</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo brctl addif br0 veth0</span><br></code></pre></td></tr></table></figure><p><a href="https://zhuanlan.zhihu.com/p/339070912">linux bridge实践</a></p><h2 id="3-Linux-路由表"><a href="#3-Linux-路由表" class="headerlink" title="3. Linux 路由表"></a>3. Linux 路由表</h2><p>路由表是 Linux 内核的一个模块，通过定义路由表来决定在某个网络Namespace 中包的流向，从而定义请求会到哪个网络设备上。</p><p>继续以上面的例子演示</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">启动宿主机上的虚拟网络设备，</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> veth0 up</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> br0 up</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">给ns1中的虚拟网络设备设置IP并启动它</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo ip netns <span class="hljs-built_in">exec</span> ns1 ip addr add 172.18.0.2/24 dev veth1</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo ip netns <span class="hljs-built_in">exec</span> ns1 ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> dev veth1 up</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">分别设置ns1网络空间的路由和宿主机上的路由</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">default代表0.0.0.0/0,即在Net Namespace中的所有流量都经过veth1的网络设备流出</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo apt-get install net-tools</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo ip netns <span class="hljs-built_in">exec</span> ns1  route add default dev veth1</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">在宿主机上将172.18.0.0/24网段的请求路由到br0网桥</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo route add -net 172.18.0.0/24 dev br0</span><br></code></pre></td></tr></table></figure><p>通过设置路由，对IP地址的请求就能正确被路由到对应的网络设备上，从而实现通信，如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">查看宿主机的IP地址</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo ip addr show eth0</span><br>6: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq master br0 state UP group default qlen 1000<br>    link/ether 00:15:5d:ff:cd:9a brd ff:ff:ff:ff:ff:ff<br>    inet 172.20.160.67/20 brd 172.20.175.255 scope global eth0<br>       valid_lft forever preferred_lft forever<br>    inet6 fe80::215:5dff:feff:cd9a/64 scope link<br>       valid_lft forever preferred_lft forever<br><span class="hljs-meta prompt_">#</span><span class="language-bash">从Namespace中访问宿主机的地址</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo ip netns <span class="hljs-built_in">exec</span> ns1 ping -c 1 172.20.160.67</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">从宿主机访问Namespace中的网络地址</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">ping -c 1 172.18.0.2</span><br></code></pre></td></tr></table></figure><p>到此就实现了通过网桥连接不同Namespace网络了。</p><h2 id="4-Linux-iptables"><a href="#4-Linux-iptables" class="headerlink" title="4. Linux iptables"></a>4. Linux iptables</h2><p>iptables 是对 Linux 内核的 netfilter 模块进行操作和展示的工具，用来管理包的流动和转送。iptables 定义了一套链式处理的结构，在网络包传输的各个阶段可以使用不同的策略对包进行加工、传送或丢弃。</p><p>在容器虚拟化的技术中，经常会用到两种策略 MASQUERADE 和 DNAT，用于容器和宿主机外部的网络通信。</p><h3 id="MASQUERADE"><a href="#MASQUERADE" class="headerlink" title="MASQUERADE"></a>MASQUERADE</h3><p>iptables 中的 MASQUERADE 策略可以将请求包中的源地址转换成一个网络设备的地址。</p><p>比如上述例子中的那个 Namespace 中网络设备的地址是 172.18.0.2, 这个地址虽然在宿主机上可以路由到 br0 网桥，但是到达宿主机外部之后，是不知道如何路由到这个 IP 地址的，所以如果要请求外部地址的话，需要先通过MASQUERADE 策略将这个 IP 转换成宿主机出口网卡的 IP。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">打开IP转发</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo sysctl -w net.ipv4.conf.all.forwarding=1</span><br>net.ipv4.conf.all.forwarding = 1<br><span class="hljs-meta prompt_">#</span><span class="language-bash">对Namespace中发出的包添加网络地址转换</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo iptables -t nat -A POSTROUTING -s 172.18.0.0/24 -o eth0 -j MASQUERADE</span><br></code></pre></td></tr></table></figure><p>在 Namespace 中请求宿主机外部地址时，将 Namespace 中的源地址转换成宿主机的地址作为源地址，就可以在 Namespace 中访问宿主机外的网络了。</p><h3 id="DNAT"><a href="#DNAT" class="headerlink" title="DNAT"></a>DNAT</h3><p>iptables 中的 DNAT 策略也是做网络地址的转换，不过它是要更换目标地址，经常用于将内部网络地址的端口映射到外部去。</p><p>比如，上面那个例子中的 Namespace 如果需要提供服务给宿主机之外的应用去请求要怎么办呢?</p><p>外部应用没办法直接路由到 172.18.0.2 这个地址，这时候就可以用到 DNAT 策略。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">将宿主机上80端口的请求转发到Namespace里的IP上</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo iptables -t nat -A PREROUTING -p tcp -m tcp --dport 80 -j DNAT --to-destination 172.18.0.2:80</span><br></code></pre></td></tr></table></figure><p>这样就可以把宿主机上 80 端口的 TCP 请求转发到 Namespace 中的地址172.18.0.2:80,从而实现外部的应用调用。</p><h2 id="5-Go语言网络库"><a href="#5-Go语言网络库" class="headerlink" title="5. Go语言网络库"></a>5. Go语言网络库</h2><p>容器网络用到的技术就是上面提到的几个点，不过用 Go 语言该怎么配置呢？</p><p>Go 中需要用到的几个网络库介绍。</p><h3 id="net-库"><a href="#net-库" class="headerlink" title="net 库"></a>net 库</h3><p>net 库是 Go 语言内置的库，提供了跨平台支持的网络地址处理，以及各种常见协议的IO支持，比如TCP、UDP、DNS、Unix Socket等。</p><h3 id="netlink库"><a href="#netlink库" class="headerlink" title="netlink库"></a>netlink库</h3><p><a href="https://github.com/vishvananda/netlink">netlink库</a> 是Go 语言的操作网络接口、路由表等配置的库 ，使用它的调用相当于我们通过 IP 命令去管理网络接口。</p><h3 id="netns库"><a href="#netns库" class="headerlink" title="netns库"></a>netns库</h3><p><a href="https://github.com/vishvananda/netns">netns库</a> 就是 Go 语言版的<code>ip netns exec</code> 命令实现。通过这个库可以让 netlink 库中配置网络接口的代码在某个容器的 Net amespace 中执行。</p><h3 id="单节点容器相互访问"><a href="#单节点容器相互访问" class="headerlink" title="单节点容器相互访问"></a>单节点容器相互访问</h3><p><img src="https://pic2.zhimg.com/v2-b3b33ed53fdfd86fff8ace576528f671_b.jpg"></p><p><img src="https://pic2.zhimg.com/80/v2-b3b33ed53fdfd86fff8ace576528f671_1440w.webp"></p><p>veth pair的一端在network namespace中，另一端接在了linux bridge上，所以图中的veth00&#x2F;veth01就变为了从设备（linux bridge），即他们就变为了网线，没有了处理数据包的能力，只能转发数据包。</p><p>以192.268.3.101（container1） → 192.268.3.106（container2）为例：</p><p>1、 container1发送APR请求得到container2的mac地址</p><p>2、 container1的这个请求出现在了docker0网桥</p><p>3、 docker0网桥将ARP广播转发到其他接在docker0上的设备</p><p>4、 container2收到这个ARP请求，响应给container1</p><p>5、 container1拿到mac地址封装ICMP请求</p><p>6、 同样这个请求也会经由docker0出现在宿主机上</p><p>7、 docker0查到container2属于自己就转发给了container2</p><h3 id="容器访问外部网络"><a href="#容器访问外部网络" class="headerlink" title="容器访问外部网络"></a>容器访问外部网络</h3><p><img src="https://pic3.zhimg.com/v2-f7891b35584bd9a960fb042e1a651206_b.jpg"></p><p><img src="https://pic3.zhimg.com/80/v2-f7891b35584bd9a960fb042e1a651206_1440w.webp"></p><p>以图中的container2要访问百度为例：</p><p>1、 container2 ping 220.181.38.148</p><p>2、 数据包同样会到达docker0网桥，即到达了宿主机</p><p>3、宿主机发现目的目的网段要交给eth0处理</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">~# route -n<br>Kernel IP routing table<br>Destination     Gateway         Genmask         Flags Metric Ref    Use Iface<br>0.0.0.0         172.28.143.253  0.0.0.0         UG    100    0        0 eth0<br>172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 docker0<br></code></pre></td></tr></table></figure><p>4、 由于源ip是内网ip还要进行一个NAT，通过eth0发到外网</p><p>转载自: <a href="https://github.com/lixd/daily-notes/blob/master/Golang/mydocker/06-1-%E7%BD%91%E7%BB%9C%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF.md">https://github.com/lixd/daily-notes/blob/master/Golang/mydocker/06-1-%E7%BD%91%E7%BB%9C%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF.md</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux mount用法</title>
    <link href="/2023/11/28/systemcall-mount%E5%88%86%E7%B1%BB/"/>
    <url>/2023/11/28/systemcall-mount%E5%88%86%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="mount-–bind"><a href="#mount-–bind" class="headerlink" title="mount –bind"></a>mount –bind</h2><p>我们可以通过mount –bind命令来将两个目录连接起来，mount –bind命令是将前一个目录挂载到后一个目录上，所有对后一个目录的访问其实都是对前一个目录的访问，如下所示：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-comment">## test1 test2为两个不同的目录</span><br>linux-<span class="hljs-title class_">UMLhEm</span><span class="hljs-symbol">:/home/test/linux</span> <span class="hljs-comment"># ls test1</span><br><span class="hljs-number">11</span>.test  <span class="hljs-number">1</span>.test<br>linux-<span class="hljs-title class_">UMLhEm</span><span class="hljs-symbol">:/home/test/linux</span> <span class="hljs-comment"># ls test2</span><br><span class="hljs-number">22</span>.test  <span class="hljs-number">2</span>.test<br>linux-<span class="hljs-title class_">UMLhEm</span><span class="hljs-symbol">:/home/test/linux</span> <span class="hljs-comment"># ls -lid test1</span><br><span class="hljs-number">1441802</span> drwx------ <span class="hljs-number">2</span> root root <span class="hljs-number">4096</span> <span class="hljs-title class_">Feb</span> <span class="hljs-number">13</span> 09<span class="hljs-symbol">:</span><span class="hljs-number">50</span> test1<br>linux-<span class="hljs-title class_">UMLhEm</span><span class="hljs-symbol">:/home/test/linux</span> <span class="hljs-comment"># ls -lid test2</span><br><span class="hljs-number">1441803</span> drwx------ <span class="hljs-number">2</span> root root <span class="hljs-number">4096</span> <span class="hljs-title class_">Feb</span> <span class="hljs-number">13</span> 09<span class="hljs-symbol">:</span><span class="hljs-number">51</span> test2<br><br><span class="hljs-comment">## 执行mount --bind 将test1挂载到test2上，inode号都变为test1的inode</span><br>linux-<span class="hljs-title class_">UMLhEm</span><span class="hljs-symbol">:/home/test/linux</span> <span class="hljs-comment"># mount --bind test1 test2</span><br>linux-<span class="hljs-title class_">UMLhEm</span><span class="hljs-symbol">:/home/test/linux</span> <span class="hljs-comment"># ls -lid test1</span><br><span class="hljs-number">1441802</span> drwx------ <span class="hljs-number">2</span> root root <span class="hljs-number">4096</span> <span class="hljs-title class_">Feb</span> <span class="hljs-number">13</span> 09<span class="hljs-symbol">:</span><span class="hljs-number">50</span> test1<br>linux-<span class="hljs-title class_">UMLhEm</span><span class="hljs-symbol">:/home/test/linux</span> <span class="hljs-comment"># ls -lid test2</span><br><span class="hljs-number">1441802</span> drwx------ <span class="hljs-number">2</span> root root <span class="hljs-number">4096</span> <span class="hljs-title class_">Feb</span> <span class="hljs-number">13</span> 09<span class="hljs-symbol">:</span><span class="hljs-number">50</span> test2<br>linux-<span class="hljs-title class_">UMLhEm</span><span class="hljs-symbol">:/home/test/linux</span> <span class="hljs-comment"># ls test2</span><br><span class="hljs-number">11</span>.test  <span class="hljs-number">1</span>.test<br><br><span class="hljs-comment">## 对test2的访问或修改实际上是改动test1目录</span><br>linux-<span class="hljs-title class_">UMLhEm</span><span class="hljs-symbol">:/home/test/linux</span> <span class="hljs-comment"># cd test2</span><br>linux-<span class="hljs-title class_">UMLhEm</span><span class="hljs-symbol">:/home/test/linux/test2</span> <span class="hljs-comment"># touch 3.test</span><br>linux-<span class="hljs-title class_">UMLhEm</span><span class="hljs-symbol">:/home/test/linux/test2</span> <span class="hljs-comment"># ls</span><br><span class="hljs-number">11</span>.test  <span class="hljs-number">1</span>.test  <span class="hljs-number">3</span>.test<br>linux-<span class="hljs-title class_">UMLhEm</span><span class="hljs-symbol">:/home/test/linux/test2</span> <span class="hljs-comment"># cd ..</span><br>linux-<span class="hljs-title class_">UMLhEm</span><span class="hljs-symbol">:/home/test/linux</span> <span class="hljs-comment"># ls test1</span><br><span class="hljs-number">11</span>.test  <span class="hljs-number">1</span>.test  <span class="hljs-number">3</span>.test<br><br><span class="hljs-comment">## 解挂载后，test1目录保持修改，test2保持不变</span><br>linux-<span class="hljs-title class_">UMLhEm</span><span class="hljs-symbol">:/home/test/linux</span> <span class="hljs-comment"># umount test2</span><br>linux-<span class="hljs-title class_">UMLhEm</span><span class="hljs-symbol">:/home/test/linux</span> <span class="hljs-comment"># ls test1</span><br><span class="hljs-number">11</span>.test  <span class="hljs-number">1</span>.test  <span class="hljs-number">3</span>.test<br>linux-<span class="hljs-title class_">UMLhEm</span><span class="hljs-symbol">:/home/test/linux</span> <span class="hljs-comment"># ls test2</span><br><span class="hljs-number">22</span>.test  <span class="hljs-number">2</span>.test<br><br><span class="hljs-comment">## 将test2挂载到test1上</span><br>linux-<span class="hljs-title class_">UMLhEm</span><span class="hljs-symbol">:/home/test/linux</span> <span class="hljs-comment"># ls -lid test2</span><br><span class="hljs-number">1441803</span> drwx------ <span class="hljs-number">2</span> root root <span class="hljs-number">4096</span> <span class="hljs-title class_">Feb</span> <span class="hljs-number">13</span> 09<span class="hljs-symbol">:</span><span class="hljs-number">51</span> test2<br>linux-<span class="hljs-title class_">UMLhEm</span><span class="hljs-symbol">:/home/test/linux</span> <span class="hljs-comment"># mount --bind test2 test1</span><br>linux-<span class="hljs-title class_">UMLhEm</span><span class="hljs-symbol">:/home/test/linux</span> <span class="hljs-comment"># ls -lid test1</span><br><span class="hljs-number">1441803</span> drwx------ <span class="hljs-number">2</span> root root <span class="hljs-number">4096</span> <span class="hljs-title class_">Feb</span> <span class="hljs-number">13</span> 09<span class="hljs-symbol">:</span><span class="hljs-number">51</span> test1<br>linux-<span class="hljs-title class_">UMLhEm</span><span class="hljs-symbol">:/home/test/linux</span> <span class="hljs-comment"># ls -lid test2</span><br><span class="hljs-number">1441803</span> drwx------ <span class="hljs-number">2</span> root root <span class="hljs-number">4096</span> <span class="hljs-title class_">Feb</span> <span class="hljs-number">13</span> 09<span class="hljs-symbol">:</span><span class="hljs-number">51</span> test2<br>linux-<span class="hljs-title class_">UMLhEm</span><span class="hljs-symbol">:/home/test/linux</span> <span class="hljs-comment"># ls test1</span><br><span class="hljs-number">22</span>.test  <span class="hljs-number">2</span>.test<br></code></pre></td></tr></table></figure><p>以mount –bind test1 test2为例，当mount –bind命令执行后，Linux将会把被挂载目录的目录项（也就是该目录文件的block，记录了下级目录的信息）屏蔽，即test2的下级路径被隐藏起来了（注意，只是隐藏不是删除，数据都没有改变，只是访问不到了）。同时，内核将挂载目录（test1）的目录项记录在内存里的一个s_root对象里，在mount命令执行时，VFS会创建一个vfsmount对象，这个对象里包含了整个文件系统所有的mount信息，其中也会包括本次mount中的信息，这个对象是一个HASH值对应表（HASH值通过对路径字符串的计算得来），表里就有 &#x2F;test1 到 &#x2F;test2 两个目录的HASH值对应关系。</p><p>命令执行完后，当访问 &#x2F;test2下的文件时，系统会告知 &#x2F;test2 的目录项被屏蔽掉了，自动转到内存里找VFS，通过vfsmount了解到 &#x2F;test2 和 &#x2F;test1 的对应关系，从而读取到 &#x2F;test1 的inode，这样在 &#x2F;test2 下读到的全是 &#x2F;test1 目录下的文件。</p><blockquote><ul><li>.mount –bind连接的两个目录的inode号码并不一样，只是被挂载目录的block被屏蔽掉，inode被重定向到挂载目录的inode（被挂载目录的inode和block依然没变）。</li><li>.两个目录的对应关系存在于内存里，一旦重启挂载关系就不存在了。</li></ul></blockquote><p>在固件开发过程中常常遇到这样的情况：为测试某个新功能，必需修改某个系统文件。而这个文件在只读文件系统上（总不能为一个小小的测试就重刷固件吧），或者是虽然文件可写，但是自己对这个改动没有把握，不愿意直接修改。这时候mount –bind就是你的好帮手。 <br>假设我们要改的文件是&#x2F;etc&#x2F;hosts，可按下面的步骤操作： <br>1. 把新的hosts文件放在&#x2F;tmp下。当然也可放在硬盘或U盘上。 <br>2. mount –bind &#x2F;tmp&#x2F;hosts &#x2F;etc&#x2F;hosts       此时的&#x2F;etc目录是可写的，所做修改不会应用到原来的&#x2F;etc目录，可以放心测试。测试完成了执行 umount &#x2F;etc&#x2F;hosts 断开绑定。</p><p>通过执行下面的命令可以创建一个挂载点：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">mount <span class="hljs-comment">--bind foo foo</span><br></code></pre></td></tr></table></figure><p>在挂载后可以通过mount命令查看所有的挂载点.这样就可以使用一些mount的属性，最简单的例子，例如：</p><blockquote><p>sudo mount,ro –bind test_dir test_dir</p></blockquote><p>可以让test_dir成为一个是read only的目录。无论改目录中的文件夹或者文件的权限是什么，这个文件夹都是只读的。</p><p>如果要递归的挂载一个目录可以使用如下命令.<br>mount –rbind olddir newdir<br>递归的挂载是指如果挂载的olddir内有挂载点，会把这个挂载点也一起挂载到newdir下。</p><h2 id="flags"><a href="#flags" class="headerlink" title="flags"></a>flags</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * These are the fs-independent mount-flags: up to 32 flags are supported </span><br><span class="hljs-comment"> */</span>  <br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_RDONLY        1         <span class="hljs-comment">/* 对应-o ro/rw */</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_NOSUID        2         <span class="hljs-comment">/* 对应-o suid/nosuid */</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_NODEV         4         <span class="hljs-comment">/* 对应-o dev/nodev */</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_NOEXEC        8         <span class="hljs-comment">/* 对应-o exec/noexec */</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_SYNCHRONOUS  16         <span class="hljs-comment">/* 对应-o sync/async */</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_REMOUNT      32         <span class="hljs-comment">/* 对应-o remount，告诉mount这是一次remount操作 */</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_MANDLOCK     64         <span class="hljs-comment">/* 对应-o mand/nomand */</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_DIRSYNC      128        <span class="hljs-comment">/* 对应-o dirsync */</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_NOATIME      1024       <span class="hljs-comment">/* 对应-o atime/noatime */</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_NODIRATIME   2048       <span class="hljs-comment">/* 对应-o diratime/nodiratime */</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_BIND         4096       <span class="hljs-comment">/* 对应-B/--bind选项，告诉mount这是一次bind操作 */</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_MOVE         8192       <span class="hljs-comment">/* 对应-M/--move，告诉mount这是一次move操作 */</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_REC          16384      <span class="hljs-comment">/* rec是recursive的意思，这个flag一般不单独出现，都是伴随这其它flag，表示递归的进行操作 */</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_VERBOSE      32768      <span class="hljs-comment">/* 对应-v/--verbose */</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_SILENT       32768      <span class="hljs-comment">/* 对应-o silent/loud */</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_POSIXACL     (1&lt;&lt;16)    <span class="hljs-comment">/* 让VFS不应用umask，如NFS */</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_UNBINDABLE   (1&lt;&lt;17)    <span class="hljs-comment">/* 对应--make-unbindable */</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_PRIVATE      (1&lt;&lt;18)    <span class="hljs-comment">/* 对应--make-private */</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_SLAVE        (1&lt;&lt;19)    <span class="hljs-comment">/* 对应--make-slave */</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_SHARED       (1&lt;&lt;20)    <span class="hljs-comment">/* 对应--make-shared */</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_RELATIME     (1&lt;&lt;21)    <span class="hljs-comment">/* 对应-o relatime/norelatime */</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_KERNMOUNT    (1&lt;&lt;22)    <span class="hljs-comment">/* 这个一般不在应用层使用，一般内核挂载的文件系统如sysfs使用，表示使用kern_mount()进行挂载 */</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_I_VERSION    (1&lt;&lt;23)    <span class="hljs-comment">/* 对应-o iversion/noiversion */</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_STRICTATIME  (1&lt;&lt;24)    <span class="hljs-comment">/* 对应-o strictatime/nostrictatime */</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_LAZYTIME     (1&lt;&lt;25)    <span class="hljs-comment">/* 对应 -o lazytime/nolazytime*/</span></span><br><br><span class="hljs-comment">/* 下面这几个flags都是内核内部使用的，不由mount系统调用传递 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_SUBMOUNT     (1&lt;&lt;26)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_NOREMOTELOCK (1&lt;&lt;27)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_NOSEC        (1&lt;&lt;28)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_BORN         (1&lt;&lt;29)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_ACTIVE       (1&lt;&lt;30)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_NOUSER       (1&lt;&lt;31)</span><br><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * Superblock flags that can be altered by MS_REMOUNT </span><br><span class="hljs-comment"> */</span>  <br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_RMT_MASK     (MS_RDONLY|MS_SYNCHRONOUS|MS_MANDLOCK|MS_I_VERSION|\                   </span><br>                         MS_LAZYTIME)  <span class="hljs-comment">// 可以在remount时改变的flags  </span><br>  <br><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * Old magic mount flag and mask </span><br><span class="hljs-comment"> */</span>  <br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_MGC_VAL 0xC0ED0000      <span class="hljs-comment">/* magic number */</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_MGC_MSK 0xffff0000      <span class="hljs-comment">/* flags mask */</span></span><br></code></pre></td></tr></table></figure><p>除了上面这些flags对应的mount选项，剩下的基本就是data来传递。</p><h2 id="mount-umount函数详解"><a href="#mount-umount函数详解" class="headerlink" title="mount&#x2F;umount函数详解"></a>mount&#x2F;umount函数详解</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp">功能描述：<br>mount挂上文件系统，umount执行相反的操作。<br>  <br>用法：  <br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mount.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">mount</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *source, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *target,</span></span><br><span class="hljs-params"><span class="hljs-function">   <span class="hljs-type">const</span> <span class="hljs-type">char</span> *filesystemtype, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> mountflags, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *data)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">umount</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *target)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">umount2</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *target, <span class="hljs-type">int</span> flags)</span></span>;<br></code></pre></td></tr></table></figure><p>参数</p><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig"><span class="hljs-string">source</span>：将要挂上的文件系统，通常是一个设备名。<br><span class="hljs-string">target</span>：文件系统所要挂在的目标目录。<br><span class="hljs-string">filesystemtype</span>：文件系统的类型，可以是<span class="hljs-string">&quot;ext2&quot;</span>，<span class="hljs-string">&quot;msdos&quot;</span>，<span class="hljs-string">&quot;proc&quot;</span>，<span class="hljs-string">&quot;nfs&quot;</span>，<span class="hljs-string">&quot;iso9660&quot;</span> 。。。<br><span class="hljs-string">mountflags</span>：指定文件系统的读写访问标志，可能值有以下<br><br><span class="hljs-string">MS_BIND</span>：执行<span class="hljs-string">bind</span>挂载，使文件或者子目录树在文件系统内的另一个点上可视。<br><span class="hljs-string">MS_DIRSYNC</span>：同步目录的更新。<br><span class="hljs-string">MS_MANDLOCK</span>：允许在文件上执行强制锁。<br><span class="hljs-string">MS_MOVE</span>：移动子目录树。<br><span class="hljs-string">MS_NOATIME</span>：不要更新文件上的访问时间。<br><span class="hljs-string">MS_NODEV</span>：不允许访问设备文件。<br><span class="hljs-string">MS_NODIRATIME</span>：不允许更新目录上的访问时间。<br><span class="hljs-string">MS_NOEXEC</span>：不允许在挂上的文件系统上执行程序。<br><span class="hljs-string">MS_NOSUID</span>：执行程序时，不遵照<span class="hljs-built_in">set-user-ID</span> 和 <span class="hljs-built_in">set-group-ID位。</span><br><span class="hljs-string">MS_RDONLY</span>：指定文件系统为只读。<br><span class="hljs-string">MS_REMOUNT</span>：重新加载文件系统。这允许你改变现存文件系统的<span class="hljs-string">mountflag</span>和数据，而无需使用先卸载，再挂上文件系统的方式。<br><span class="hljs-string">MS_SYNCHRONOUS</span>：同步文件的更新。<br><span class="hljs-string">MNT_FORCE</span>：强制卸载，即使文件系统处于忙状态。<br><span class="hljs-string">MNT_EXPIRE</span>：将挂载点标志为过时<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>mount</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
