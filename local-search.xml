<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>CRI详解</title>
    <link href="/2023/11/30/CRI%E8%AF%A6%E8%A7%A3/"/>
    <url>/2023/11/30/CRI%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p><code>CRI</code>（Container Runtime Interface 容器运行时接口）本质上就是 Kubernetes 定义的一组与容器运行时进行交互的接口，所以只要实现了这套接口的容器运行时都可以对接到 Kubernetes 平台上来。不过 Kubernetes 推出 CRI 这套标准的时候还没有现在的统治地位，所以有一些容器运行时可能不会自身就去实现 CRI 接口，于是就有了 <code>shim（垫片）</code>， 一个 shim 的职责就是作为适配器将各种容器运行时本身的接口适配到 Kubernetes 的 CRI 接口上，其中 <code>dockershim</code> 就是 Kubernetes 对接 Docker 到 CRI 接口上的一个垫片实现。</p><p><img src="https://picdn.youdianzhishi.com/images/20210809172030.png" alt="cri shim"></p><p>Kubelet 通过 gRPC 框架与容器运行时或 shim 进行通信，其中 kubelet 作为客户端，CRI shim（也可能是容器运行时本身）作为服务器。</p><p>CRI定义的 API(<a href="https://github.com/kubernetes/kubernetes/blob/release-1.5/pkg/kubelet/api/v1alpha1/runtime/api.proto">RuntimeService</a>) 主要包括两个 gRPC 服务，<code>ImageService</code> 和 <code>RuntimeService</code>，<code>ImageService</code> 服务主要是拉取镜像、查看和删除镜像等操作，<code>RuntimeService</code> 则是用来管理 Pod 和容器的生命周期，以及与容器交互的调用（exec&#x2F;attach&#x2F;port-forward）等操作，可以通过 kubelet 中的标志 <code>--container-runtime-endpoint</code> 和 <code>--image-service-endpoint</code> 来配置这两个服务的套接字。</p><p><img src="https://picdn.youdianzhishi.com/images/20210809173134.png" alt="kubelet cri"></p><p>不过这里同样也有一个例外，那就是 Docker，由于 Docker 当时的江湖地位很高，Kubernetes 是直接内置了 <code>dockershim</code> 在 kubelet 中的，所以如果你使用的是 Docker 这种容器运行时的话是不需要单独去安装配置适配器之类的，当然这个举动似乎也麻痹了 Docker 公司。</p><p><img src="https://picdn.youdianzhishi.com/images/20210809173555.png" alt="dockershim"></p><p>现在如果我们使用的是 Docker 的话，当我们在 Kubernetes 中创建一个 Pod 的时候，首先就是 kubelet 通过 CRI 接口调用 <code>dockershim</code>，请求创建一个容器，kubelet 可以视作一个简单的 CRI Client, 而 dockershim 就是接收请求的 Server，不过他们都是在 kubelet 内置的。</p><p><code>dockershim</code> 收到请求后, 转化成 Docker Daemon 能识别的请求, 发到 Docker Daemon 上请求创建一个容器，请求到了 Docker Daemon 后续就是 Docker 创建容器的流程了，去调用 <code>containerd</code>，然后创建 <code>containerd-shim</code> 进程，通过该进程去调用 <code>runc</code> 去真正创建容器。</p><p>其实我们仔细观察也不难发现使用 Docker 的话其实是调用链比较长的，真正容器相关的操作其实 containerd 就完全足够了，Docker 太过于复杂笨重了，当然 Docker 深受欢迎的很大一个原因就是提供了很多对用户操作比较友好的功能，但是对于 Kubernetes 来说压根不需要这些功能，因为都是通过接口去操作容器的，所以自然也就可以将容器运行时切换到 containerd 来。</p><p><img src="https://picdn.youdianzhishi.com/images/20210810094948.png" alt="切换到containerd"></p><p>切换到 containerd 可以消除掉中间环节，操作体验也和以前一样，但是由于直接用容器运行时调度容器，所以它们对 Docker 来说是不可见的。 因此，你以前用来检查这些容器的 Docker 工具就不能使用了。</p><p>你不能再使用 <code>docker ps</code> 或 <code>docker inspect</code> 命令来获取容器信息。由于不能列出容器，因此也不能获取日志、停止容器，甚至不能通过 <code>docker exec</code> 在容器中执行命令。</p><p>当然我们仍然可以下载镜像，或者用 <code>docker build</code> 命令构建镜像，但用 Docker 构建、下载的镜像，对于容器运行时和 Kubernetes，均不可见。为了在 Kubernetes 中使用，需要把镜像推送到镜像仓库中去。</p><p>从上图可以看出在 containerd 1.0 中，对 CRI 的适配是通过一个单独的 <code>CRI-Containerd</code> 进程来完成的，这是因为最开始 containerd 还会去适配其他的系统（比如 swarm），所以没有直接实现 CRI，所以这个对接工作就交给 <code>CRI-Containerd</code> 这个 shim 了。</p><p>然后到了 containerd 1.1 版本后就去掉了 <code>CRI-Containerd</code> 这个 shim，直接把适配逻辑作为插件的方式集成到了 containerd 主进程中，现在这样的调用就更加简洁了。</p><p><img src="https://picdn.youdianzhishi.com/images/20210810095546.png" alt="containerd cri"></p><p>与此同时 Kubernetes 社区也做了一个专门用于 Kubernetes 的 CRI 运行时 <a href="https://cri-o.io/">CRI-O</a>，直接兼容 CRI 和 OCI 规范。</p><p><img src="https://picdn.youdianzhishi.com/images/20210810100752.png" alt="cri-o"></p><p>这个方案和 containerd 的方案显然比默认的 dockershim 简洁很多，不过由于大部分用户都比较习惯使用 Docker，所以大家还是更喜欢使用 <code>dockershim</code> 方案。</p><p>但是随着 CRI 方案的发展，以及其他容器运行时对 CRI 的支持越来越完善，Kubernetes 社区在 2020 年 7 月份就开始着手移除 dockershim 方案了：<a href="https://github.com/kubernetes/enhancements/tree/master/keps/sig-node/2221-remove-dockershim%EF%BC%8C%E7%8E%B0%E5%9C%A8%E7%9A%84%E7%A7%BB%E9%99%A4%E8%AE%A1%E5%88%92%E6%98%AF%E5%9C%A8">https://github.com/kubernetes/enhancements/tree/master/keps/sig-node/2221-remove-dockershim，现在的移除计划是在</a> 1.20 版本中将 kubelet 中内置的 dockershim 代码分离，将内置的 dockershim 标记为<code>维护模式</code>，当然这个时候仍然还可以使用 dockershim，目标是在 1.23&#x2F;1.24 版本发布没有 dockershim 的版本（代码还在，但是要默认支持开箱即用的 docker 需要自己构建 kubelet，会在某个宽限期过后从 kubelet 中删除内置的 dockershim 代码）。</p><p>那么这是否就意味这 Kubernetes 不再支持 Docker 了呢？当然不是的，这只是废弃了内置的 <code>dockershim</code> 功能而已，Docker 和其他容器运行时将一视同仁，不会单独对待内置支持，如果我们还想直接使用 Docker 这种容器运行时应该怎么办呢？可以将 dockershim 的功能单独提取出来独立维护一个 <code>cri-dockerd</code> 即可，就类似于 containerd 1.0 版本中提供的 <code>CRI-Containerd</code>，当然还有一种办法就是 Docker 官方社区将 CRI 接口内置到 Dockerd 中去实现。</p><p>但是我们也清楚 Dockerd 也是去直接调用的 Containerd，而 containerd 1.1 版本后就内置实现了 CRI，所以 Docker 也没必要再去单独实现 CRI 了，当 Kubernetes 不再内置支持开箱即用的 Docker 的以后，最好的方式当然也就是直接使用 Containerd 这种容器运行时，而且该容器运行时也已经经过了生产环境实践的，接下来我们就来学习下 Containerd 的使用。</p><p>转载自：<a href="https://www.qikqiak.com/post/containerd-usage/">https://www.qikqiak.com/post/containerd-usage/</a></p>]]></content>
    
    
    <categories>
      
      <category>container</category>
      
    </categories>
    
    
    <tags>
      
      <tag>container</tag>
      
      <tag>kubernetes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker简介</title>
    <link href="/2023/11/30/docker%E6%9E%B6%E6%9E%84/"/>
    <url>/2023/11/30/docker%E6%9E%B6%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h2 id="Docker-Architecutre"><a href="#Docker-Architecutre" class="headerlink" title="Docker Architecutre"></a>Docker Architecutre</h2><p>Docker uses a client-server architecture. The Docker client talks to the Docker daemon, which does the heavy lifting of building, running, and distributing your Docker containers. The Docker client and daemon can run on the same system, or you can connect a Docker client to a remote Docker daemon. The Docker client and daemon communicate using a REST API, over UNIX sockets or a network interface. </p><p><img src="https://docs.docker.com/get-started/images/docker-architecture.webp" alt="Docker Architecture diagram"></p><h3 id="The-Docker-daemon"><a href="#The-Docker-daemon" class="headerlink" title="The Docker daemon"></a><a href="https://docs.docker.com/get-started/overview/#the-docker-daemon">The Docker daemon</a></h3><p>The Docker daemon (<code>dockerd</code>) listens for Docker API requests and manages Docker objects such as images, containers, networks, and volumes. A daemon can also communicate with other daemons to manage Docker services.</p><h3 id="The-Docker-client"><a href="#The-Docker-client" class="headerlink" title="The Docker client"></a><a href="https://docs.docker.com/get-started/overview/#the-docker-client">The Docker client</a></h3><p>The Docker client (<code>docker</code>) is the primary way that many Docker users interact with Docker. When you use commands such as <code>docker run</code>, the client sends these commands to <code>dockerd</code>, which carries them out. The <code>docker</code> command uses the Docker API. The Docker client can communicate with more than one daemon.</p><h3 id="Docker-registries"><a href="#Docker-registries" class="headerlink" title="Docker registries"></a><a href="https://docs.docker.com/get-started/overview/#docker-registries">Docker registries</a></h3><p>A Docker registry stores Docker images. Docker Hub is a public registry that anyone can use, and Docker looks for images on Docker Hub by default. You can even run your own private registry.</p><p>When you use the <code>docker pull</code> or <code>docker run</code> commands, Docker pulls the required images from your configured registry. When you use the <code>docker push</code> command, Docker pushes your image to your configured registry.</p><h3 id="Docker-objects"><a href="#Docker-objects" class="headerlink" title="Docker objects"></a><a href="https://docs.docker.com/get-started/overview/#docker-objects">Docker objects</a></h3><p>When you use Docker, you are creating and using images, containers, networks, volumes, plugins, and other objects. This section is a brief overview of some of those objects.</p><h4 id="Images"><a href="#Images" class="headerlink" title="Images"></a><a href="https://docs.docker.com/get-started/overview/#images">Images</a></h4><p>An image is a read-only template with instructions for creating a Docker container. Often, an image is based on another image, with some additional customization. For example, you may build an image which is based on the <code>ubuntu</code> image, but installs the Apache web server and your application, as well as the configuration details needed to make your application run.</p><p>You might create your own images or you might only use those created by others and published in a registry. To build your own image, you create a Dockerfile with a simple syntax for defining the steps needed to create the image and run it. Each instruction in a Dockerfile creates a layer in the image. When you change the Dockerfile and rebuild the image, only those layers which have changed are rebuilt. This is part of what makes images so lightweight, small, and fast, when compared to other virtualization technologies.</p><h4 id="Containers"><a href="#Containers" class="headerlink" title="Containers"></a><a href="https://docs.docker.com/get-started/overview/#containers">Containers</a></h4><p>A container is a runnable instance of an image. You can create, start, stop, move, or delete a container using the Docker API or CLI. You can connect a container to one or more networks, attach storage to it, or even create a new image based on its current state.</p><p>By default, a container is relatively well isolated from other containers and its host machine. You can control how isolated a container’s network, storage, or other underlying subsystems are from other containers or from the host machine.</p><p>A container is defined by its image as well as any configuration options you provide to it when you create or start it. When a container is removed, any changes to its state that aren’t stored in persistent storage disappear.</p><h5 id="Example-docker-run-command"><a href="#Example-docker-run-command" class="headerlink" title="Example docker run command"></a><a href="https://docs.docker.com/get-started/overview/#example-docker-run-command">Example docker run command</a></h5><p>The following command runs an <code>ubuntu</code> container, attaches interactively to your local command-line session, and runs <code>/bin/bash</code>.</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">$ docker <span class="hljs-keyword">run</span><span class="language-bash"> -i -t ubuntu /bin/bash</span><br></code></pre></td></tr></table></figure><p>When you run this command, the following happens (assuming you are using the default registry configuration):</p><ol><li><p>If you don’t have the <code>ubuntu</code> image locally, Docker pulls it from your configured registry, as though you had run <code>docker pull ubuntu</code> manually.</p></li><li><p>Docker creates a new container, as though you had run a <code>docker container create</code> command manually.</p></li><li><p>Docker allocates a read-write filesystem to the container, as its final layer. This allows a running container to create or modify files and directories in its local filesystem.</p></li><li><p>Docker creates a network interface to connect the container to the default network, since you didn’t specify any networking options. This includes assigning an IP address to the container. By default, containers can connect to external networks using the host machine’s network connection.</p></li><li><p>Docker starts the container and executes <code>/bin/bash</code>. Because the container is running interactively and attached to your terminal (due to the <code>-i</code> and <code>-t</code> flags), you can provide input using your keyboard while Docker logs the output to your terminal.</p></li><li><p>When you run <code>exit</code> to terminate the <code>/bin/bash</code> command, the container stops but isn’t removed. You can start it again or remove it.</p></li></ol><hr><h2 id="Docker完整架构"><a href="#Docker完整架构" class="headerlink" title="Docker完整架构"></a>Docker完整架构</h2><p>从 Docker 1.11 版本开始，Docker 容器运行就不是简单通过 Docker Daemon 来启动了，而是通过集成 containerd、runc 等多个组件来完成的。虽然 Docker Daemon 守护进程模块在不停的重构，但是基本功能和定位没有太大的变化，一直都是 CS 架构，守护进程负责和 Docker Client 端交互，并管理 Docker 镜像和容器。现在的架构中组件 containerd 就会负责集群节点上容器的生命周期管理，并向上为 Docker Daemon 提供 gRPC 接口。</p><p><img src="https://picdn.youdianzhishi.com/images/20210809154608.png" alt="docker 架构"></p><p>当我们要创建一个容器的时候，现在 Docker Daemon 并不能直接帮我们创建了，而是请求 <code>containerd</code> 来创建一个容器，containerd 收到请求后，也并不会直接去操作容器，而是创建一个叫做 <code>containerd-shim</code> 的进程，让这个进程去操作容器，我们指定容器进程是需要一个父进程来做状态收集、维持 stdin 等 fd 打开等工作的，假如这个父进程就是 containerd，那如果 containerd 挂掉的话，整个宿主机上所有的容器都得退出了，而引入 <code>containerd-shim</code> 这个垫片就可以来规避这个问题了。</p><p>然后创建容器需要做一些 namespaces 和 cgroups 的配置，以及挂载 root 文件系统等操作，这些操作其实已经有了标准的规范，那就是 OCI（开放容器标准），<code>runc</code> 就是它的一个参考实现.这个标准其实就是一个文档，主要规定了容器镜像的结构、以及容器需要接收哪些操作指令，比如 create、start、stop、delete 等这些命令。<code>runc</code> 就可以按照这个 OCI 文档来创建一个符合规范的容器，既然是标准肯定就有其他 OCI 实现，比如 Kata、gVisor 这些容器运行时都是符合 OCI 标准的。</p><p>所以真正启动容器是通过 <code>containerd-shim</code> 去调用 <code>runc</code> 来启动容器的，<code>runc</code> 启动完容器后本身会直接退出，<code>containerd-shim</code> 则会成为容器进程的父进程, 负责收集容器进程的状态, 上报给 containerd, 并在容器中 pid 为 1 的进程退出后接管容器中的子进程进行清理, 确保不会出现僵尸进程。</p>]]></content>
    
    
    <categories>
      
      <category>container</category>
      
    </categories>
    
    
    <tags>
      
      <tag>container</tag>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iptables详解</title>
    <link href="/2023/11/30/iptables%E8%AF%A6%E8%A7%A3/"/>
    <url>/2023/11/30/iptables%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p>防火墙，其实说白了讲，就是用于实现Linux下访问控制的功能的，它分为硬件的或者软件的防火墙两种。无论是在哪个网络中，防火墙工作的地方一定是在网络的边缘。而我们的任务就是需要去定义到底防火墙如何工作，这就是防火墙的策略，规则，以达到让它对出入网络的IP、数据进行检测。</p><p>目前市面上比较常见的有3、4层的防火墙，叫网络层的防火墙，还有7层的防火墙，其实是代理层的网关。</p><p>对于TCP&#x2F;IP的七层模型来讲，我们知道第三层是网络层，三层的防火墙会在这层对源地址和目标地址进行检测。但是对于七层的防火墙，不管你源端口或者目标端口，源地址或者目标地址是什么，都将对你所有的东西进行检查。所以，对于设计原理来讲，七层防火墙更加安全，但是这却带来了效率更低。所以市面上通常的防火墙方案，都是两者结合的。而又由于我们都需要从防火墙所控制的这个口来访问，所以防火墙的工作效率就成了用户能够访问数据多少的一个最重要的控制，配置的不好甚至有可能成为流量的瓶颈。</p><p><img src="https://2716750027-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-LlaUBNni4_0TG9UuF4O%2F-LlaUC6_aT-jhYVzesvT%2F-LlaUCpdSjavmSa4XDlu%2F1.png?generation=1565087556310544&alt=media"></p><p>iptables的前身叫ipfirewall （内核1.x时代）,这是一个作者从freeBSD上移植过来的，能够工作在内核当中的，对数据包进行检测的一款简易访问控制工具。但是ipfirewall工作功能极其有限(它需要将所有的规则都放进内核当中，这样规则才能够运行起来，而放进内核，这个做法一般是极其困难的)。当内核发展到2.x系列的时候，软件更名为ipchains，它可以定义多条规则，将他们串起来，共同发挥作用，而现在，它叫做iptables，可以将规则组成一个列表，实现绝对详细的访问控制功能。</p><p>他们都是工作在用户空间中，定义规则的工具，本身并不算是防火墙。它们定义的规则，可以让在内核空间当中的netfilter来读取，并且实现让防火墙工作。而放入内核的地方必须要是特定的位置，必须是tcp&#x2F;ip的协议栈经过的地方。而这个tcp&#x2F;ip协议栈必须经过的地方，可以实现读取规则的地方就叫做 netfilter.(网络过滤器)</p><ul><li><ol><li></li></ol><p>内核空间中：从一个网络接口进来，到另一个网络接口去的</p></li></ul><p>从上面的发展我们知道了作者选择了5个位置，来作为控制的地方，但是你有没有发现，其实前三个位置已经基本上能将路径彻底封锁了，但是为什么已经在进出的口设置了关卡之后还要在内部卡呢？ 由于数据包尚未进行路由决策，还不知道数据要走向哪里，所以在进出口是没办法实现数据过滤的。所以要在内核空间里设置转发的关卡，进入用户空间的关卡，从用户空间出去的关卡。那么，既然他们没什么用，那我们为什么还要放置他们呢？因为我们在做NAT和DNAT的时候，目标地址转换必须在路由之前转换。所以我们必须在外网而后内网的接口处进行设置关卡。</p><p>这五个位置也被称为五个钩子函数（hook functions）,也叫五个规则链。</p><p>这是NetFilter规定的五个规则链，任何一个数据包，只要经过本机，必将经过这五个链中的其中一个链。</p><p><img src="https://2716750027-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-LlaUBNni4_0TG9UuF4O%2F-LlaUC6_aT-jhYVzesvT%2F-LlaUCpfP6PsaTbNSWEH%2F2.png?generation=1565087556441446&alt=media"></p><ul><li><ol><li></li></ol><p>一个数据包进入网卡时，它首先进入PREROUTING链，内核根据数据包目的IP判断是否需要转发出去。</p></li><li><ol start="2"><li></li></ol><p>如果数据包就是进入本机的，它就会沿着图向下移动，到达INPUT链。数据包到了INPUT链后，任何进程都会收到它。本机上运行的程序可以发送数据包，这些数据包会经 过OUTPUT链，然后到达POSTROUTING链输出。</p></li><li><ol start="3"><li></li></ol><p>如果数据包是要转发出去的，且内核允许转发，数据包就会如图所示向右移动，经过 FORWARD链，然后到达POSTROUTING链输出。</p></li></ul><p>规则（rules）其实就是网络管理员预定义的条件，规则一般的定义为“如果数据包头符合这样的条件，就这样处理这个数据包”。规则存储在内核空间的信息包过滤表中，这些规则分别指定了源地址、目的地址、传输协议（如TCP、UDP、ICMP）和服务类型（如HTTP、FTP和SMTP）等。当数据包与规则匹配时，iptables就根据规则所定义的方法来处理这些数据包，如放行（accept）、拒绝（reject）和丢弃（drop）等。配置防火墙的主要工作就是添加、修改和删除这些规则。</p><p>链（chains）是数据包传播的路径，每一条链其实就是众多规则中的一个检查清单，每一条链中可以有一条或数条规则。当一个数据包到达一个链时，iptables就会从链中第一条规则开始检查，看该数据包是否满足规则所定义的条件。如果满足，系统就会根据该条规则所定义的方法处理该数据包；否则iptables将继续检查下一条规则，如果该数据包不符合链中任一条规则，iptables就会根据该链预先定义的默认策略来处理数据包。</p><p>表（tables）提供特定的功能，iptables内置了4个表，即raw表、filter表、nat表和mangle表，分别用于实现包过滤，网络地址转换和包重构的功能。</p><ul><li><p>RAW表：只使用在PREROUTING链和OUTPUT链上,因为优先级最高，从而可以对收到的数据包在连接跟踪前进行处理。一但用户使用了RAW表,在 某个链上,RAW表处理完后,将跳过NAT表和 ip_conntrack处理,即不再做地址转换和数据包的链接跟踪处理了.</p></li><li><p>filter表：主要用于过滤数据包，该表根据系统管理员预定义的一组规则过滤符合条件的数据包。对于防火墙而言，主要利用在filter表中指定的规则来实现对数据包的过滤。Filter表是默认的表，如果没有指定哪个表，iptables 就默认使用filter表来执行所有命令，filter表包含了INPUT链（处理进入的数据包），RORWARD链（处理转发的数据包），OUTPUT链（处理本地生成的数据包）在filter表中只能允许对数据包进行接受，丢弃的操作，而无法对数据包进行更改</p></li><li><p>nat表：主要用于网络地址转换NAT，该表可以实现一对一，一对多，多对多等NAT 工作，iptables就是使用该表实现共享上网的，NAT表包含了PREROUTING链（修改即将到来的数据包），POSTROUTING链（修改即将出去的数据包），OUTPUT链（修改路由之前本地生成的数据包）</p></li><li><p>mangle表：主要用于对指定数据包进行更改，在内核版本2.4.18 后的linux版本中该表包含的链为：INPUT链（处理进入的数据包），RORWARD链（处理转发的数据包），OUTPUT链（处理本地生成的数据包）POSTROUTING链（修改即将出去的数据包），PREROUTING链（修改即将到来的数据包）</p></li></ul><p><strong>Raw——&gt;mangle——&gt;nat——&gt;filter</strong></p><p>从外界到达防火墙的数据包，先被PREROUTING规则链处理（是否修改数据包地址等），之后会进行路由选择（判断该数据包应该发往何处），如果数据包 的目标主机是防火墙本机（比如说Internet用户访问防火墙主机中的web服务器的数据包），那么内核将其传给INPUT链进行处理（决定是否允许通 过等），通过以后再交给系统上层的应用程序（比如Apache服务器）进行响应。</p><p>来自外界的数据包到达防火墙后，首先被PREROUTING规则链处理，之后会进行路由选择，如果数据包的目标地址是其它外部地址（比如局域网用户通过网 关访问QQ站点的数据包），则内核将其传递给FORWARD链进行处理（是否转发或拦截），然后再交给POSTROUTING规则链（是否修改数据包的地 址等）进行处理。</p><p>防火墙本机向外部地址发送的数据包（比如在防火墙主机中测试公网DNS服务器时），首先被OUTPUT规则链处理，之后进行路由选择，然后传递给POSTROUTING规则链（是否修改数据包的地址等）进行处理。</p><p>iptables的命令格式较为复杂，一般的格式如下：</p><p>iptables [-t 表] -命令 匹配 操作</p><p>表选项用于指定命令应用于哪个iptables内置表。</p><p>命令选项用于指定iptables的执行方式，包括插入规则，删除规则和添加规则，如下表所示</p><p>-L –list &lt;链名&gt; 查看iptables规则列表</p><p>-A –append &lt;链名&gt; 在规则列表的最后增加1条规则</p><p>-I –insert &lt;链名&gt; 在指定的位置插入1条规则</p><p>-D –delete &lt;链名&gt; 从规则列表中删除1条规则</p><p>-R –replace &lt;链名&gt; 替换规则列表中的某条规则</p><p>-Z –zero &lt;链名&gt; 将表中数据包计数器和流量计数器归零</p><p>-X –delete-chain &lt;链名&gt; 删除自定义链</p><p>-v –verbose &lt;链名&gt; 与-L他命令一起使用显示更多更详细的信息</p><p>匹配选项指定数据包与规则匹配所具有的特征，包括源地址，目的地址，传输协议和端口号，如下表所示</p><p>-i –in-interface 网络接口名&gt; 指定数据包从哪个网络接口进入，</p><p>-o –out-interface 网络接口名&gt; 指定数据包从哪个网络接口输出</p><p>-p —proto 协议类型 指定数据包匹配的协议，如TCP、UDP和ICMP等</p><p>-s –source 源地址或子网&gt; 指定数据包匹配的源地址</p><p>--sport 源端口号&gt; 指定数据包匹配的源端口号</p><p>--dport 目的端口号&gt; 指定数据包匹配的目的端口号</p><p>-m –match 匹配的模块 指定数据包规则所使用的过滤模块</p><p>前面我们说过iptables处理动作除了 ACCEPT、REJECT、DROP、REDIRECT 、MASQUERADE 以外，还多出 LOG、ULOG、DNAT、RETURN、TOS、SNAT、MIRROR、QUEUE、TTL、MARK等。我们只说明其中最常用的动作：</p><ul><li>REJECT 拦阻该数据包，并返回数据包通知对方，可以返回的数据包有几个选择：ICMP port-unreachable、ICMP echo-reply 或是tcp-reset（这个数据包包会要求对方关闭联机），进行完此处理动作后，将不再比对其它规则，直接中断过滤程序。范例如下：</li></ul><p>iptables -A INPUT -p TCP –dport 22 -j REJECT –reject-with ICMP echo-reply</p><ul><li><p>DROP 丢弃数据包不予处理，进行完此处理动作后，将不再比对其它规则，直接中断过滤程序。</p></li><li><p>REDIRECT 将封包重新导向到另一个端口（PNAT），进行完此处理动作后，将会继续比对其它规则。这个功能可以用来实作透明代理 或用来保护web 服务器。例如：</p></li></ul><p>iptables -t nat -A PREROUTING -p tcp –dport 80 -j REDIRECT–to-ports 8081</p><ul><li>MASQUERADE 改写封包来源IP为防火墙的IP，可以指定port 对应的范围，进行完此处理动作后，直接跳往下一个规则链（mangle:postrouting）。这个功能与 SNAT 略有不同，当进行IP 伪装时，不需指定要伪装成哪个 IP，IP 会从网卡直接读取，当使用拨接连线时，IP 通常是由 ISP 公司的 DHCP服务器指派的，这个时候 MASQUERADE 特别有用。范例如下：</li></ul><p>iptables -t nat -A POSTROUTING -p TCP -j MASQUERADE –to-ports 21000-31000</p><ul><li>LOG 将数据包相关信息纪录在 &#x2F;var&#x2F;log 中，详细位置请查阅 &#x2F;etc&#x2F;syslog.conf 配置文件，进行完此处理动作后，将会继续比对其它规则。例如：</li></ul><p>iptables -A INPUT -p tcp -j LOG –log-prefix “input packet”</p><ul><li>SNAT 改写封包来源 IP 为某特定 IP 或 IP 范围，可以指定 port 对应的范围，进行完此处理动作后，将直接跳往下一个规则炼（mangle:postrouting）。范例如下：</li></ul><p>iptables -t nat -A POSTROUTING -p tcp-o eth0 -j SNAT –to-source 192.168.10.15-192.168.10.160:2100-3200</p><ul><li>DNAT 改写数据包包目的地 IP 为某特定 IP 或 IP 范围，可以指定 port 对应的范围，进行完此处理动作后，将会直接跳往下一个规则链（filter:input 或 filter:forward）。范例如下：</li></ul><p>iptables -t nat -A PREROUTING -p tcp -d 15.45.23.67 –dport 80 -j DNAT –to-destination 192.168.10.1-192.168.10.10:80-100</p><ul><li><p>MIRROR 镜像数据包，也就是将来源 IP与目的地IP对调后，将数据包返回，进行完此处理动作后，将会中断过滤程序。</p></li><li><p>QUEUE 中断过滤程序，将封包放入队列，交给其它程序处理。透过自行开发的处理程序，可以进行其它应用，例如：计算联机费用等。</p></li><li><p>RETURN 结束在目前规则链中的过滤程序，返回主规则链继续过滤，如果把自订规则炼看成是一个子程序，那么这个动作，就相当于提早结束子程序并返回到主程序中。</p></li><li><p>MARK 将封包标上某个代号，以便提供作为后续过滤的条件判断依据，进行完此处理动作后，将会继续比对其它规则。范例如下：</p></li></ul><p>iptables -t mangle -A PREROUTING -p tcp –dport 22 -j MARK –set-mark 22</p><p>iptables -L -n -v –line-numbers</p><p>iptables -L INPUT -n –line-numbers</p><p>iptables -L OUTPUT -n –line-numbers</p><p>iptables -L OUTPUT -n –line-numbers | less</p><p>iptables -L OUTPUT -n –line-numbers | grep 202.54.1.1</p><p>iptables -I INPUT 2 -s 202.54.1.2 -j DROP</p><p>iptables-restore &lt; &#x2F;root&#x2F;my.active.firewall.rules</p><p>iptables -A INPUT -i eth1 -s 192.168.0.0&#x2F;24 -j DROP</p><p>iptables -A INPUT -i eth1 -s 10.0.0.0&#x2F;8 -j DROP</p><p>iptables -A INPUT -s 1.2.3.4 -j DROP</p><p>iptables -A INPUT -s 192.168.0.0&#x2F;24 -j DROP</p><p>iptables -A INPUT -p tcp -s 1.2.3.4 –dport 80 -j DROP</p><p>iptables -A INPUT -i eth1 -p tcp -s 192.168.1.0&#x2F;24 –dport 80 -j DROP</p><p>iptables -A OUTPUT -d 192.168.1.0&#x2F;24 -j DROP</p><p>iptables -A OUTPUT -o eth1 -d 192.168.1.0&#x2F;24 -j DROP</p><p>iptables -A INPUT -i eth1 -s 10.0.0.0&#x2F;8 -j LOG –log-prefix “IP_SPOOF A: “</p><p>iptables -A INPUT -i eth1 -s 10.0.0.0&#x2F;8 -j DROP</p><p>iptables -A INPUT -m mac –mac-source 00:0F:EA:91:04:08 -j DROP</p><p>只接收MAC地址为00:0F:EA:91:04:07的TCP流量</p><p>iptables -A INPUT -p tcp –destination-port 22 -m mac –mac-source 00:0F:EA:91:04:07 -j ACCEPT</p><p>iptables -A INPUT -p icmp –icmp-type echo-request -j DROP</p><p>iptables -A INPUT -i eth1 -p icmp –icmp-type echo-request -j DROP</p><p>iptables -A INPUT -m state –state NEW -m tcp -p tcp –dport 7000:7010 -j ACCEPT</p><p>iptables -A INPUT -p tcp –destination-port 80 -m iprange –src-range 192.168.1.100-192.168.1.200 -j ACCEPT</p><p>如果想要删除一条规则，那么可以直接使用序号，例如 INPUT 的第 4 条可以直接这么删除</p>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
      <category>network</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>network</tag>
      
      <tag>iptables</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>容器网络模型</title>
    <link href="/2023/11/29/%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/"/>
    <url>/2023/11/29/%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="构建容器网络模型"><a href="#构建容器网络模型" class="headerlink" title="构建容器网络模型"></a>构建容器网络模型</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>在上一节中，通过 Linux 的网络虚拟化技术构建了一个网络，连接了容器的网络Namespace 和宿主机网络，其中做了命名空间创建、设备创建、地址分配、挂载设备和地址转换配置等操作，本节会将这些操作抽象出网络的模型以便于用代码实现上面一系列流程。</p><h2 id="2-模型"><a href="#2-模型" class="headerlink" title="2. 模型"></a>2. 模型</h2><p>首先，需要抽象出容器网络的两个对象：网络和网络端点。</p><h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><p>网络是容器的一个集合，在这个网络上的容器可以通过这个网络互相通信，就像挂载到同一个 Linux Bridge 设备上的网络设备一样， 可以直接通过 Bridge 设备实现网络互连;连接到同一个网络中的容器也可以通过这个网络和网络中别的容器互连。网络中会包括这个网络相关的配置，比如网络的容器地址段、网络操作所调用的网络驱动等信息。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Network <span class="hljs-keyword">struct</span> &#123;<br>Name    <span class="hljs-type">string</span>     <span class="hljs-comment">// 网络名</span><br>IPRange *net.IPNet <span class="hljs-comment">// 地址段</span><br>Driver  <span class="hljs-type">string</span>     <span class="hljs-comment">// 网络驱动名</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="网络端点"><a href="#网络端点" class="headerlink" title="网络端点"></a>网络端点</h3><p>网络端点是用于连接容器与网络的，保证容器内部与网络的通信。像上一节中用到的 Veth 设备，一端挂载到容器内部，另一端挂载到 Bridge 上，就能使得容器和网络的通信。</p><p>网络端点中会包括连接到网络的一些信息，比如地址、Veth 设备、端口映射、连接的容器和网络等信息。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Endpoint <span class="hljs-keyword">struct</span> &#123;<br>ID          <span class="hljs-type">string</span>           <span class="hljs-string">`json:&quot;id&quot;`</span><br>Device      netlink.Veth     <span class="hljs-string">`json:&quot;dev&quot;`</span><br>IPAddress   net.IP           <span class="hljs-string">`json:&quot;ip&quot;`</span><br>MacAddress  net.HardwareAddr <span class="hljs-string">`json:&quot;mac&quot;`</span><br>Network     *Network<br>PortMapping []<span class="hljs-type">string</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="网络驱动"><a href="#网络驱动" class="headerlink" title="网络驱动"></a>网络驱动</h3><p>网络驱动(Network Driver) 是一个网络功能中的组件，不同的驱动对网络的创建、连接、销毁的策略不同，通过在创建网络时指定不同的网络驱动来定义使用哪个驱动做网络的配置。</p><p>它的接口定义如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Driver <span class="hljs-keyword">interface</span> &#123;<br>Name() <span class="hljs-type">string</span><br>Create(subnet <span class="hljs-type">string</span>, name <span class="hljs-type">string</span>) (*Network, <span class="hljs-type">error</span>)<br>Delete(network Network) <span class="hljs-type">error</span><br>Connect(network *Network, endpoint *Endpoint) <span class="hljs-type">error</span><br>Disconnect(network Network, endpoint *Endpoint) <span class="hljs-type">error</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="IPAM"><a href="#IPAM" class="headerlink" title="IPAM"></a>IPAM</h3><p>IPAM(IP Address Management) 也是网络功能中的一个组件，用于网络 IP 地址的分配和释放，包括容器的IP地址和网络网关的IP地址，它的主要功能如下。</p><ul><li>IPAM.Allocate(subnet *net.IPNet) 从指定的 subnet 网段中分配 IP 地址</li><li>IPAM.Release(subnet net.IPNet, ipaddr net.IP) 从指定的 subnet 网段中释放掉指定的 IP 地址。</li></ul><h2 id="3-调用关系"><a href="#3-调用关系" class="headerlink" title="3. 调用关系"></a>3. 调用关系</h2><h3 id="创建网络"><a href="#创建网络" class="headerlink" title="创建网络"></a>创建网络</h3><p>通过<code>mydocker network create</code>命令创建一个容器网络：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mydocker network create --subset 192.168.0.0/24 --deive bridge testbr<br></code></pre></td></tr></table></figure><p>通过 Bridge 网络驱动创建一个网络，网段是 192.168.0.0&#x2F;24。</p><p>具体流程如下图所示：</p><!-- ![](/source/_posts/容器网络模型/网络创建流程.png) --><p><img src="https://github.com/lixd/daily-notes/raw/master/Golang/mydocker/assets/%E7%BD%91%E7%BB%9C%E5%88%9B%E5%BB%BA%E6%B5%81%E7%A8%8B.png"></p><p>在调用命令创建网络时，先通过 IPAM 获取网络的网关 IP,然后再调用网络驱动去设置网络的信息，比如 Bridge 的驱动将会创建 Linux Bridge 网络设备和相应的<br>iptables规则，最终将网络的信息返回给调用者。</p><p>上图中的 IPAM 和 Network Driver 是两个组件，IPAM 负责通过传入的IP网段去分配一个可用的 IP 地址给容器和网络的网关，比如网络的网段是 192.168.0.0&#x2F;16， 那么通过 IPAM 获取这个网段的容器地址就是在这个网段中的一个 IP 地址，然后用于分配给容器的连接端点，保证网络中的容器 IP 不会冲突。</p><p>而 Network Driver 是用于网络的管理的，例如在创建网络时完成网络初始化动作及在容器启动时完成网络端点配置。像 Bridge 的驱动对应的动作就是创建 Linux Bridge 和挂载 Veth 设备。</p><h3 id="创建容器并连接网络"><a href="#创建容器并连接网络" class="headerlink" title="创建容器并连接网络"></a>创建容器并连接网络</h3><p>通过创建容器时指定<code>-net</code> 参数，指定容器启动时连接的网络。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mydocker run -it -p 80:80 --net testbridgenet xxxx<br></code></pre></td></tr></table></figure><p>这样创建出的容器便可以通过 testbridgenet 这个网络与网络中的其他容器进行通信了。</p><p>具体流程图如下：<br><img src="https://github.com/lixd/daily-notes/raw/master/Golang/mydocker/assets/%E5%AE%B9%E5%99%A8%E5%8A%A0%E5%85%A5%E7%BD%91%E7%BB%9C%E6%B5%81%E7%A8%8B.png"><br>在调用创建容器时指定网络，首先会调用IPAM,通过网络中定义的网段找到未分配的 IP 分配给容器，然后创建容器的网络端点，并调用这个网络的网络驱动连接网络与网络端点，最终完成网络端点的连接和配置。比如在 Bridge 驱动中就会将Veth 设备挂载到 Linux Bridge 网桥上。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Connect</span><span class="hljs-params">(networkName <span class="hljs-type">string</span>, info *container.Info)</span></span> <span class="hljs-type">error</span> &#123;<br><span class="hljs-comment">// 从networks字典中取到容器连接的网络的信息，networks字典中保存了当前己经创建的网络</span><br>network, ok := networks[networkName]<br><span class="hljs-keyword">if</span> !ok &#123;<br><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;no Such Network: %s&quot;</span>, networkName)<br>&#125;<br><br><span class="hljs-comment">// 分配容器IP地址</span><br>ip, err := ipAllocator.Allocate(network.IpRange)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><br><span class="hljs-comment">// 创建网络端点</span><br>ep := &amp;Endpoint&#123;<br>ID:          fmt.Sprintf(<span class="hljs-string">&quot;%s-%s&quot;</span>, cinfo.Id, networkName),<br>IPAddress:   ip,<br>Network:     network,<br>PortMapping: info.PortMapping,<br>&#125;<br><span class="hljs-comment">// 调用网络驱动挂载和配置网络端点</span><br><span class="hljs-keyword">if</span> err = drivers[network.Driver].Connect(network, ep); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><span class="hljs-comment">// 到容器的namespace配置容器网络设备IP地址</span><br><span class="hljs-keyword">if</span> err = configEndpointIpAddressAndRoute(ep, info); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><br><span class="hljs-keyword">return</span> configPortMapping(ep, info)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="展示网络列表"><a href="#展示网络列表" class="headerlink" title="展示网络列表"></a>展示网络列表</h3><p>通过 <code>mydocker network list</code>命令显示当前创建了哪些网络。</p><p>首先从网络配置的目录中加载所有的网络配置信息到 networks 字典中，如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Init</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span> &#123;<br><span class="hljs-comment">// 加载网络驱动</span><br><span class="hljs-keyword">var</span> bridgeDriver = BridgeNetworkDriver&#123;&#125;<br>drivers[bridgeDriver.Name()] = &amp;bridgeDriver<br><span class="hljs-comment">// 文件不存在则创建</span><br><span class="hljs-keyword">if</span> _, err := os.Stat(defaultNetworkPath); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">if</span> !os.IsNotExist(err) &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><span class="hljs-keyword">if</span> err = os.MkdirAll(defaultNetworkPath, constant.Perm0644); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br>&#125;<br><span class="hljs-comment">// 检查网络配置目录中的所有文件,并执行第二个参数中的函数指针去处理目录下的每一个文件</span><br>err := filepath.Walk(defaultNetworkPath, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(nwPath <span class="hljs-type">string</span>, info os.FileInfo, err <span class="hljs-type">error</span>)</span></span> <span class="hljs-type">error</span> &#123;<br><span class="hljs-comment">// 如果是目录则跳过</span><br><span class="hljs-keyword">if</span> info.IsDir() &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><span class="hljs-comment">// if strings.HasSuffix(nwPath, &quot;/&quot;) &#123;</span><br><span class="hljs-comment">// return nil</span><br><span class="hljs-comment">// &#125;</span><br><span class="hljs-comment">//  加载文件名作为网络名</span><br>_, nwName := path.Split(nwPath)<br>nw := &amp;Network&#123;<br>Name: nwName,<br>&#125;<br><span class="hljs-comment">// 调用前面介绍的 Network.load 方法加载网络的配置信息</span><br><span class="hljs-keyword">if</span> err = nw.load(nwPath); err != <span class="hljs-literal">nil</span> &#123;<br>logrus.Errorf(<span class="hljs-string">&quot;error load network: %s&quot;</span>, err)<br>&#125;<br><span class="hljs-comment">// 将网络的配置信息加入到 networks 字典中</span><br>networks[nwName] = nw<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;)<br><span class="hljs-keyword">return</span> err<br>&#125;<br></code></pre></td></tr></table></figure><p>上面己经把网络配置目录中的所有网络配置加载到了 networks 典中， 然后通过遍历这个字典来展示创建的网络，如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ListNetwork</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 通过tabwriter库把信息打印到屏幕上</span><br>w := tabwriter.NewWriter(os.Stdout, <span class="hljs-number">12</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-number">0</span>)<br>fmt.Fprint(w, <span class="hljs-string">&quot;NAME\tIpRange\tDriver\n&quot;</span>)<br><span class="hljs-keyword">for</span> _, nw := <span class="hljs-keyword">range</span> networks &#123;<br>fmt.Fprintf(w, <span class="hljs-string">&quot;%s\t%s\t%s\n&quot;</span>,<br>nw.Name,<br>nw.IPRange.String(),<br>nw.Driver,<br>)<br>&#125;<br><span class="hljs-keyword">if</span> err := w.Flush(); err != <span class="hljs-literal">nil</span> &#123;<br>logrus.Errorf(<span class="hljs-string">&quot;Flush error %v&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="删除网络"><a href="#删除网络" class="headerlink" title="删除网络"></a>删除网络</h3><p>通过使用命令 <code>mydocker network remove</code>命令删除己经创建的网络。</p><p>具体流程如下图：</p><p><img src="https://github.com/lixd/daily-notes/blob/master/Golang/mydocker/assets/%E7%BD%91%E7%BB%9C%E5%88%A0%E9%99%A4%E6%B5%81%E7%A8%8B.png"></p><!-- <img src="/2023/11/29/%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/%E7%BD%91%E7%BB%9C%E5%88%A0%E9%99%A4%E6%B5%81%E7%A8%8B.png" class="" title="This is an example image"> --><ul><li>1）先调用 IPAM 去释放网络所占用的网关 IP</li><li>2）然后调用网络驱动去删除该网络创建的一些设备与配置</li><li>3）最终从网络配置目录中删除网络对应的配置文</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">DeleteNetwork</span><span class="hljs-params">(networkName <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">error</span> &#123;<br><span class="hljs-comment">// 网络不存在直接返回一个error</span><br>nw, ok := networks[networkName]<br><span class="hljs-keyword">if</span> !ok &#123;<br><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;no Such Network: %s&quot;</span>, networkName)<br>&#125;<br><span class="hljs-comment">// 调用IPAM的实例ipAllocator释放网络网关的IP</span><br><span class="hljs-keyword">if</span> err := ipAllocator.Release(nw.IpRange, &amp;nw.IpRange.IP); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> errors.Wrap(err, <span class="hljs-string">&quot;remove Network gateway ip failed&quot;</span>)<br>&#125;<br><span class="hljs-comment">// 调用网络驱动删除网络创建的设备与配置 后面会以 Bridge 驱动删除网络为例子介绍如何实现网络驱动删除网络</span><br><span class="hljs-keyword">if</span> err := drivers[nw.Driver].Delete(*nw); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> errors.Wrap(err, <span class="hljs-string">&quot;remove Network DriverError failed&quot;</span>)<br>&#125;<br><span class="hljs-comment">// 最后从网络的配直目录中删除该网络对应的配置文件</span><br><span class="hljs-keyword">return</span> nw.remove(defaultNetworkPath)<br>&#125;<br><br></code></pre></td></tr></table></figure><p>其中 network remove 会从网络配置目录中删除网络的配置文件。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(nw *Network)</span></span> remove(dumpPath <span class="hljs-type">string</span>) <span class="hljs-type">error</span> &#123;<br><span class="hljs-comment">// 检查网络对应的配置文件状态，如果文件己经不存在就直接返回</span><br>fullPath := path.Join(dumpPath, nw.Name)<br><span class="hljs-keyword">if</span> _, err := os.Stat(fullPath); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">if</span> !os.IsNotExist(err) &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><span class="hljs-comment">// 否则删除这个网络对应的配置文件</span><br><span class="hljs-keyword">return</span> os.Remove(fullPath)<br>&#125;<br></code></pre></td></tr></table></figure><p>转载自：<a href="https://github.com/lixd/mydocker">https://github.com/lixd/mydocker</a></p>]]></content>
    
    
    <categories>
      
      <category>container</category>
      
    </categories>
    
    
    <tags>
      
      <tag>container</tag>
      
      <tag>virtual network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux虚拟网络设备</title>
    <link href="/2023/11/29/linux%E8%99%9A%E6%8B%9F%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/"/>
    <url>/2023/11/29/linux%E8%99%9A%E6%8B%9F%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/</url>
    
    <content type="html"><![CDATA[<h2 id="Linux-虚拟网络设备"><a href="#Linux-虚拟网络设备" class="headerlink" title="Linux 虚拟网络设备"></a>Linux 虚拟网络设备</h2><h3 id="Linux-Veth"><a href="#Linux-Veth" class="headerlink" title="Linux Veth"></a>Linux Veth</h3><h4 id="veth-pair"><a href="#veth-pair" class="headerlink" title="veth-pair"></a>veth-pair</h4><p>顾名思义，veth-pair 就是一对的虚拟设备接口，和 tap&#x2F;tun 设备不同的是，它都是成对出现的。一端连着协议栈，一端彼此相连着。</p><p>一般用于跨 namespace 通信。</p><blockquote><p>Linux 中默认不同 net namespace 设备无法通信。</p></blockquote><h4 id="网络命名空间"><a href="#网络命名空间" class="headerlink" title="网络命名空间"></a>网络命名空间</h4><p>为了支持网络协议栈的多个实例，Linux在网络栈中引入了网络命名空间。这些独立的协议栈被隔离到不同的命名空间中。</p><h4 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h4><p>本次演示中，先创建一个网络命名空间，然后创建一个 veth 设备对，将设备对分别切换到不同的命名空间中，实现不同命名空间的互相通信。</p><p>准备一个 net namespace</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 1创建 namespace</span><br>$ ip netns add netns1<br><span class="hljs-comment"># 查询</span><br>$ ip netns list<br>netns1 (<span class="hljs-built_in">id</span>: 0)<br></code></pre></td></tr></table></figure><p>创建两个Veth设备对</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># ip link add &lt;veth name&gt; type veth peer name &lt;peer name&gt;</span><br>$ ip <span class="hljs-built_in">link</span> add veth0 <span class="hljs-built_in">type</span> veth peer name veth1<br><span class="hljs-comment"># 查询</span><br>$ ip <span class="hljs-built_in">link</span> show<br></code></pre></td></tr></table></figure><p>此时两个 veth 都在默认 net namespace 中，为了测试，先将其中一个切换到 netns1</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> veth1 netns netns1<br><span class="hljs-comment"># 此时再看就只能看到一个了</span><br>$ ip <span class="hljs-built_in">link</span> show<br><span class="hljs-comment"># 去 netns 中查询</span><br>$ ip netns <span class="hljs-built_in">exec</span> netns1 ip <span class="hljs-built_in">link</span> show<br></code></pre></td></tr></table></figure><p>至此，两个不同的命名空间各自有一个Veth，不过还不能通信，因为我们还没给它们分配IP</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ ip netns <span class="hljs-built_in">exec</span> netns1 ip addr add 10.1.1.1/24 dev veth1<br>$ ip addr add 10.1.1.2/24 dev veth0<br></code></pre></td></tr></table></figure><p>再启动它们</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ ip netns <span class="hljs-built_in">exec</span> netns1 ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> dev veth1 up<br>$ ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> dev veth0 up<br></code></pre></td></tr></table></figure><p>现在两个网络命名空间可以互相通信了</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ ping 10.1.1.1<br></code></pre></td></tr></table></figure><p>至此，Veth设备对的基本原理和用法演示结束。</p><blockquote><p>Docker 内部，Veth设备对也是连通容器与宿主机的主要网络设备。</p></blockquote><h3 id="Linux-Bridge"><a href="#Linux-Bridge" class="headerlink" title="Linux Bridge"></a>Linux Bridge</h3><p>Bridge 虚拟设备是用来桥接的网络设备，它相当于现实世界中的交换机，可以连接不同的网络设备，当请求到达 Bridge 设备时，可以通过报文中的 Mac 地址进行广播或转发。</p><p>例如，我们可以创建一个 Bridge 设备来连接 Namespace 中的网络设备和宿主机上的网络。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">创建veth设备并将一端移动到指定Namespace中</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo ip netns add ns1</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo ip <span class="hljs-built_in">link</span> add veth0 <span class="hljs-built_in">type</span> veth peer name veth1</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> veth1 netns ns1</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">先安装bridge-utils</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo apt-get install bridge-utils</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">创建网桥,</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo brctl addbr br0</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">挂载网络设备</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo brctl addif br0 eth0</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo brctl addif br0 veth0</span><br></code></pre></td></tr></table></figure><p><a href="https://zhuanlan.zhihu.com/p/339070912">linux bridge实践</a></p><h2 id="3-Linux-路由表"><a href="#3-Linux-路由表" class="headerlink" title="3. Linux 路由表"></a>3. Linux 路由表</h2><p>路由表是 Linux 内核的一个模块，通过定义路由表来决定在某个网络Namespace 中包的流向，从而定义请求会到哪个网络设备上。</p><p>继续以上面的例子演示</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">启动宿主机上的虚拟网络设备，</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> veth0 up</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> br0 up</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">给ns1中的虚拟网络设备设置IP并启动它</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo ip netns <span class="hljs-built_in">exec</span> ns1 ip addr add 172.18.0.2/24 dev veth1</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo ip netns <span class="hljs-built_in">exec</span> ns1 ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> dev veth1 up</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">分别设置ns1网络空间的路由和宿主机上的路由</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">default代表0.0.0.0/0,即在Net Namespace中的所有流量都经过veth1的网络设备流出</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo apt-get install net-tools</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo ip netns <span class="hljs-built_in">exec</span> ns1  route add default dev veth1</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">在宿主机上将172.18.0.0/24网段的请求路由到br0网桥</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo route add -net 172.18.0.0/24 dev br0</span><br></code></pre></td></tr></table></figure><p>通过设置路由，对IP地址的请求就能正确被路由到对应的网络设备上，从而实现通信，如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">查看宿主机的IP地址</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo ip addr show eth0</span><br>6: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq master br0 state UP group default qlen 1000<br>    link/ether 00:15:5d:ff:cd:9a brd ff:ff:ff:ff:ff:ff<br>    inet 172.20.160.67/20 brd 172.20.175.255 scope global eth0<br>       valid_lft forever preferred_lft forever<br>    inet6 fe80::215:5dff:feff:cd9a/64 scope link<br>       valid_lft forever preferred_lft forever<br><span class="hljs-meta prompt_">#</span><span class="language-bash">从Namespace中访问宿主机的地址</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo ip netns <span class="hljs-built_in">exec</span> ns1 ping -c 1 172.20.160.67</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">从宿主机访问Namespace中的网络地址</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">ping -c 1 172.18.0.2</span><br></code></pre></td></tr></table></figure><p>到此就实现了通过网桥连接不同Namespace网络了。</p><h2 id="4-Linux-iptables"><a href="#4-Linux-iptables" class="headerlink" title="4. Linux iptables"></a>4. Linux iptables</h2><p>iptables 是对 Linux 内核的 netfilter 模块进行操作和展示的工具，用来管理包的流动和转送。iptables 定义了一套链式处理的结构，在网络包传输的各个阶段可以使用不同的策略对包进行加工、传送或丢弃。</p><p>在容器虚拟化的技术中，经常会用到两种策略 MASQUERADE 和 DNAT，用于容器和宿主机外部的网络通信。</p><h3 id="MASQUERADE"><a href="#MASQUERADE" class="headerlink" title="MASQUERADE"></a>MASQUERADE</h3><p>iptables 中的 MASQUERADE 策略可以将请求包中的源地址转换成一个网络设备的地址。</p><p>比如上述例子中的那个 Namespace 中网络设备的地址是 172.18.0.2, 这个地址虽然在宿主机上可以路由到 br0 网桥，但是到达宿主机外部之后，是不知道如何路由到这个 IP 地址的，所以如果要请求外部地址的话，需要先通过MASQUERADE 策略将这个 IP 转换成宿主机出口网卡的 IP。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">打开IP转发</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo sysctl -w net.ipv4.conf.all.forwarding=1</span><br>net.ipv4.conf.all.forwarding = 1<br><span class="hljs-meta prompt_">#</span><span class="language-bash">对Namespace中发出的包添加网络地址转换</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo iptables -t nat -A POSTROUTING -s 172.18.0.0/24 -o eth0 -j MASQUERADE</span><br></code></pre></td></tr></table></figure><p>在 Namespace 中请求宿主机外部地址时，将 Namespace 中的源地址转换成宿主机的地址作为源地址，就可以在 Namespace 中访问宿主机外的网络了。</p><h3 id="DNAT"><a href="#DNAT" class="headerlink" title="DNAT"></a>DNAT</h3><p>iptables 中的 DNAT 策略也是做网络地址的转换，不过它是要更换目标地址，经常用于将内部网络地址的端口映射到外部去。</p><p>比如，上面那个例子中的 Namespace 如果需要提供服务给宿主机之外的应用去请求要怎么办呢?</p><p>外部应用没办法直接路由到 172.18.0.2 这个地址，这时候就可以用到 DNAT 策略。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">将宿主机上80端口的请求转发到Namespace里的IP上</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo iptables -t nat -A PREROUTING -p tcp -m tcp --dport 80 -j DNAT --to-destination 172.18.0.2:80</span><br></code></pre></td></tr></table></figure><p>这样就可以把宿主机上 80 端口的 TCP 请求转发到 Namespace 中的地址172.18.0.2:80,从而实现外部的应用调用。</p><h2 id="5-Go语言网络库"><a href="#5-Go语言网络库" class="headerlink" title="5. Go语言网络库"></a>5. Go语言网络库</h2><p>容器网络用到的技术就是上面提到的几个点，不过用 Go 语言该怎么配置呢？</p><p>Go 中需要用到的几个网络库介绍。</p><h3 id="net-库"><a href="#net-库" class="headerlink" title="net 库"></a>net 库</h3><p>net 库是 Go 语言内置的库，提供了跨平台支持的网络地址处理，以及各种常见协议的IO支持，比如TCP、UDP、DNS、Unix Socket等。</p><h3 id="netlink库"><a href="#netlink库" class="headerlink" title="netlink库"></a>netlink库</h3><p><a href="https://github.com/vishvananda/netlink">netlink库</a> 是Go 语言的操作网络接口、路由表等配置的库 ，使用它的调用相当于我们通过 IP 命令去管理网络接口。</p><h3 id="netns库"><a href="#netns库" class="headerlink" title="netns库"></a>netns库</h3><p><a href="https://github.com/vishvananda/netns">netns库</a> 就是 Go 语言版的<code>ip netns exec</code> 命令实现。通过这个库可以让 netlink 库中配置网络接口的代码在某个容器的 Net amespace 中执行。</p><h3 id="单节点容器相互访问"><a href="#单节点容器相互访问" class="headerlink" title="单节点容器相互访问"></a>单节点容器相互访问</h3><p><img src="https://pic2.zhimg.com/v2-b3b33ed53fdfd86fff8ace576528f671_b.jpg"></p><p><img src="https://pic2.zhimg.com/80/v2-b3b33ed53fdfd86fff8ace576528f671_1440w.webp"></p><p>veth pair的一端在network namespace中，另一端接在了linux bridge上，所以图中的veth00&#x2F;veth01就变为了从设备（linux bridge），即他们就变为了网线，没有了处理数据包的能力，只能转发数据包。</p><p>以192.268.3.101（container1） → 192.268.3.106（container2）为例：</p><p>1、 container1发送APR请求得到container2的mac地址</p><p>2、 container1的这个请求出现在了docker0网桥</p><p>3、 docker0网桥将ARP广播转发到其他接在docker0上的设备</p><p>4、 container2收到这个ARP请求，响应给container1</p><p>5、 container1拿到mac地址封装ICMP请求</p><p>6、 同样这个请求也会经由docker0出现在宿主机上</p><p>7、 docker0查到container2属于自己就转发给了container2</p><h3 id="容器访问外部网络"><a href="#容器访问外部网络" class="headerlink" title="容器访问外部网络"></a>容器访问外部网络</h3><p><img src="https://pic3.zhimg.com/v2-f7891b35584bd9a960fb042e1a651206_b.jpg"></p><p><img src="https://pic3.zhimg.com/80/v2-f7891b35584bd9a960fb042e1a651206_1440w.webp"></p><p>以图中的container2要访问百度为例：</p><p>1、 container2 ping 220.181.38.148</p><p>2、 数据包同样会到达docker0网桥，即到达了宿主机</p><p>3、宿主机发现目的目的网段要交给eth0处理</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">~# route -n<br>Kernel IP routing table<br>Destination     Gateway         Genmask         Flags Metric Ref    Use Iface<br>0.0.0.0         172.28.143.253  0.0.0.0         UG    100    0        0 eth0<br>172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 docker0<br></code></pre></td></tr></table></figure><p>4、 由于源ip是内网ip还要进行一个NAT，通过eth0发到外网</p><p>转载自: <a href="https://github.com/lixd/daily-notes/blob/master/Golang/mydocker/06-1-%E7%BD%91%E7%BB%9C%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF.md">https://github.com/lixd/daily-notes/blob/master/Golang/mydocker/06-1-%E7%BD%91%E7%BB%9C%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF.md</a></p>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
      <category>network</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux mount用法</title>
    <link href="/2023/11/28/systemcall-mount%E5%88%86%E7%B1%BB/"/>
    <url>/2023/11/28/systemcall-mount%E5%88%86%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="mount-–bind"><a href="#mount-–bind" class="headerlink" title="mount –bind"></a>mount –bind</h2><p>我们可以通过mount –bind命令来将两个目录连接起来，mount –bind命令是将前一个目录挂载到后一个目录上，所有对后一个目录的访问其实都是对前一个目录的访问，如下所示：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-comment">## test1 test2为两个不同的目录</span><br>linux-<span class="hljs-title class_">UMLhEm</span><span class="hljs-symbol">:/home/test/linux</span> <span class="hljs-comment"># ls test1</span><br><span class="hljs-number">11</span>.test  <span class="hljs-number">1</span>.test<br>linux-<span class="hljs-title class_">UMLhEm</span><span class="hljs-symbol">:/home/test/linux</span> <span class="hljs-comment"># ls test2</span><br><span class="hljs-number">22</span>.test  <span class="hljs-number">2</span>.test<br>linux-<span class="hljs-title class_">UMLhEm</span><span class="hljs-symbol">:/home/test/linux</span> <span class="hljs-comment"># ls -lid test1</span><br><span class="hljs-number">1441802</span> drwx------ <span class="hljs-number">2</span> root root <span class="hljs-number">4096</span> <span class="hljs-title class_">Feb</span> <span class="hljs-number">13</span> 09<span class="hljs-symbol">:</span><span class="hljs-number">50</span> test1<br>linux-<span class="hljs-title class_">UMLhEm</span><span class="hljs-symbol">:/home/test/linux</span> <span class="hljs-comment"># ls -lid test2</span><br><span class="hljs-number">1441803</span> drwx------ <span class="hljs-number">2</span> root root <span class="hljs-number">4096</span> <span class="hljs-title class_">Feb</span> <span class="hljs-number">13</span> 09<span class="hljs-symbol">:</span><span class="hljs-number">51</span> test2<br><br><span class="hljs-comment">## 执行mount --bind 将test1挂载到test2上，inode号都变为test1的inode</span><br>linux-<span class="hljs-title class_">UMLhEm</span><span class="hljs-symbol">:/home/test/linux</span> <span class="hljs-comment"># mount --bind test1 test2</span><br>linux-<span class="hljs-title class_">UMLhEm</span><span class="hljs-symbol">:/home/test/linux</span> <span class="hljs-comment"># ls -lid test1</span><br><span class="hljs-number">1441802</span> drwx------ <span class="hljs-number">2</span> root root <span class="hljs-number">4096</span> <span class="hljs-title class_">Feb</span> <span class="hljs-number">13</span> 09<span class="hljs-symbol">:</span><span class="hljs-number">50</span> test1<br>linux-<span class="hljs-title class_">UMLhEm</span><span class="hljs-symbol">:/home/test/linux</span> <span class="hljs-comment"># ls -lid test2</span><br><span class="hljs-number">1441802</span> drwx------ <span class="hljs-number">2</span> root root <span class="hljs-number">4096</span> <span class="hljs-title class_">Feb</span> <span class="hljs-number">13</span> 09<span class="hljs-symbol">:</span><span class="hljs-number">50</span> test2<br>linux-<span class="hljs-title class_">UMLhEm</span><span class="hljs-symbol">:/home/test/linux</span> <span class="hljs-comment"># ls test2</span><br><span class="hljs-number">11</span>.test  <span class="hljs-number">1</span>.test<br><br><span class="hljs-comment">## 对test2的访问或修改实际上是改动test1目录</span><br>linux-<span class="hljs-title class_">UMLhEm</span><span class="hljs-symbol">:/home/test/linux</span> <span class="hljs-comment"># cd test2</span><br>linux-<span class="hljs-title class_">UMLhEm</span><span class="hljs-symbol">:/home/test/linux/test2</span> <span class="hljs-comment"># touch 3.test</span><br>linux-<span class="hljs-title class_">UMLhEm</span><span class="hljs-symbol">:/home/test/linux/test2</span> <span class="hljs-comment"># ls</span><br><span class="hljs-number">11</span>.test  <span class="hljs-number">1</span>.test  <span class="hljs-number">3</span>.test<br>linux-<span class="hljs-title class_">UMLhEm</span><span class="hljs-symbol">:/home/test/linux/test2</span> <span class="hljs-comment"># cd ..</span><br>linux-<span class="hljs-title class_">UMLhEm</span><span class="hljs-symbol">:/home/test/linux</span> <span class="hljs-comment"># ls test1</span><br><span class="hljs-number">11</span>.test  <span class="hljs-number">1</span>.test  <span class="hljs-number">3</span>.test<br><br><span class="hljs-comment">## 解挂载后，test1目录保持修改，test2保持不变</span><br>linux-<span class="hljs-title class_">UMLhEm</span><span class="hljs-symbol">:/home/test/linux</span> <span class="hljs-comment"># umount test2</span><br>linux-<span class="hljs-title class_">UMLhEm</span><span class="hljs-symbol">:/home/test/linux</span> <span class="hljs-comment"># ls test1</span><br><span class="hljs-number">11</span>.test  <span class="hljs-number">1</span>.test  <span class="hljs-number">3</span>.test<br>linux-<span class="hljs-title class_">UMLhEm</span><span class="hljs-symbol">:/home/test/linux</span> <span class="hljs-comment"># ls test2</span><br><span class="hljs-number">22</span>.test  <span class="hljs-number">2</span>.test<br><br><span class="hljs-comment">## 将test2挂载到test1上</span><br>linux-<span class="hljs-title class_">UMLhEm</span><span class="hljs-symbol">:/home/test/linux</span> <span class="hljs-comment"># ls -lid test2</span><br><span class="hljs-number">1441803</span> drwx------ <span class="hljs-number">2</span> root root <span class="hljs-number">4096</span> <span class="hljs-title class_">Feb</span> <span class="hljs-number">13</span> 09<span class="hljs-symbol">:</span><span class="hljs-number">51</span> test2<br>linux-<span class="hljs-title class_">UMLhEm</span><span class="hljs-symbol">:/home/test/linux</span> <span class="hljs-comment"># mount --bind test2 test1</span><br>linux-<span class="hljs-title class_">UMLhEm</span><span class="hljs-symbol">:/home/test/linux</span> <span class="hljs-comment"># ls -lid test1</span><br><span class="hljs-number">1441803</span> drwx------ <span class="hljs-number">2</span> root root <span class="hljs-number">4096</span> <span class="hljs-title class_">Feb</span> <span class="hljs-number">13</span> 09<span class="hljs-symbol">:</span><span class="hljs-number">51</span> test1<br>linux-<span class="hljs-title class_">UMLhEm</span><span class="hljs-symbol">:/home/test/linux</span> <span class="hljs-comment"># ls -lid test2</span><br><span class="hljs-number">1441803</span> drwx------ <span class="hljs-number">2</span> root root <span class="hljs-number">4096</span> <span class="hljs-title class_">Feb</span> <span class="hljs-number">13</span> 09<span class="hljs-symbol">:</span><span class="hljs-number">51</span> test2<br>linux-<span class="hljs-title class_">UMLhEm</span><span class="hljs-symbol">:/home/test/linux</span> <span class="hljs-comment"># ls test1</span><br><span class="hljs-number">22</span>.test  <span class="hljs-number">2</span>.test<br></code></pre></td></tr></table></figure><p>以mount –bind test1 test2为例，当mount –bind命令执行后，Linux将会把被挂载目录的目录项（也就是该目录文件的block，记录了下级目录的信息）屏蔽，即test2的下级路径被隐藏起来了（注意，只是隐藏不是删除，数据都没有改变，只是访问不到了）。同时，内核将挂载目录（test1）的目录项记录在内存里的一个s_root对象里，在mount命令执行时，VFS会创建一个vfsmount对象，这个对象里包含了整个文件系统所有的mount信息，其中也会包括本次mount中的信息，这个对象是一个HASH值对应表（HASH值通过对路径字符串的计算得来），表里就有 &#x2F;test1 到 &#x2F;test2 两个目录的HASH值对应关系。</p><p>命令执行完后，当访问 &#x2F;test2下的文件时，系统会告知 &#x2F;test2 的目录项被屏蔽掉了，自动转到内存里找VFS，通过vfsmount了解到 &#x2F;test2 和 &#x2F;test1 的对应关系，从而读取到 &#x2F;test1 的inode，这样在 &#x2F;test2 下读到的全是 &#x2F;test1 目录下的文件。</p><blockquote><ul><li>.mount –bind连接的两个目录的inode号码并不一样，只是被挂载目录的block被屏蔽掉，inode被重定向到挂载目录的inode（被挂载目录的inode和block依然没变）。</li><li>.两个目录的对应关系存在于内存里，一旦重启挂载关系就不存在了。</li></ul></blockquote><p>在固件开发过程中常常遇到这样的情况：为测试某个新功能，必需修改某个系统文件。而这个文件在只读文件系统上（总不能为一个小小的测试就重刷固件吧），或者是虽然文件可写，但是自己对这个改动没有把握，不愿意直接修改。这时候mount –bind就是你的好帮手。 <br>假设我们要改的文件是&#x2F;etc&#x2F;hosts，可按下面的步骤操作： <br>1. 把新的hosts文件放在&#x2F;tmp下。当然也可放在硬盘或U盘上。 <br>2. mount –bind &#x2F;tmp&#x2F;hosts &#x2F;etc&#x2F;hosts       此时的&#x2F;etc目录是可写的，所做修改不会应用到原来的&#x2F;etc目录，可以放心测试。测试完成了执行 umount &#x2F;etc&#x2F;hosts 断开绑定。</p><p>通过执行下面的命令可以创建一个挂载点：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">mount <span class="hljs-comment">--bind foo foo</span><br></code></pre></td></tr></table></figure><p>在挂载后可以通过mount命令查看所有的挂载点.这样就可以使用一些mount的属性，最简单的例子，例如：</p><blockquote><p>sudo mount,ro –bind test_dir test_dir</p></blockquote><p>可以让test_dir成为一个是read only的目录。无论改目录中的文件夹或者文件的权限是什么，这个文件夹都是只读的。</p><p>如果要递归的挂载一个目录可以使用如下命令.<br>mount –rbind olddir newdir<br>递归的挂载是指如果挂载的olddir内有挂载点，会把这个挂载点也一起挂载到newdir下。</p><h2 id="flags"><a href="#flags" class="headerlink" title="flags"></a>flags</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * These are the fs-independent mount-flags: up to 32 flags are supported </span><br><span class="hljs-comment"> */</span>  <br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_RDONLY        1         <span class="hljs-comment">/* 对应-o ro/rw */</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_NOSUID        2         <span class="hljs-comment">/* 对应-o suid/nosuid */</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_NODEV         4         <span class="hljs-comment">/* 对应-o dev/nodev */</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_NOEXEC        8         <span class="hljs-comment">/* 对应-o exec/noexec */</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_SYNCHRONOUS  16         <span class="hljs-comment">/* 对应-o sync/async */</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_REMOUNT      32         <span class="hljs-comment">/* 对应-o remount，告诉mount这是一次remount操作 */</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_MANDLOCK     64         <span class="hljs-comment">/* 对应-o mand/nomand */</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_DIRSYNC      128        <span class="hljs-comment">/* 对应-o dirsync */</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_NOATIME      1024       <span class="hljs-comment">/* 对应-o atime/noatime */</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_NODIRATIME   2048       <span class="hljs-comment">/* 对应-o diratime/nodiratime */</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_BIND         4096       <span class="hljs-comment">/* 对应-B/--bind选项，告诉mount这是一次bind操作 */</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_MOVE         8192       <span class="hljs-comment">/* 对应-M/--move，告诉mount这是一次move操作 */</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_REC          16384      <span class="hljs-comment">/* rec是recursive的意思，这个flag一般不单独出现，都是伴随这其它flag，表示递归的进行操作 */</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_VERBOSE      32768      <span class="hljs-comment">/* 对应-v/--verbose */</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_SILENT       32768      <span class="hljs-comment">/* 对应-o silent/loud */</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_POSIXACL     (1&lt;&lt;16)    <span class="hljs-comment">/* 让VFS不应用umask，如NFS */</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_UNBINDABLE   (1&lt;&lt;17)    <span class="hljs-comment">/* 对应--make-unbindable */</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_PRIVATE      (1&lt;&lt;18)    <span class="hljs-comment">/* 对应--make-private */</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_SLAVE        (1&lt;&lt;19)    <span class="hljs-comment">/* 对应--make-slave */</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_SHARED       (1&lt;&lt;20)    <span class="hljs-comment">/* 对应--make-shared */</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_RELATIME     (1&lt;&lt;21)    <span class="hljs-comment">/* 对应-o relatime/norelatime */</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_KERNMOUNT    (1&lt;&lt;22)    <span class="hljs-comment">/* 这个一般不在应用层使用，一般内核挂载的文件系统如sysfs使用，表示使用kern_mount()进行挂载 */</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_I_VERSION    (1&lt;&lt;23)    <span class="hljs-comment">/* 对应-o iversion/noiversion */</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_STRICTATIME  (1&lt;&lt;24)    <span class="hljs-comment">/* 对应-o strictatime/nostrictatime */</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_LAZYTIME     (1&lt;&lt;25)    <span class="hljs-comment">/* 对应 -o lazytime/nolazytime*/</span></span><br><br><span class="hljs-comment">/* 下面这几个flags都是内核内部使用的，不由mount系统调用传递 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_SUBMOUNT     (1&lt;&lt;26)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_NOREMOTELOCK (1&lt;&lt;27)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_NOSEC        (1&lt;&lt;28)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_BORN         (1&lt;&lt;29)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_ACTIVE       (1&lt;&lt;30)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_NOUSER       (1&lt;&lt;31)</span><br><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * Superblock flags that can be altered by MS_REMOUNT </span><br><span class="hljs-comment"> */</span>  <br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_RMT_MASK     (MS_RDONLY|MS_SYNCHRONOUS|MS_MANDLOCK|MS_I_VERSION|\                   </span><br>                         MS_LAZYTIME)  <span class="hljs-comment">// 可以在remount时改变的flags  </span><br>  <br><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * Old magic mount flag and mask </span><br><span class="hljs-comment"> */</span>  <br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_MGC_VAL 0xC0ED0000      <span class="hljs-comment">/* magic number */</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_MGC_MSK 0xffff0000      <span class="hljs-comment">/* flags mask */</span></span><br></code></pre></td></tr></table></figure><p>除了上面这些flags对应的mount选项，剩下的基本就是data来传递。</p><h2 id="mount-umount函数详解"><a href="#mount-umount函数详解" class="headerlink" title="mount&#x2F;umount函数详解"></a>mount&#x2F;umount函数详解</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp">功能描述：<br>mount挂上文件系统，umount执行相反的操作。<br>  <br>用法：  <br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mount.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">mount</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *source, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *target,</span></span><br><span class="hljs-params"><span class="hljs-function">   <span class="hljs-type">const</span> <span class="hljs-type">char</span> *filesystemtype, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> mountflags, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *data)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">umount</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *target)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">umount2</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *target, <span class="hljs-type">int</span> flags)</span></span>;<br></code></pre></td></tr></table></figure><p>参数</p><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig"><span class="hljs-string">source</span>：将要挂上的文件系统，通常是一个设备名。<br><span class="hljs-string">target</span>：文件系统所要挂在的目标目录。<br><span class="hljs-string">filesystemtype</span>：文件系统的类型，可以是<span class="hljs-string">&quot;ext2&quot;</span>，<span class="hljs-string">&quot;msdos&quot;</span>，<span class="hljs-string">&quot;proc&quot;</span>，<span class="hljs-string">&quot;nfs&quot;</span>，<span class="hljs-string">&quot;iso9660&quot;</span> 。。。<br><span class="hljs-string">mountflags</span>：指定文件系统的读写访问标志，可能值有以下<br><br><span class="hljs-string">MS_BIND</span>：执行<span class="hljs-string">bind</span>挂载，使文件或者子目录树在文件系统内的另一个点上可视。<br><span class="hljs-string">MS_DIRSYNC</span>：同步目录的更新。<br><span class="hljs-string">MS_MANDLOCK</span>：允许在文件上执行强制锁。<br><span class="hljs-string">MS_MOVE</span>：移动子目录树。<br><span class="hljs-string">MS_NOATIME</span>：不要更新文件上的访问时间。<br><span class="hljs-string">MS_NODEV</span>：不允许访问设备文件。<br><span class="hljs-string">MS_NODIRATIME</span>：不允许更新目录上的访问时间。<br><span class="hljs-string">MS_NOEXEC</span>：不允许在挂上的文件系统上执行程序。<br><span class="hljs-string">MS_NOSUID</span>：执行程序时，不遵照<span class="hljs-built_in">set-user-ID</span> 和 <span class="hljs-built_in">set-group-ID位。</span><br><span class="hljs-string">MS_RDONLY</span>：指定文件系统为只读。<br><span class="hljs-string">MS_REMOUNT</span>：重新加载文件系统。这允许你改变现存文件系统的<span class="hljs-string">mountflag</span>和数据，而无需使用先卸载，再挂上文件系统的方式。<br><span class="hljs-string">MS_SYNCHRONOUS</span>：同步文件的更新。<br><span class="hljs-string">MNT_FORCE</span>：强制卸载，即使文件系统处于忙状态。<br><span class="hljs-string">MNT_EXPIRE</span>：将挂载点标志为过时<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
      <category>filesystem</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>mount</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
