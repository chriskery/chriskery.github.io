<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>基于LGB实现新闻文本分类</title>
    <link href="/2024/05/01/%E5%9F%BA%E4%BA%8ELGB%E5%AE%9E%E7%8E%B0%E6%96%B0%E9%97%BB%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB/"/>
    <url>/2024/05/01/%E5%9F%BA%E4%BA%8ELGB%E5%AE%9E%E7%8E%B0%E6%96%B0%E9%97%BB%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="0-概述"><a href="#0-概述" class="headerlink" title="0.概述"></a>0.概述</h2><ul><li><strong>任务描述</strong>：</li></ul><p>识别样本中的敏感数据，构建基于敏感数据本体的分级分类模型，判断数据所属的类别以及级别。 1.利用远程监督技术，基于小样本构建文档分类分级样本库。 2.结合当下先进的深度学习和机器学习技术，利用已构建的样本库，提取文本语义特征，构建泛化能力强且能自我学习的文档分类分级模型。：</p><ul><li><strong>数据集</strong>：</li></ul><p>（1）已标注数据：共7000篇文档，类别包含7类，分别为：财经、房产、家居、教育、科技、时尚、时政，每一类包含1000篇文档。 （2）未标注数据：共33000篇文档。 （3）分类分级测试数据：共20000篇文档，包含10个类别:财经、房产、家居、教育、科技、时尚、时政、游戏、娱乐、体育。</p><ul><li><strong>运行环境</strong>：</li></ul><p>Python3.7环境下测试了本教程代码。需要的第三方模块包括：</p><pre><code class="hljs"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">operator</span><br>numpy<br>pandas<br>jieba<br>lightgbm<br>warnings<br>missingno<br>seaborn<br>datetime<br>sklearn<br></code></pre></td></tr></table></figure></code></pre><ul><li><strong>方法概述</strong>：</li></ul><p>本教程包括以下内容：数据分析、特征提取、特征筛选、模型训练、参数调优 <img src="https://work-storage.datafountain.cn/ceph-s3/api/notebook_assets/files/%E6%88%AA%E5%B1%8F2021-05-23%20%E4%B8%8A%E5%8D%889.49.33-872377.png" alt="流程图.png"></p><h2 id="1-数据分析"><a href="#1-数据分析" class="headerlink" title="1.数据分析"></a>1.数据分析</h2><p>（1）已标注数据：共7000篇文档，类别包含7类，分别为：财经、房产、家居、教育、科技、时尚、时政，每一类包含1000篇文档。 （2）未标注数据：共33000篇文档。 （3）分类分级测试数据：共20000篇文档，包含10个类别:财经、房产、家居、教育、科技、时尚、时政、游戏、娱乐、体育</p><p>已标注的数据共7个类别，每个类别1000篇，而测试数据包含10个类别。首先得先找出另外的3个类别的数据，然后再进行数据的处理。解决的思路有：</p><p>1.采用在信息抽取领域称为“远程监督”的方法，具体见：<a href="https://zhuanlan.zhihu.com/p/273756508">https://zhuanlan.zhihu.com/p/273756508</a> 能取得不错的召回率</p><p>2.采用无监督的算法进行预料的预训练，然后进行无监督文本抽取，最后进行微调。具体参考：<a href="https://zhuanlan.zhihu.com/p/350937332">https://zhuanlan.zhihu.com/p/350937332</a></p><p>将抽取出来的数据进行随机选取，每个类别共1000条，添加到训练集中，于是我们就有了10个类别的数据。</p><h2 id="2-数据读取与预处理"><a href="#2-数据读取与预处理" class="headerlink" title="2.数据读取与预处理"></a>2.数据读取与预处理</h2><p>主要进行分词和停用词过滤。分词是对新闻文本采用jieba分词，然后对分词后的结果进行停用词的过滤，最后将分词后的结果合起来组成新的句子。</p><h2 id="3-文本特征提取"><a href="#3-文本特征提取" class="headerlink" title="3. 文本特征提取"></a>3. 文本特征提取</h2><p>使用sklearn计算训练集的TF-IDF，并将训练集和测试集分别转换为TF-IDF权重矩阵，作为模型的输入。</p><p>至此，我们已经通过lgb模型训练与预测得出了test_data.csv新闻文本预测的结果。</p><h2 id="5-最优化参数搜索"><a href="#5-最优化参数搜索" class="headerlink" title="5. 最优化参数搜索"></a>5. 最优化参数搜索</h2><p>5.1 利用lgb.cv进行交叉验证，获取到最佳迭代次数</p><p>5.2 抽取部分训练集为验证集，使用验证集对lgb训练结果进行验证，选取最佳迭代次数进行进行测试集的预测。测试集的数量可以不断尝试，但是要保证每个类别的数量均匀。验证集与训练集进行一样的处理。</p><h2 id="6-优化思路"><a href="#6-优化思路" class="headerlink" title="6.优化思路"></a>6.优化思路</h2><p>（1）LGB参数调优： a.提高准确率：</p><p>1.learning_rate:学习率. 默认值：0.1 调参策略：最开始可以设置得大一些，如0.1。调整完其他参数之后最后再将此参数调小。 取值范围:0.01~0.3.</p><p>2.max_depth:树模型深度 默认值：-1 调整策略:无 取值范围：3-8（不超过10）</p><p>3.num_leaves:叶子节点数，数模型复杂度。 默认值：31 调整策略：可以设置为2的n次幂。但要大于分类的类别数 取值范围：classes&lt;num_leaves &lt;2^{max_depth}</p><p>b.降低过拟合</p><p>1.max_bin:工具箱数,工具箱的最大数特征值决定了容量 工具箱的最小数特征值可能会降低训练的准确性, 但是可能会增加一些一般的影响（处理过度学习）</p><p>2.min_data_in_leaf:一个叶子上数据的最小数量. 可以用来处理过拟合. 默认值：20 调参策略：搜索，尽量不要太大。</p><p>3.feature_fraction：每次迭代中随机选择特征的比例。默认值：1.0 调参策略：0.5-0.9之间调节。 可以用来加速训练 可以用来处理过拟合</p><p>4.bagging_fraction：不进行重采样的情况下随机选择部分数据 默认值：1.0 调参策略：0.5-0.9之间调节。 可以用来加速训练 可以用来处理过拟合</p><p>5.bagging_freq：bagging的次数。0表示禁用bagging，非零值表示执行k次bagging 默认值：0 调参策略：3-5</p><p>6.lambda_l1:L1正则 lambda_l2:L2正则</p><p>7.min_split_gain：执行切分的最小增益 默认值：0.1</p><p>（2）优化补充类别的方法</p><h2 id="8-总结"><a href="#8-总结" class="headerlink" title="8. 总结"></a>8. 总结</h2><p>当参加数据科学的比赛时，不妨先试着用常见的模型进行处理，然后挑选最适合的模型进行调优。前期大量方法模型的尝试是很有必要的，一方面能令我们加深对题目的理解，另一方面通过各种模型之间的对比，观察各个优异模型结果的共性，能方便我们针对性的进行优化，然后也能取得较为满意的分数。因为我不是专业的，不了解很多复杂的模型、步骤，但通过简单模型的尝试组合，然后进行模型调整，强化性的加深对模型参数的理解，学会如何用调整参数的方法处理训练中遇到的情况，将理论用于实践；或者多模型融合，进行投票，以取得更为精确的结果。使用多种算法，再对算法进行具体的调整，这也不失为一条学习与成长的路子。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>使用Argo Workflow实现镜像构建和推送</title>
    <link href="/2024/04/27/%E4%BD%BF%E7%94%A8Argo-Workflow%E5%AE%9E%E7%8E%B0%E9%95%9C%E5%83%8F%E6%9E%84%E5%BB%BA%E5%92%8C%E6%8E%A8%E9%80%81/"/>
    <url>/2024/04/27/%E4%BD%BF%E7%94%A8Argo-Workflow%E5%AE%9E%E7%8E%B0%E9%95%9C%E5%83%8F%E6%9E%84%E5%BB%BA%E5%92%8C%E6%8E%A8%E9%80%81/</url>
    
    <content type="html"><![CDATA[<p><em>我们将使用Argo Workflow构建一个CI&#x2F;CD的PipeLine来展示 Workflow的使用，</em><br><em>包括以下几个步骤：</em></p><ol><li>使用git-sync clone一个git仓库到volume中</li><li>使用Kaniko&#x2F;buildkit构建docker镜像</li><li>推送docker镜像到镜像仓库</li></ol><h1 id="使用git-sync-clone一个git仓库到volume中"><a href="#使用git-sync-clone一个git仓库到volume中" class="headerlink" title="使用git-sync clone一个git仓库到volume中"></a>使用git-sync clone一个git仓库到volume中</h1><p>1.1.首先我们需要创建一个secret，包含git ssh credentials用来从github中clone 仓库到volume中，执行以下命令：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment">##create a secret for git</span><br><span class="hljs-string">kubectl</span> <span class="hljs-string">create</span> <span class="hljs-string">secret</span> <span class="hljs-string">generic</span> <span class="hljs-string">git-creds</span> <span class="hljs-string">\</span><br>     <span class="hljs-string">--from-file=ssh=$HOME/.ssh/id_rsa</span> <span class="hljs-string">\</span><br>     <span class="hljs-string">--from-file=known_hosts=$HOME/.ssh/known_hosts</span> <br></code></pre></td></tr></table></figure><p>1.2.然后我们创建一个Workflow Template，将上面创建的secret挂载到我们的容器中。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">argoproj.io/v1alpha1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">WorkflowTemplate</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">ci-test</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-comment">#mount secrets for the workflow</span><br>  <span class="hljs-attr">volumes:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">git-secret</span><br>      <span class="hljs-attr">secret:</span><br>        <span class="hljs-attr">defaultMode:</span> <span class="hljs-number">256</span><br>        <span class="hljs-attr">secretName:</span> <span class="hljs-string">git-creds</span> <span class="hljs-comment"># your-ssh-key</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">repo-root</span><br>      <span class="hljs-attr">hostPath:</span><br>        <span class="hljs-attr">path:</span> <span class="hljs-string">/tmp/ci-test</span><br>        <span class="hljs-attr">type:</span> <span class="hljs-string">DirectoryOrCreate</span><br>  <span class="hljs-attr">nodeSelector:</span><br>      <span class="hljs-attr">argo-worflow:</span> <span class="hljs-string">&quot;true&quot;</span><br>  <span class="hljs-comment">#start the sequence</span><br>  <span class="hljs-attr">templates:</span><br>      <span class="hljs-comment">#this is the git fetch magic as an init container in the first step</span><br>      <span class="hljs-attr">initContainers:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">image:</span> <span class="hljs-string">k8s.gcr.io/git-sync:v3.1.6</span><br>          <span class="hljs-attr">args:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;--repo=git@github.com:&lt;YOUR-ORG&gt;/&lt;YOUR-REPO&gt;.git&quot;</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;--root=/workdir/root&quot;</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;--max-sync-failures=3&quot;</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;--timeout=200&quot;</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;--branch=main&quot;</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;--ssh&quot;</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;--one-time&quot;</span><br>          <span class="hljs-attr">name:</span> <span class="hljs-string">git-data</span><br>          <span class="hljs-attr">volumeMounts:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">repo-root</span><br>              <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/workdir</span> <span class="hljs-comment">##</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">git-secret</span><br>              <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/etc/git-secret</span><br>      <span class="hljs-attr">securityContext:</span><br>        <span class="hljs-attr">runAsUser:</span> <span class="hljs-number">0</span> <span class="hljs-comment"># to allow read of ssh key</span><br></code></pre></td></tr></table></figure><p>我们在volumes中声明了一个叫做git-secret的volume，引用了我们刚才创建的git-creds secrets。同时使用hostpath声明了挂载本机的&#x2F;tmp&#x2F;ci-test作为共享存储，我们整个Workflow的数据都会存在这个共享存储上。同时使用了NodeSelector指定该Workflow在固定节点运行（因为repo-root不是共享存储）。<br>volumes声明完成后，我们在templates.initcontainers里声明了一个init-containers，该container 使用了k8s.gcr.io&#x2F;git-sync:v3.1.6镜像，负责将git repo拷贝到&#x2F;workdir中，这样，我们就完成了使用使用git-sync clone一个git仓库到volume中的过程。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">argoproj.io/v1alpha1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">WorkflowTemplate</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">ci-test</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">entrypoint:</span> <span class="hljs-string">pipeline</span><br>  <span class="hljs-comment">#mount secrets for the workflow</span><br>  <span class="hljs-attr">volumes:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">git-secret</span><br>      <span class="hljs-attr">secret:</span><br>        <span class="hljs-attr">defaultMode:</span> <span class="hljs-number">256</span><br>        <span class="hljs-attr">secretName:</span> <span class="hljs-string">git-creds</span> <span class="hljs-comment"># your-ssh-key</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">repo-root</span><br>      <span class="hljs-attr">hostPath:</span><br>        <span class="hljs-attr">path:</span> <span class="hljs-string">/tmp/ci-test</span><br>        <span class="hljs-attr">type:</span> <span class="hljs-string">DirectoryOrCreate</span><br>  <span class="hljs-attr">nodeSelector:</span><br>      <span class="hljs-attr">argo-worflow:</span> <span class="hljs-string">&quot;true&quot;</span><br>  <span class="hljs-attr">hostNetwork:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-comment">#start the sequence</span><br>  <span class="hljs-attr">templates:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">pipeline</span><br>      <span class="hljs-attr">dag:</span><br>        <span class="hljs-attr">tasks:</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">git-sync</span><br>            <span class="hljs-attr">template:</span> <span class="hljs-string">git-sync</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">check-repo</span><br>            <span class="hljs-attr">template:</span> <span class="hljs-string">check-repo</span><br>            <span class="hljs-attr">depends:</span> <span class="hljs-string">git-sync</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">check-repo</span><br>      <span class="hljs-attr">container:</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">alpine:latest</span><br>        <span class="hljs-attr">command:</span> [<span class="hljs-string">sh</span>, <span class="hljs-string">-c</span>]<br>        <span class="hljs-attr">args:</span><br>          [<br>            <span class="hljs-string">&quot;echo getting message from volume; ls /workdir/root/argo-workflow-guide &gt; ls.txt; cat ls.txt&quot;</span>,<br>          ]<br>        <span class="hljs-attr">volumeMounts:</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">repo-root</span><br>            <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/workdir</span> <span class="hljs-comment">##</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">git-secret</span><br>            <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/etc/git-secret</span> <span class="hljs-comment">##</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">git-sync</span><br>      <span class="hljs-attr">container:</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">docker.io/chriskery/git-sync:v3.1.6</span><br>        <span class="hljs-attr">args:</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;--repo=git@github.com:chriskery/argo-workflow-guide.git&quot;</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;--root=/workdir/root&quot;</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;--dest=argo-workflow-guide&quot;</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;--max-sync-failures=3&quot;</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;--timeout=200&quot;</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;--branch=main&quot;</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;--ssh&quot;</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;--one-time&quot;</span><br>        <span class="hljs-attr">command:</span> [<span class="hljs-string">&quot;/git-sync&quot;</span>]<br>        <span class="hljs-attr">name:</span> <span class="hljs-string">git-data</span><br>        <span class="hljs-attr">volumeMounts:</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">repo-root</span><br>            <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/workdir</span> <span class="hljs-comment">##</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">git-secret</span><br>            <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/etc/git-secret</span><br>      <span class="hljs-attr">securityContext:</span><br>        <span class="hljs-attr">runAsUser:</span> <span class="hljs-number">0</span> <span class="hljs-comment"># to allow read of ssh key</span><br></code></pre></td></tr></table></figure><p>我们定义了一个叫做pineline和一个叫做check-repo的template，entrypoint为pipeline。Workflow会先运行initContainers的步骤，然后再运行entrypoint的步骤。pipeline里调用了check-repo，因此当这个workflow运行后，我们能在check-repo的步骤看到相关的输出。完整的WorkflowTemplate如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">argoproj.io/v1alpha1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">WorkflowTemplate</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">ci-test</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">entrypoint:</span> <span class="hljs-string">pipeline</span><br>  <span class="hljs-comment">#mount secrets for the workflow</span><br>  <span class="hljs-attr">volumes:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">git-secret</span><br>      <span class="hljs-attr">secret:</span><br>        <span class="hljs-attr">defaultMode:</span> <span class="hljs-number">256</span><br>        <span class="hljs-attr">secretName:</span> <span class="hljs-string">git-creds</span> <span class="hljs-comment"># your-ssh-key</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">repo-root</span><br>      <span class="hljs-attr">hostPath:</span><br>        <span class="hljs-attr">path:</span> <span class="hljs-string">/tmp/ci-test</span><br>        <span class="hljs-attr">type:</span> <span class="hljs-string">DirectoryOrCreate</span><br>  <span class="hljs-attr">nodeSelector:</span><br>      <span class="hljs-attr">argo-worflow:</span> <span class="hljs-string">&quot;true&quot;</span><br>  <span class="hljs-attr">hostNetwork:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-comment">#start the sequence</span><br>  <span class="hljs-attr">templates:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">pipeline</span><br>      <span class="hljs-attr">dag:</span><br>        <span class="hljs-attr">tasks:</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">git-sync</span><br>            <span class="hljs-attr">template:</span> <span class="hljs-string">git-sync</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">check-repo</span><br>            <span class="hljs-attr">template:</span> <span class="hljs-string">check-repo</span><br>            <span class="hljs-attr">depends:</span> <span class="hljs-string">git-sync</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">check-repo</span><br>      <span class="hljs-attr">container:</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">alpine:latest</span><br>        <span class="hljs-attr">command:</span> [<span class="hljs-string">sh</span>, <span class="hljs-string">-c</span>]<br>        <span class="hljs-attr">args:</span><br>          [<br>            <span class="hljs-string">&quot;echo getting message from volume; ls /workdir/root/argo-workflow-guide &gt; ls.txt; cat ls.txt&quot;</span>,<br>          ]<br>        <span class="hljs-attr">volumeMounts:</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">repo-root</span><br>            <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/workdir</span> <span class="hljs-comment">##</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">git-secret</span><br>            <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/etc/git-secret</span> <span class="hljs-comment">##</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">git-sync</span><br>      <span class="hljs-attr">container:</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">docker.io/chriskery/git-sync:v3.1.6</span><br>        <span class="hljs-attr">args:</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;--repo=git@github.com:chriskery/argo-workflow-guide.git&quot;</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;--root=/workdir/root&quot;</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;--dest=argo-workflow-guide&quot;</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;--max-sync-failures=3&quot;</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;--timeout=200&quot;</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;--branch=main&quot;</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;--ssh&quot;</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;--one-time&quot;</span><br>        <span class="hljs-attr">command:</span> [<span class="hljs-string">&quot;/git-sync&quot;</span>]<br>        <span class="hljs-attr">name:</span> <span class="hljs-string">git-data</span><br>        <span class="hljs-attr">volumeMounts:</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">repo-root</span><br>            <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/workdir</span> <span class="hljs-comment">##</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">git-secret</span><br>            <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/etc/git-secret</span><br>      <span class="hljs-attr">securityContext:</span><br>        <span class="hljs-attr">runAsUser:</span> <span class="hljs-number">0</span> <span class="hljs-comment"># to allow read of ssh key</span><br></code></pre></td></tr></table></figure><p>你现在可以通过Argo Workflow UI或Argo CLI提交这个Workflow Template。运行完成之后你应该能看到类似的输出：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/12923067/1714061286022-b57623c7-29ab-4680-9cd7-d8774d456a81.png#averageHue=%23574a42&clientId=u7ebd007b-bae5-4&from=drop&id=SDRst&originHeight=1266&originWidth=2840&originalType=binary&ratio=2&rotation=0&showTitle=false&size=223708&status=done&style=none&taskId=u54c8538d-8798-4c4a-9c46-773147be01d&title=" alt="截屏2024-04-26 00.07.58.png"><br>看看我们刚才clone下来的git仓库：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/12923067/1714061242502-175d2a45-4b9c-499b-b196-4a021fceed75.png#averageHue=%23292d39&clientId=u7ebd007b-bae5-4&from=drop&id=e3So7&originHeight=216&originWidth=1124&originalType=binary&ratio=2&rotation=0&showTitle=false&size=74199&status=done&style=none&taskId=u81bde82c-3e3d-4baf-8732-ccd1cc9d334&title=" alt="截屏2024-04-26 00.07.18.png"><br>现在有了数据，我们可以开始构建和推送我们的镜像了。</p><h1 id="使用Kaniko-buildkit构建Docker镜像"><a href="#使用Kaniko-buildkit构建Docker镜像" class="headerlink" title="使用Kaniko&#x2F;buildkit构建Docker镜像"></a>使用Kaniko&#x2F;buildkit构建Docker镜像</h1><blockquote><p><strong>Kaniko</strong>: Kaniko is a tool to build container images from a Dockerfile, inside a container or Kubernetes cluster. <a href="https://github.com/GoogleContainerTools/kaniko">https://github.com/GoogleContainerTools/kaniko</a><br><strong>buildkit</strong>: buildKit is a toolkit for converting source code to build artifacts in an efficient, expressive and repeatable manner.<br><a href="https://github.com/moby/buildkit">https://github.com/moby/buildkit</a></p></blockquote><p>kaniko和buildkit都可以在user space中完成镜像构建的功能，而无需跟主机上上的docker.socket进行通信。这里我们使用kaniko进行镜像构建。首先我们先创建一个secret将docker registry的credentials放在里面：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment">#docker-secret:</span><br><span class="hljs-string">kubectl</span> <span class="hljs-string">create</span> <span class="hljs-string">secret</span> <span class="hljs-string">generic</span> <span class="hljs-string">docker-secret</span> <span class="hljs-string">--from-file=config.json=$HOME/.docker/config.json</span> <br><br><span class="hljs-comment">#config.json 类似于：</span><br>&#123;<span class="hljs-attr">&quot;auths&quot;:</span> &#123;<span class="hljs-attr">&quot;https://index.docker.io/v1/&quot;:</span> &#123;<span class="hljs-string">&quot;username&quot;</span><span class="hljs-string">:&quot;$USERNAME&quot;</span>,<span class="hljs-string">&quot;password&quot;</span><span class="hljs-string">:&quot;$PASSWORD&quot;</span>&#125;,&#125;&#125;<br><span class="hljs-comment">#或者 </span><br><span class="hljs-comment"># echo &quot;$USERNAME&quot;:&quot;$PASSWORD&quot; | base64 </span><br><span class="hljs-comment">#&#123;&quot;auths&quot;: &#123;&quot;https://index.docker.io/v1/&quot;: &#123;&quot;auth&quot;:&quot;上一步的输出&quot;&#125;&#125;</span><br></code></pre></td></tr></table></figure><p>然后我们增加一个Task，进行镜像的构建与推送在上面的Workflow Template上增加以下的内容：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">entrypoint:</span> <span class="hljs-string">pipeline</span><br><span class="hljs-comment">#mount secrets for the workflow</span><br><span class="hljs-attr">volumes:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">docker-secret</span><br>    <span class="hljs-attr">secret:</span><br>      <span class="hljs-attr">secretName:</span> <span class="hljs-string">docker-secret</span><br><span class="hljs-comment">#start the sequence</span><br><span class="hljs-attr">templates:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">pipeline</span><br>    <span class="hljs-attr">dag:</span><br>      <span class="hljs-attr">tasks:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">git-sync</span><br>          <span class="hljs-attr">template:</span> <span class="hljs-string">git-sync</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">check-repo</span><br>          <span class="hljs-attr">template:</span> <span class="hljs-string">check-repo</span><br>          <span class="hljs-attr">depends:</span> <span class="hljs-string">git-sync</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">build-docker</span><br>          <span class="hljs-attr">template:</span> <span class="hljs-string">build-docker</span> <br>          <span class="hljs-attr">depends:</span> <span class="hljs-string">check-repo</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">build-docker</span><br>    <span class="hljs-attr">container:</span><br>      <span class="hljs-comment">#argo is gonna ask for a command - the debug version allows us to exec this way i think</span><br>      <span class="hljs-attr">image:</span> <span class="hljs-string">docker.io/chriskery/executor:v1.9.0</span><br>      <span class="hljs-attr">imagePullPolicy:</span> <span class="hljs-string">Always</span><br>      <span class="hljs-attr">env:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">DOCKER_USERNAME</span><br>          <span class="hljs-attr">value:</span> <span class="hljs-string">chriskery</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">DOCKER_PASSWORD</span><br>          <span class="hljs-attr">value:</span> <span class="hljs-string">1584537639qq</span><br>      <span class="hljs-attr">command:</span> [<span class="hljs-string">&quot;/kaniko/executor&quot;</span>]<br>      <span class="hljs-comment"># (if we set cache true we should make an ECR container update)</span><br>      <span class="hljs-comment"># i gave the full path to the docker file but maybe relative is fine</span><br>      <span class="hljs-attr">args:</span><br>        [<br>          <span class="hljs-string">&quot;--context=/workdir/root/argo-workflow-guide&quot;</span>,<br>          <span class="hljs-string">&quot;--destination=docker.io/chriskery/argo-worflow-guide:v1&quot;</span>,<br>          <span class="hljs-string">&quot;--cache=false&quot;</span>,<br>        ]<br>      <span class="hljs-attr">volumeMounts:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">repo-root</span><br>          <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/workdir</span> <span class="hljs-comment">##</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">docker-secret</span><br>          <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/kaniko/.docker</span><br>      <span class="hljs-attr">resources:</span><br>        <span class="hljs-attr">limits:</span><br>          <span class="hljs-attr">cpu:</span> <span class="hljs-number">1</span><br>          <span class="hljs-attr">memory:</span> <span class="hljs-string">5Gi</span><br></code></pre></td></tr></table></figure><p>完整的示例如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">argoproj.io/v1alpha1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">WorkflowTemplate</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">ci-test</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">entrypoint:</span> <span class="hljs-string">pipeline</span><br>  <span class="hljs-comment">#mount secrets for the workflow</span><br>  <span class="hljs-attr">volumes:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">git-secret</span><br>      <span class="hljs-attr">secret:</span><br>        <span class="hljs-attr">defaultMode:</span> <span class="hljs-number">256</span><br>        <span class="hljs-attr">secretName:</span> <span class="hljs-string">git-creds</span> <span class="hljs-comment"># your-ssh-key</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">repo-root</span><br>      <span class="hljs-attr">hostPath:</span><br>        <span class="hljs-attr">path:</span> <span class="hljs-string">/tmp/ci-test</span><br>        <span class="hljs-attr">type:</span> <span class="hljs-string">DirectoryOrCreate</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">docker-secret</span><br>      <span class="hljs-attr">secret:</span><br>        <span class="hljs-attr">secretName:</span> <span class="hljs-string">docker-secret</span><br>  <span class="hljs-attr">nodeSelector:</span><br>      <span class="hljs-attr">argo-worflow:</span> <span class="hljs-string">&quot;true&quot;</span><br>  <span class="hljs-attr">hostNetwork:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-comment">#start the sequence</span><br>  <span class="hljs-attr">templates:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">pipeline</span><br>      <span class="hljs-attr">dag:</span><br>        <span class="hljs-attr">tasks:</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">git-sync</span><br>            <span class="hljs-attr">template:</span> <span class="hljs-string">git-sync</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">check-repo</span><br>            <span class="hljs-attr">template:</span> <span class="hljs-string">check-repo</span><br>            <span class="hljs-attr">depends:</span> <span class="hljs-string">git-sync</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">build-docker</span><br>            <span class="hljs-attr">template:</span> <span class="hljs-string">build-docker</span> <br>            <span class="hljs-attr">depends:</span> <span class="hljs-string">check-repo</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">check-repo</span><br>      <span class="hljs-attr">container:</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">alpine:latest</span><br>        <span class="hljs-attr">command:</span> [<span class="hljs-string">sh</span>, <span class="hljs-string">-c</span>]<br>        <span class="hljs-attr">args:</span><br>          [<br>            <span class="hljs-string">&quot;echo getting message from volume; ls /workdir/root/argo-workflow-guide &gt; ls.txt; cat ls.txt&quot;</span>,<br>          ]<br>        <span class="hljs-attr">volumeMounts:</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">repo-root</span><br>            <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/workdir</span> <span class="hljs-comment">##</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">git-secret</span><br>            <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/etc/git-secret</span> <span class="hljs-comment">##</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">build-docker</span><br>      <span class="hljs-attr">container:</span><br>        <span class="hljs-comment">#argo is gonna ask for a command - the debug version allows us to exec this way i think</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">docker.io/chriskery/executor:v1.9.0</span><br>        <span class="hljs-attr">imagePullPolicy:</span> <span class="hljs-string">Always</span><br>        <span class="hljs-attr">env:</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">DOCKER_USERNAME</span><br>            <span class="hljs-attr">value:</span> <span class="hljs-string">chriskery</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">DOCKER_PASSWORD</span><br>            <span class="hljs-attr">value:</span> <span class="hljs-string">1584537639qq</span><br>        <span class="hljs-attr">command:</span> [<span class="hljs-string">&quot;/kaniko/executor&quot;</span>]<br>        <span class="hljs-comment"># (if we set cache true we should make an ECR container update)</span><br>        <span class="hljs-comment"># i gave the full path to the docker file but maybe relative is fine</span><br>        <span class="hljs-attr">args:</span><br>          [<br>            <span class="hljs-string">&quot;--context=/workdir/root/argo-workflow-guide&quot;</span>,<br>            <span class="hljs-string">&quot;--destination=docker.io/chriskery/argo-worflow-guide:v1&quot;</span>,<br>            <span class="hljs-string">&quot;--cache=false&quot;</span>,<br>          ]<br>        <span class="hljs-attr">volumeMounts:</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">repo-root</span><br>            <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/workdir</span> <span class="hljs-comment">##</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">docker-secret</span><br>            <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/kaniko/.docker</span><br>        <span class="hljs-attr">resources:</span><br>          <span class="hljs-attr">limits:</span><br>            <span class="hljs-attr">cpu:</span> <span class="hljs-number">1</span><br>            <span class="hljs-attr">memory:</span> <span class="hljs-string">5Gi</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">git-sync</span><br>      <span class="hljs-attr">container:</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">docker.io/chriskery/git-sync:v3.1.6</span><br>        <span class="hljs-attr">args:</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;--repo=git@github.com:chriskery/argo-workflow-guide.git&quot;</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;--root=/workdir/root&quot;</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;--dest=argo-workflow-guide&quot;</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;--max-sync-failures=3&quot;</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;--timeout=200&quot;</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;--branch=main&quot;</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;--ssh&quot;</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;--one-time&quot;</span><br>        <span class="hljs-attr">command:</span> [<span class="hljs-string">&quot;/git-sync&quot;</span>]<br>        <span class="hljs-attr">name:</span> <span class="hljs-string">git-data</span><br>        <span class="hljs-attr">volumeMounts:</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">repo-root</span><br>            <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/workdir</span> <span class="hljs-comment">##</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">git-secret</span><br>            <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/etc/git-secret</span><br>      <span class="hljs-attr">securityContext:</span><br>        <span class="hljs-attr">runAsUser:</span> <span class="hljs-number">0</span> <span class="hljs-comment"># to allow read of ssh key</span><br></code></pre></td></tr></table></figure><p>提交到Argo Workflow中，我们能看到最下面多了一个build-docker的task；<br><img src="https://cdn.nlark.com/yuque/0/2024/png/12923067/1714149576229-6882807b-5d54-4499-8ca7-10416f3bd991.png#averageHue=%235abb98&clientId=uc0b33e88-6645-4&from=drop&id=uaa78ef13&originHeight=1282&originWidth=2740&originalType=binary&ratio=2&rotation=0&showTitle=false&size=253399&status=done&style=none&taskId=u61661978-8df8-42b2-9629-81665b758a6&title=" alt="截屏2024-04-27 00.39.30.png"><br>查看构建日志：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/12923067/1714149635254-dd3499f0-d264-4a55-bfd7-732a86f5d419.png#averageHue=%23514f49&clientId=uc0b33e88-6645-4&from=drop&id=ueef045b3&originHeight=1338&originWidth=2880&originalType=binary&ratio=2&rotation=0&showTitle=false&size=545517&status=done&style=none&taskId=uebe5b696-e914-4db4-8aa4-e4bca7c754f&title=" alt="截屏2024-04-27 00.40.31.png">至此，我们完成了一个简单的gitops操作，从远端同步git代码-&gt;检查git文件-&gt;构建并推送镜像到镜像仓库中。我们现在是手工提交的workflow，但其实可以使用argo event提供的webhook机制在代码合并式自动进行提交，我们也可以继续增加新的步骤，比如单元测试、自动部署等，实现CICD的全流程自动化。</p>]]></content>
    
    
    
    <tags>
      
      <tag>CI/CD</tag>
      
      <tag>Argo Workflow</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hadoop Operator</title>
    <link href="/2024/01/22/Hadoop-Operator/"/>
    <url>/2024/01/22/Hadoop-Operator/</url>
    
    <content type="html"><![CDATA[<p>项目地址：<a href="https://github.com/chriskery/hadoop-operator">https://github.com/chriskery/hadoop-operator</a></p><p>Hadoop是一个框架，允许在计算机集群上使用简单的编程模型对大型数据集进行分布式处理。它被设计为从单个服务器扩展到数千台机器，每台机器都提供本地计算和存储。与依赖硬件提供高可用性不同，该库本身被设计为在应用程序层面检测和处理故障，提供在一组计算机集群上的高可用服务，其中每台计算机都可能发生故障。</p><p>Hadoop Operator 的目标是为了用于管理Kubernetes上Apache Hadoop Yarn作业的生命周期，其包括两个方面的内容：</p><ol><li>提供声明式的方式创建Hadoop集群</li><li>云原生的方式运行传统的Hadoop Yarn作业</li></ol><h2 id="Operator-安装"><a href="#Operator-安装" class="headerlink" title="Operator 安装"></a>Operator 安装</h2><p>Hadoop Operator依赖cert manager组件提供的证书创建与更新功能，因此在安装Hadoop Operator之前，需要先安装cert manager，执行以下命令安装Cert Manger ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br>kubectl apply -f https://github.com/cert-manager/cert-manager/releases/download/v1.13.3/cert-manager.yaml<br><br></code></pre></td></tr></table></figure><p>执行以下命令安装Hadoop  Operator：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br>kubectl apply -k github.com/chriskery/hadoop-operator/manifests/default<br><br></code></pre></td></tr></table></figure><h2 id="构建第一个Hadoop-Cluster"><a href="#构建第一个Hadoop-Cluster" class="headerlink" title="构建第一个Hadoop Cluster"></a>构建第一个Hadoop Cluster</h2><p>首先，创建一个YAML文件以定义名为hello-world.yaml的HadoopCluster资源。</p><p>然后将下面的片段复制并粘贴到文件中，并保存：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">kubecluster.org/v1alpha1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">HadoopCluster</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">hadoopcluster-sample</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">yarn:</span><br>    <span class="hljs-attr">serviceType:</span> <span class="hljs-string">NodePort</span><br></code></pre></td></tr></table></figure><p>接下来，通过运行以下命令应用hello-world.yaml：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">&gt; kubectl apply -f hello-world.yaml                                                                                   <br>hadoopcluster.kubecluster.org/hadoopcluster-sample created<br></code></pre></td></tr></table></figure><p>现在，我们已经创建了一个Hadoop集群，运行以下命令查看它：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl get hdcs<br></code></pre></td></tr></table></figure><p>输出类似于：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">&gt; kubectl get hdc                                             <br>NAME                   AGE     STATE<br>hadoopcluster-sample   2m23s   Created<br></code></pre></td></tr></table></figure><p>Hadoop集群运算符创建Pods以模拟物理Hadoop集群中的节点。运行以下命令查看已创建的Pods：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">&gt; kubectl get pods -o wide<br>NAME                                   READY   STATUS    RESTARTS   AGE     IP               NODE   NOMINATED NODE   READINESS GATES<br>hadoopcluster-sample-datanode-0        1/1     Running   0          96s     10.244.0.100     k8s    &lt;none&gt;           &lt;none&gt;<br>hadoopcluster-sample-namenode          1/1     Running   0          7m25s   10.244.0.96      k8s    &lt;none&gt;           &lt;none&gt;<br>hadoopcluster-sample-nodemanager-0     1/1     Running   0          5m55s   10.244.0.99      k8s    &lt;none&gt;           &lt;none&gt;<br>hadoopcluster-sample-resourcemanager   1/1     Running   0          6s      10.244.0.101     k8s    &lt;none&gt;           &lt;none&gt;<br></code></pre></td></tr></table></figure><p>如您所见，有一个模拟NameNode、DataNode、NodeManager和ResourceManager的Pod。如果需要更多的Pods来运行更多的任务，可以调整相关的Datanodes和Nodemanagers的数量。</p><p>现在，让我们尝试登录到一个节点并运行一个MapReduce作业：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs bash">&gt; kubectl <span class="hljs-built_in">exec</span> -it hadoopcluster-sample-resourcemanager /bin/bash<br>kubectl <span class="hljs-built_in">exec</span> [POD] [COMMAND] is DEPRECATED and will be removed <span class="hljs-keyword">in</span> a future version. Use kubectl <span class="hljs-built_in">exec</span> [POD] -- [COMMAND] instead.<br>bash-4.2$ <span class="hljs-built_in">ls</span><br>LICENSE-binary  LICENSE.txt  NOTICE-binary  NOTICE.txt  README.txt  bin  etc  include  lib  libexec  licenses-binary  sbin  share<br>bash-4.2$ <span class="hljs-built_in">cd</span> share/hadoop/mapreduce/<br>bash-4.2$ <span class="hljs-built_in">ls</span>         <br>hadoop-mapreduce-client-app-3.3.1.jar     hadoop-mapreduce-client-hs-plugins-3.3.1.jar       hadoop-mapreduce-client-shuffle-3.3.1.jar   lib-examples<br>hadoop-mapreduce-client-common-3.3.1.jar  hadoop-mapreduce-client-jobclient-3.3.1-tests.jar  hadoop-mapreduce-client-uploader-3.3.1.jar  sources<br>hadoop-mapreduce-client-core-3.3.1.jar    hadoop-mapreduce-client-jobclient-3.3.1.jar        hadoop-mapreduce-examples-3.3.1.jar<br>hadoop-mapreduce-client-hs-3.3.1.jar      hadoop-mapreduce-client-nativetask-3.3.1.jar       jdiff<br>bash-4.2$ hadoop jar hadoop-mapreduce-examples-3.3.1.jar pi 8 1000<br>Number of Maps  = 8<br>Samples per Map = 1000<br>Wrote input <span class="hljs-keyword">for</span> Map <span class="hljs-comment">#0</span><br>Wrote input <span class="hljs-keyword">for</span> Map <span class="hljs-comment">#1</span><br>Wrote input <span class="hljs-keyword">for</span> Map <span class="hljs-comment">#2</span><br>Wrote input <span class="hljs-keyword">for</span> Map <span class="hljs-comment">#3</span><br>Wrote input <span class="hljs-keyword">for</span> Map <span class="hljs-comment">#4</span><br>Wrote input <span class="hljs-keyword">for</span> Map <span class="hljs-comment">#5</span><br>Wrote input <span class="hljs-keyword">for</span> Map <span class="hljs-comment">#6</span><br>Wrote input <span class="hljs-keyword">for</span> Map <span class="hljs-comment">#7</span><br>Starting Job<br>2024-01-11 08:28:41 INFO  DefaultNoHARMFailoverProxyProvider:64 - Connecting to ResourceManager at hadoopcluster-sample-resourcemanager/10.244.0.101:8032<br>2024-01-11 08:28:42 INFO  JobResourceUploader:906 - Disabling Erasure Coding <span class="hljs-keyword">for</span> path: /tmp/hadoop-yarn/staging/hadoop/.staging/job_1704961336749_0001<br>2024-01-11 08:28:42 INFO  FileInputFormat:300 - Total input files to process : 8<br>2024-01-11 08:28:43 INFO  JobSubmitter:202 - number of splits:8<br>2024-01-11 08:28:43 INFO  JobSubmitter:298 - Submitting tokens <span class="hljs-keyword">for</span> job: job_1704961336749_0001<br>2024-01-11 08:28:43 INFO  JobSubmitter:299 - Executing with tokens: []<br>......<br>......<br>Job Finished <span class="hljs-keyword">in</span> 26.166 seconds<br>Estimated value of Pi is 3.14100000000000000000<br>bash-4.2$ <br></code></pre></td></tr></table></figure><h2 id="提交Hadoop作业"><a href="#提交Hadoop作业" class="headerlink" title="提交Hadoop作业"></a>提交Hadoop作业</h2><p><img src="https://github.com/chriskery/hadoop-operator/blob/master/docs/images/architecture.png?raw=true" alt="架构"><br>Hadoop Operator提供了一个简单的方式直接运行Yarn的作业而无需先创建一个Hadoop Cluster，将下面的片段复制并粘贴到文件中，并保存：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">kubecluster.org/v1alpha1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">HadoopApplication</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">hadoopapplication-sample</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">mainApplicationFile:</span> <span class="hljs-string">/opt/hadoop/share/hadoop/mapreduce/hadoop-mapreduce-examples-3.3.1.jar</span><br>  <span class="hljs-attr">arguments:</span> [<span class="hljs-string">&quot;pi&quot;</span>,<span class="hljs-string">&quot;20&quot;</span>,<span class="hljs-string">&quot;10000000000&quot;</span>]<br>  <span class="hljs-attr">nameNodeDirFormat:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">executorSpec:</span><br>      <span class="hljs-attr">image:</span> <span class="hljs-string">apache/hadoop:3</span><br>      <span class="hljs-attr">replicas:</span> <span class="hljs-number">1</span><br>      <span class="hljs-attr">volumes:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">demos</span><br>          <span class="hljs-attr">hostPath:</span><br>            <span class="hljs-attr">path:</span> <span class="hljs-string">/root/demos</span><br>      <span class="hljs-attr">volumeMounts:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">demos</span><br>          <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/root/demos</span><br>      <span class="hljs-attr">resources:</span><br>        <span class="hljs-attr">requests:</span><br>            <span class="hljs-attr">cpu:</span> <span class="hljs-number">2</span><br>            <span class="hljs-attr">memory:</span> <span class="hljs-string">4Gi</span><br>        <span class="hljs-attr">limits:</span><br>            <span class="hljs-attr">cpu:</span> <span class="hljs-number">2</span><br>            <span class="hljs-attr">memory:</span> <span class="hljs-string">4Gi</span><br></code></pre></td></tr></table></figure><p>提交hadoop作业：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">kubectl apply -f manifests/samples/hadoop_job.yaml</span>               <br>hadoopapplication.kubecluster.org/hadoopapplication-sample created<br></code></pre></td></tr></table></figure><p>查看hadoop作业的状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">kubectl get hda</span><br>NAME                       AGE   STATE<br>hadoopapplication-sample   67s   Running<br></code></pre></td></tr></table></figure><p>Hadoop Operator会为每个作业创建一个Hadoop Cluster，并创建一个driver Pod提交作业，我们可以通过查看driver Pod的日志查看作业的运行情况：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs shell">·&gt; kubectl get pods                                        <br>NAME                                       READY   STATUS    RESTARTS   AGE<br>hadoopapplication-sample-datanode-0        1/1     Running   0          2m45s<br>hadoopapplication-sample-driver            1/1     Running   0          2m32s<br>hadoopapplication-sample-namenode          1/1     Running   0          2m47s<br>hadoopapplication-sample-nodemanager-0     1/1     Running   0          2m42s<br>hadoopapplication-sample-resourcemanager   1/1     Running   0          2m44s<br><br><br>·&gt; kubectl logs -f hadoopapplication-sample-driver                          <br>The value of HADOOP_CONF_DIR is: /opt/hadoop/etc/hadoop<br>Copying configuration files...<br>Copying configuration files...<br>cp: cannot create regular file &#x27;/hbase/conf&#x27;: No such file or directory<br>Environment variable HADOOP_ROLE is not set to a recognized value: driver<br>Number of Maps  = 20<br>Samples per Map = 10000000000<br>Wrote input for Map #0<br>Wrote input for Map #1<br>Wrote input for Map #2<br>Wrote input for Map #3<br>Wrote input for Map #4<br>Wrote input for Map #5<br>Wrote input for Map #6<br>Wrote input for Map #7<br>Wrote input for Map #8<br>Wrote input for Map #9<br>Wrote input for Map #10<br>Wrote input for Map #11<br>Wrote input for Map #12<br>...<br>2024-01-22 14:09:26 INFO  Job:1641 - Job job_1705932546606_0001 running in uber mode : false<br>2024-01-22 14:09:26 INFO  Job:1648 -  map 0% reduce 0%<br>2024-01-22 14:09:44 INFO  Job:1648 -  map 3% reduce 0%<br>2024-01-22 14:09:45 INFO  Job:1648 -  map 7% reduce 0%<br>2024-01-22 14:12:15 INFO  Job:1648 -  map 8% reduce 0%<br>2024-01-22 14:12:16 INFO  Job:1648 -  map 10% reduce 0%<br></code></pre></td></tr></table></figure><h2 id="Web-Portal访问"><a href="#Web-Portal访问" class="headerlink" title="Web Portal访问"></a>Web Portal访问</h2><p>Hadoop Operator会将一个Hadoop 相关的Web服务以NodePort的方式暴露出来，如果想访问Hadoop的web端口对集群和作业进行状态查看，可以访问对应的service：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">&gt; kubectl get svc | grep -i nodePort<br>hadoopcluster-sample-resourcemanager-nodeport   NodePort    10.107.164.217   &lt;none&gt;        8088:31505/TCP                        18m<br></code></pre></td></tr></table></figure><p>Open a browser and access the corresponding PhyNodeIp:port and you can see a web portal like this:</p><p><img src="https://github.com/chriskery/hadoop-cluster-operator/blob/master/docs/images/hadoop-web.png?raw=true" alt="Hadoop-Web-Portal"></p>]]></content>
    
    
    <categories>
      
      <category>bigData</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hadoop</tag>
      
      <tag>yarn</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kubelet详解（二）- Pod同步流程</title>
    <link href="/2023/12/20/Kubelet%E8%AF%A6%E8%A7%A3%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <url>/2023/12/20/Kubelet%E8%AF%A6%E8%A7%A3%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>本章节介绍一下Kubelet对Pod的同步流程。</p><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><h3 id="Mirror-Pod"><a href="#Mirror-Pod" class="headerlink" title="Mirror Pod"></a>Mirror Pod</h3><p>在浏览Kubelet的相关源码的时候，我们经常会看到如下的代码调用：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs golang">GetPodByMirrorPod(*v1.Pod) (*v1.Pod, <span class="hljs-type">bool</span>)<br><span class="hljs-comment">// GetMirrorPodByPod returns the mirror pod for the given static pod and</span><br><span class="hljs-comment">// whether it was known to the pod manager.</span><br>GetMirrorPodByPod(*v1.Pod) (*v1.Pod, <span class="hljs-type">bool</span>)<br><span class="hljs-comment">// GetPodAndMirrorPod returns the complement for a pod - if a pod was provided</span><br><span class="hljs-comment">// and a mirror pod can be found, return it. If a mirror pod is provided and</span><br><span class="hljs-comment">// the pod can be found, return it and true for wasMirror.</span><br>GetPodAndMirrorPod(*v1.Pod) (pod, mirrorPod *v1.Pod, wasMirror <span class="hljs-type">bool</span>)<br></code></pre></td></tr></table></figure><p>这里面的<strong>mirror pod</strong>很容易让人一头雾水。在介绍<strong>mirror pod</strong>之前，我们首先需要知道Kubelet所监听的Pods的来源，主要分为三种：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-comment">// define file config source</span><br><span class="hljs-keyword">if</span> kubeCfg.StaticPodPath != <span class="hljs-string">&quot;&quot;</span> &#123;<br>klog.InfoS(<span class="hljs-string">&quot;Adding static pod path&quot;</span>, <span class="hljs-string">&quot;path&quot;</span>, kubeCfg.StaticPodPath)<br>config.NewSourceFile(kubeCfg.StaticPodPath, nodeName, kubeCfg.FileCheckFrequency.Duration, cfg.Channel(ctx, kubetypes.FileSource))<br>&#125;<br><br><span class="hljs-comment">// define url config source</span><br><span class="hljs-keyword">if</span> kubeCfg.StaticPodURL != <span class="hljs-string">&quot;&quot;</span> &#123;<br>klog.InfoS(<span class="hljs-string">&quot;Adding pod URL with HTTP header&quot;</span>, <span class="hljs-string">&quot;URL&quot;</span>, kubeCfg.StaticPodURL, <span class="hljs-string">&quot;header&quot;</span>, manifestURLHeader)<br>config.NewSourceURL(kubeCfg.StaticPodURL, manifestURLHeader, nodeName, kubeCfg.HTTPCheckFrequency.Duration, cfg.Channel(ctx, kubetypes.HTTPSource))<br>&#125;<br><br><span class="hljs-keyword">if</span> kubeDeps.KubeClient != <span class="hljs-literal">nil</span> &#123;<br>klog.InfoS(<span class="hljs-string">&quot;Adding apiserver pod source&quot;</span>)<br>config.NewSourceApiserver(kubeDeps.KubeClient, nodeName, nodeHasSynced, cfg.Channel(ctx, kubetypes.ApiserverSource))<br>&#125;<br></code></pre></td></tr></table></figure><p>Kubelet启动后，会负责所有调度到对应机器上的Pod的生命周期管理，获取Pod清单列表的方式包括：</p><ul><li>文件∶启动参数–config指定的配置目录下的文件（默认&#x2F;etc&#x2F;Kubernetes&#x2F;manifests&#x2F;）。</li><li>HTTP endpoint（URL）∶启动参数–manifest-url设置。</li><li>APIServer∶通过APIServer监听etcd目录，同步Pod清单。</li><li>HTTP Server∶ kubelet 侦听 HTTP 请求，并响应简单的 API 以提交新的 Pod 清单</li></ul><p>其中所有来自<code>APIServer</code>的Pod为非静态Pod，其余来源的Pod称之为<code>静态Pod</code>。静态 Pod 不通过 master 节点上的 apiserver 操作及管理，直接由特定节点上的 kubelet 进程来管理的。无法与我们常用的控制器 Deployment 或者 DaemonSet 等进行关联，它由 kubelet 进程自己来监控，当 pod 崩溃时重启该 pod。静态 pod 始终绑定在某个 kubelet ，并且始终运行在同一个节点上。</p><p>为了让这些不是由API Server管理的Pods也能在Kubernetes API中表示和监控，kubelet 会自动为每一个静态 pod 在 kubernetes 的 apiserver 上创建一个镜像 pod，也就是<code>mirror pod</code>。注意，镜像Pod是一个只读的资源，在API server上不能对其进行修改或删除</p><h3 id="syncLoopIteration"><a href="#syncLoopIteration" class="headerlink" title="syncLoopIteration"></a>syncLoopIteration</h3><p>Kubelet的<code>syncLoopIteration</code>功能是Kubernetes节点代理kubelet内部的一个核心循环，负责同步节点上的Pod状态。在这个循环中，kubelet会执行一系列动作来确保节点上的Pods状态与其期望的状态一致。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(kl *Kubelet)</span></span> syncLoopIteration(ctx context.Context, configCh &lt;-<span class="hljs-keyword">chan</span> kubetypes.PodUpdate, handler SyncHandler, syncCh &lt;-<span class="hljs-keyword">chan</span> time.Time, housekeepingCh &lt;-<span class="hljs-keyword">chan</span> time.Time, plegCh &lt;-<span class="hljs-keyword">chan</span> *pleg.PodLifecycleEvent) <span class="hljs-type">bool</span><br></code></pre></td></tr></table></figure><p><code>syncLoopIteration</code>参数为各个事件源的channel，其具体含义为：</p><ul><li><p>configCh &lt;-chan kubetypes.PodUpdate: 这是一个Go channel，kubelet通过它接收Pod更新信息。kubetypes.PodUpdate是一个结构体，包含了Pods的更新信息，例如Pod的创建、更新、删除事件。</p></li><li><p>handler SyncHandler: SyncHandler是一个接口，它定义了处理Pod同步的一系列方法。syncLoopIteration函数会调用SyncHandler的方法来同步Pod的状态，比如启动新的Pod、更新现有的Pod、或者停止不再需要的Pod。</p></li><li><p>syncCh &lt;-chan time.Time: 这是一个定时器channel，kubelet使用它来定期执行同步操作。当这个channel发出信号时，它触发kubelet去检查和更新Pod的状态。</p></li><li><p>housekeepingCh &lt;-chan time.Time: 这个也是一个定时器channel，但它专门用于触发常规的节点维护任务，如垃圾收集、状态更新等。</p></li><li><p>plegCh &lt;-chan *pleg.PodLifecycleEvent: plegCh是Pod生命周期事件生成器（PLEG）的channel。PLEG负责检测容器的状态变化，并生成相应的事件。kubelet监听这个channel来获取容器状态变化的通知，并根据这些变化来更新Pod的状态。</p></li></ul><h2 id="configCh"><a href="#configCh" class="headerlink" title="configCh"></a>configCh</h2><p>针对<code>configCh</code>传递过来的Pod的更新事件，其响应如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-keyword">case</span> u, open := &lt;-configCh:<br><span class="hljs-comment">// Update from a config source; dispatch it to the right handler</span><br><span class="hljs-comment">// callback.</span><br><span class="hljs-keyword">if</span> !open &#123;<br>klog.ErrorS(<span class="hljs-literal">nil</span>, <span class="hljs-string">&quot;Update channel is closed, exiting the sync loop&quot;</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><br><span class="hljs-keyword">switch</span> u.Op &#123;<br><span class="hljs-keyword">case</span> kubetypes.ADD:<br>klog.V(<span class="hljs-number">2</span>).InfoS(<span class="hljs-string">&quot;SyncLoop ADD&quot;</span>, <span class="hljs-string">&quot;source&quot;</span>, u.Source, <span class="hljs-string">&quot;pods&quot;</span>, klog.KObjSlice(u.Pods))<br><span class="hljs-comment">// After restarting, kubelet will get all existing pods through</span><br><span class="hljs-comment">// ADD as if they are new pods. These pods will then go through the</span><br><span class="hljs-comment">// admission process and *may* be rejected. This can be resolved</span><br><span class="hljs-comment">// once we have checkpointing.</span><br>handler.HandlePodAdditions(u.Pods)<br><span class="hljs-keyword">case</span> kubetypes.UPDATE:<br>klog.V(<span class="hljs-number">2</span>).InfoS(<span class="hljs-string">&quot;SyncLoop UPDATE&quot;</span>, <span class="hljs-string">&quot;source&quot;</span>, u.Source, <span class="hljs-string">&quot;pods&quot;</span>, klog.KObjSlice(u.Pods))<br>handler.HandlePodUpdates(u.Pods)<br><span class="hljs-keyword">case</span> kubetypes.REMOVE:<br>klog.V(<span class="hljs-number">2</span>).InfoS(<span class="hljs-string">&quot;SyncLoop REMOVE&quot;</span>, <span class="hljs-string">&quot;source&quot;</span>, u.Source, <span class="hljs-string">&quot;pods&quot;</span>, klog.KObjSlice(u.Pods))<br>handler.HandlePodRemoves(u.Pods)<br><span class="hljs-keyword">case</span> kubetypes.RECONCILE:<br>klog.V(<span class="hljs-number">4</span>).InfoS(<span class="hljs-string">&quot;SyncLoop RECONCILE&quot;</span>, <span class="hljs-string">&quot;source&quot;</span>, u.Source, <span class="hljs-string">&quot;pods&quot;</span>, klog.KObjSlice(u.Pods))<br>handler.HandlePodReconcile(u.Pods)<br><span class="hljs-keyword">case</span> kubetypes.DELETE:<br>klog.V(<span class="hljs-number">2</span>).InfoS(<span class="hljs-string">&quot;SyncLoop DELETE&quot;</span>, <span class="hljs-string">&quot;source&quot;</span>, u.Source, <span class="hljs-string">&quot;pods&quot;</span>, klog.KObjSlice(u.Pods))<br><span class="hljs-comment">// DELETE is treated as a UPDATE because of graceful deletion.</span><br>handler.HandlePodUpdates(u.Pods)<br><span class="hljs-keyword">case</span> kubetypes.SET:<br><span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Do we want to support this?</span><br>klog.ErrorS(<span class="hljs-literal">nil</span>, <span class="hljs-string">&quot;Kubelet does not support snapshot update&quot;</span>)<br><span class="hljs-keyword">default</span>:<br>klog.ErrorS(<span class="hljs-literal">nil</span>, <span class="hljs-string">&quot;Invalid operation type received&quot;</span>, <span class="hljs-string">&quot;operation&quot;</span>, u.Op)<br>&#125;<br><br>kl.sourcesReady.AddSource(u.Source)<br><br></code></pre></td></tr></table></figure><p>kubelet 将Pod的操作类型分为<code>kubetypes.ADD、kubetypes.UPDATE、kubetypes.REMOVE 、kubetypes.RECONCILE、kubetypes.DELETE、kubetypes.SE</code>，并根据事件的类型调用handler的对应接口进行处理。</p><h3 id="handler-HandlePodAdditions-u-Pods"><a href="#handler-HandlePodAdditions-u-Pods" class="headerlink" title="handler.HandlePodAdditions(u.Pods)"></a>handler.HandlePodAdditions(u.Pods)</h3><p>其函数实现为：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-comment">// HandlePodAdditions is the callback in SyncHandler for pods being added from</span><br><span class="hljs-comment">// a config source.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(kl *Kubelet)</span></span> HandlePodAdditions(pods []*v1.Pod) &#123;<br>start := kl.clock.Now()<br>sort.Sort(sliceutils.PodsByCreationTime(pods))<br><span class="hljs-keyword">for</span> _, pod := <span class="hljs-keyword">range</span> pods &#123;<br>existingPods := kl.podManager.GetPods()<br><span class="hljs-comment">// Always add the pod to the pod manager. Kubelet relies on the pod</span><br><span class="hljs-comment">// manager as the source of truth for the desired state. If a pod does</span><br><span class="hljs-comment">// not exist in the pod manager, it means that it has been deleted in</span><br><span class="hljs-comment">// the apiserver and no action (other than cleanup) is required.</span><br>kl.podManager.AddPod(pod)<br><br>pod, mirrorPod, wasMirror := kl.podManager.GetPodAndMirrorPod(pod)<br><span class="hljs-keyword">if</span> wasMirror &#123;<br><span class="hljs-keyword">if</span> pod == <span class="hljs-literal">nil</span> &#123;<br>klog.V(<span class="hljs-number">2</span>).InfoS(<span class="hljs-string">&quot;Unable to find pod for mirror pod, skipping&quot;</span>, <span class="hljs-string">&quot;mirrorPod&quot;</span>, klog.KObj(mirrorPod), <span class="hljs-string">&quot;mirrorPodUID&quot;</span>, mirrorPod.UID)<br><span class="hljs-keyword">continue</span><br>&#125;<br>kl.podWorkers.UpdatePod(UpdatePodOptions&#123;<br>Pod:        pod,<br>MirrorPod:  mirrorPod,<br>UpdateType: kubetypes.SyncPodUpdate,<br>StartTime:  start,<br>&#125;)<br><span class="hljs-keyword">continue</span><br>&#125;<br><br><span class="hljs-comment">// Only go through the admission process if the pod is not requested</span><br><span class="hljs-comment">// for termination by another part of the kubelet. If the pod is already</span><br><span class="hljs-comment">// using resources (previously admitted), the pod worker is going to be</span><br><span class="hljs-comment">// shutting it down. If the pod hasn&#x27;t started yet, we know that when</span><br><span class="hljs-comment">// the pod worker is invoked it will also avoid setting up the pod, so</span><br><span class="hljs-comment">// we simply avoid doing any work.</span><br><span class="hljs-keyword">if</span> !kl.podWorkers.IsPodTerminationRequested(pod.UID) &#123;<br><span class="hljs-comment">// We failed pods that we rejected, so activePods include all admitted</span><br><span class="hljs-comment">// pods that are alive.</span><br>activePods := kl.filterOutInactivePods(existingPods)<br><br><span class="hljs-keyword">if</span> utilfeature.DefaultFeatureGate.Enabled(features.InPlacePodVerticalScaling) &#123;&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// Check if we can admit the pod; if not, reject it.</span><br><span class="hljs-keyword">if</span> ok, reason, message := kl.canAdmitPod(activePods, pod); !ok &#123;<br>kl.rejectPod(pod, reason, message)<br><span class="hljs-keyword">continue</span><br>&#125;<br>&#125;<br>&#125;<br>kl.podWorkers.UpdatePod(UpdatePodOptions&#123;<br>Pod:        pod,<br>MirrorPod:  mirrorPod,<br>UpdateType: kubetypes.SyncPodCreate,<br>StartTime:  start,<br>&#125;)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>将待添加的pods按照创建时间进行排序</li><li>依次遍历每个Pod</li><li>获取<code>podManager</code>已经存在的pod，podManager缓存了该Kubelet所有已经<code>admitted</code>的pods和mirror pods</li><li>将新的Pod添加到<code>podManager</code>中</li><li>调用<code>podManager</code>获取到缓存里该Pod对应的pod和mirror pod，并判断是否是<code>mirror pod</code>，调用<code>kl.podWorkers.UpdatePod</code>传递更新事件。</li><li>判断是否Pod的<code>Termination</code>请求，是的话调用<code>kl.podWorkers.UpdatePod</code>传递更新事件，否则检查是否应该Admit该Pod（资源限制、节点匹配、xxxx），然后再调用<code>kl.podWorkers.UpdatePod</code>。</li><li>无论是 MirrorPod 还是正常 Pod ，最终都是调用 <code>kl.podWorkers.UpdatePod</code> 接口进行处理，他们的区别在于传进去的参数的不同。MirrorPod所有的&#x3D;操作类型都被当做 UPDATE 来处理，更新它在 apiserver 上的状态。</li></ol><h3 id="handler-HandlePodUpdates-u-Pods"><a href="#handler-HandlePodUpdates-u-Pods" class="headerlink" title="handler.HandlePodUpdates(u.Pods)"></a>handler.HandlePodUpdates(u.Pods)</h3><p>其实现如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs golang"><br><span class="hljs-comment">// HandlePodUpdates is the callback in the SyncHandler interface for pods</span><br><span class="hljs-comment">// being updated from a config source.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(kl *Kubelet)</span></span> HandlePodUpdates(pods []*v1.Pod) &#123;<br>start := kl.clock.Now()<br><span class="hljs-keyword">for</span> _, pod := <span class="hljs-keyword">range</span> pods &#123;<br>kl.podManager.UpdatePod(pod)<br><br>pod, mirrorPod, wasMirror := kl.podManager.GetPodAndMirrorPod(pod)<br><span class="hljs-keyword">if</span> wasMirror &#123;<br><span class="hljs-keyword">if</span> pod == <span class="hljs-literal">nil</span> &#123;<br>klog.V(<span class="hljs-number">2</span>).InfoS(<span class="hljs-string">&quot;Unable to find pod for mirror pod, skipping&quot;</span>, <span class="hljs-string">&quot;mirrorPod&quot;</span>, klog.KObj(mirrorPod), <span class="hljs-string">&quot;mirrorPodUID&quot;</span>, mirrorPod.UID)<br><span class="hljs-keyword">continue</span><br>&#125;<br>&#125;<br><br>kl.podWorkers.UpdatePod(UpdatePodOptions&#123;<br>Pod:        pod,<br>MirrorPod:  mirrorPod,<br>UpdateType: kubetypes.SyncPodUpdate,<br>StartTime:  start,<br>&#125;)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>主要做了两件事：</p><ol><li>更新<code>podManager</code>里的缓存</li><li>判断是否是MirrorPod，最终调用 <code>kl.podWorkers.UpdatePod</code> 接口进行处理。</li></ol><h3 id="handler-HandlePodRemoves-u-Pods"><a href="#handler-HandlePodRemoves-u-Pods" class="headerlink" title="handler.HandlePodRemoves(u.Pods)"></a>handler.HandlePodRemoves(u.Pods)</h3><p>其具体实现如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs golang"><br><span class="hljs-comment">// HandlePodRemoves is the callback in the SyncHandler interface for pods</span><br><span class="hljs-comment">// being removed from a config source.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(kl *Kubelet)</span></span> HandlePodRemoves(pods []*v1.Pod) &#123;<br>start := kl.clock.Now()<br><span class="hljs-keyword">for</span> _, pod := <span class="hljs-keyword">range</span> pods &#123;<br>kl.podManager.RemovePod(pod)<br><br>pod, mirrorPod, wasMirror := kl.podManager.GetPodAndMirrorPod(pod)<br><span class="hljs-keyword">if</span> wasMirror &#123;<br><span class="hljs-keyword">if</span> pod == <span class="hljs-literal">nil</span> &#123;<br>klog.V(<span class="hljs-number">2</span>).InfoS(<span class="hljs-string">&quot;Unable to find pod for mirror pod, skipping&quot;</span>, <span class="hljs-string">&quot;mirrorPod&quot;</span>, klog.KObj(mirrorPod), <span class="hljs-string">&quot;mirrorPodUID&quot;</span>, mirrorPod.UID)<br><span class="hljs-keyword">continue</span><br>&#125;<br>kl.podWorkers.UpdatePod(UpdatePodOptions&#123;<br>Pod:        pod,<br>MirrorPod:  mirrorPod,<br>UpdateType: kubetypes.SyncPodUpdate,<br>StartTime:  start,<br>&#125;)<br><span class="hljs-keyword">continue</span><br>&#125;<br><br><span class="hljs-comment">// Deletion is allowed to fail because the periodic cleanup routine</span><br><span class="hljs-comment">// will trigger deletion again.</span><br><span class="hljs-keyword">if</span> err := kl.deletePod(pod); err != <span class="hljs-literal">nil</span> &#123;<br>klog.V(<span class="hljs-number">2</span>).InfoS(<span class="hljs-string">&quot;Failed to delete pod&quot;</span>, <span class="hljs-string">&quot;pod&quot;</span>, klog.KObj(pod), <span class="hljs-string">&quot;err&quot;</span>, err)<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>跟<code>HandlePodUpdates</code>实现差不多，只不过在最后调用<code>kl.deletePod(pod)</code>从Kubelet内部的状态里删除对应的Pod，其内部分为两个步骤：</p><ol><li>异步停止所有相关联的pod worker</li><li>给<code>podKillingCh</code>发送signal通知pod进行kill的过程</li></ol><h3 id="handler-HandlePodRemoves-u-Pods-1"><a href="#handler-HandlePodRemoves-u-Pods-1" class="headerlink" title="handler.HandlePodRemoves(u.Pods)"></a>handler.HandlePodRemoves(u.Pods)</h3><p>其具体实现如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(kl *Kubelet)</span></span> HandlePodReconcile(pods []*v1.Pod) &#123;<br>start := kl.clock.Now()<br><span class="hljs-keyword">for</span> _, pod := <span class="hljs-keyword">range</span> pods &#123;<br><span class="hljs-comment">// Update the pod in pod manager, status manager will do periodically reconcile according</span><br><span class="hljs-comment">// to the pod manager.</span><br>kl.podManager.UpdatePod(pod)<br><br>pod, mirrorPod, wasMirror := kl.podManager.GetPodAndMirrorPod(pod)<br><span class="hljs-keyword">if</span> wasMirror &#123;<br><span class="hljs-keyword">if</span> pod == <span class="hljs-literal">nil</span> &#123;<br>klog.V(<span class="hljs-number">2</span>).InfoS(<span class="hljs-string">&quot;Unable to find pod for mirror pod, skipping&quot;</span>, <span class="hljs-string">&quot;mirrorPod&quot;</span>, klog.KObj(mirrorPod), <span class="hljs-string">&quot;mirrorPodUID&quot;</span>, mirrorPod.UID)<br><span class="hljs-keyword">continue</span><br>&#125;<br><span class="hljs-comment">// Static pods should be reconciled the same way as regular pods</span><br>&#125;<br><br><br><span class="hljs-keyword">if</span> status.NeedToReconcilePodReadiness(pod) &#123;<br>kl.podWorkers.UpdatePod(UpdatePodOptions&#123;<br>Pod:        pod,<br>MirrorPod:  mirrorPod,<br>UpdateType: kubetypes.SyncPodSync,<br>StartTime:  start,<br>&#125;)<br>&#125;<br><br><br><span class="hljs-keyword">if</span> eviction.PodIsEvicted(pod.Status) &#123;<br><span class="hljs-keyword">if</span> podStatus, err := kl.podCache.Get(pod.UID); err == <span class="hljs-literal">nil</span> &#123;<br>kl.containerDeletor.deleteContainersInPod(<span class="hljs-string">&quot;&quot;</span>, podStatus, <span class="hljs-literal">true</span>)<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>handler.HandlePodReconcile() 分 3 步走，先将 pod 状态更新到缓存中，然后判断 pod 状态是否需要重新reconcile ，则调用 <code>kl.podWorkers.UpdatePod</code> 完成同步，如果是被驱逐的，则删掉该Pod的所有容器。</p><h2 id="kl-podWorkers-UpdatePod"><a href="#kl-podWorkers-UpdatePod" class="headerlink" title="kl.podWorkers.UpdatePod"></a>kl.podWorkers.UpdatePod</h2><p><code>kl.podWorkers.UpdatePod</code>处理pod的配置变化和pod的<code>termination</code>状态，其具体实现为：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br></pre></td><td class="code"><pre><code class="hljs golang"><br><span class="hljs-comment">// UpdatePod carries a configuration change or termination state to a pod. A pod is either runnable,</span><br><span class="hljs-comment">// terminating, or terminated, and will transition to terminating if: deleted on the apiserver,</span><br><span class="hljs-comment">// discovered to have a terminal phase (Succeeded or Failed), or evicted by the kubelet.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *podWorkers)</span></span> UpdatePod(options UpdatePodOptions) &#123;<br><span class="hljs-comment">// Handle when the pod is an orphan (no config) and we only have runtime status by running only</span><br><span class="hljs-comment">// the terminating part of the lifecycle. A running pod contains only a minimal set of information</span><br><span class="hljs-comment">// about the pod</span><br><span class="hljs-keyword">var</span> isRuntimePod <span class="hljs-type">bool</span><br><span class="hljs-keyword">var</span> uid types.UID<br><span class="hljs-keyword">var</span> name, ns <span class="hljs-type">string</span><br><span class="hljs-keyword">if</span> runningPod := options.RunningPod; runningPod != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">if</span> options.Pod == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-comment">// the sythetic pod created here is used only as a placeholder and not tracked</span><br><span class="hljs-keyword">if</span> options.UpdateType != kubetypes.SyncPodKill &#123;<br>klog.InfoS(<span class="hljs-string">&quot;Pod update is ignored, runtime pods can only be killed&quot;</span>, <span class="hljs-string">&quot;pod&quot;</span>, klog.KRef(runningPod.Namespace, runningPod.Name), <span class="hljs-string">&quot;podUID&quot;</span>, runningPod.ID, <span class="hljs-string">&quot;updateType&quot;</span>, options.UpdateType)<br><span class="hljs-keyword">return</span><br>&#125;<br>uid, ns, name = runningPod.ID, runningPod.Namespace, runningPod.Name<br>isRuntimePod = <span class="hljs-literal">true</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>options.RunningPod = <span class="hljs-literal">nil</span><br>uid, ns, name = options.Pod.UID, options.Pod.Namespace, options.Pod.Name<br>klog.InfoS(<span class="hljs-string">&quot;Pod update included RunningPod which is only valid when Pod is not specified&quot;</span>, <span class="hljs-string">&quot;pod&quot;</span>, klog.KRef(ns, name), <span class="hljs-string">&quot;podUID&quot;</span>, uid, <span class="hljs-string">&quot;updateType&quot;</span>, options.UpdateType)<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>uid, ns, name = options.Pod.UID, options.Pod.Namespace, options.Pod.Name<br>&#125;<br><br>p.podLock.Lock()<br><span class="hljs-keyword">defer</span> p.podLock.Unlock()<br><br><span class="hljs-comment">// decide what to do with this pod - we are either setting it up, tearing it down, or ignoring it</span><br><span class="hljs-keyword">var</span> firstTime <span class="hljs-type">bool</span><br>now := p.clock.Now()<br>status, ok := p.podSyncStatuses[uid]<br><span class="hljs-keyword">if</span> !ok &#123;<br>klog.V(<span class="hljs-number">4</span>).InfoS(<span class="hljs-string">&quot;Pod is being synced for the first time&quot;</span>, <span class="hljs-string">&quot;pod&quot;</span>, klog.KRef(ns, name), <span class="hljs-string">&quot;podUID&quot;</span>, uid, <span class="hljs-string">&quot;updateType&quot;</span>, options.UpdateType)<br>firstTime = <span class="hljs-literal">true</span><br>status = &amp;podSyncStatus&#123;<br>syncedAt: now,<br>fullname: kubecontainer.BuildPodFullName(name, ns),<br>&#125;<br><span class="hljs-comment">// if this pod is being synced for the first time, we need to make sure it is an active pod</span><br><span class="hljs-keyword">if</span> options.Pod != <span class="hljs-literal">nil</span> &amp;&amp; (options.Pod.Status.Phase == v1.PodFailed || options.Pod.Status.Phase == v1.PodSucceeded) &#123;<br><span class="hljs-comment">// Check to see if the pod is not running and the pod is terminal; if this succeeds then record in the podWorker that it is terminated.</span><br><span class="hljs-comment">// This is needed because after a kubelet restart, we need to ensure terminal pods will NOT be considered active in Pod Admission. See http://issues.k8s.io/105523</span><br><span class="hljs-comment">// However, `filterOutInactivePods`, considers pods that are actively terminating as active. As a result, `IsPodKnownTerminated()` needs to return true and thus `terminatedAt` needs to be set.</span><br><span class="hljs-keyword">if</span> statusCache, err := p.podCache.Get(uid); err == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">if</span> isPodStatusCacheTerminal(statusCache) &#123;<br><span class="hljs-comment">// At this point we know:</span><br><span class="hljs-comment">// (1) The pod is terminal based on the config source.</span><br><span class="hljs-comment">// (2) The pod is terminal based on the runtime cache.</span><br><span class="hljs-comment">// This implies that this pod had already completed `SyncTerminatingPod` sometime in the past. The pod is likely being synced for the first time due to a kubelet restart.</span><br><span class="hljs-comment">// These pods need to complete SyncTerminatedPod to ensure that all resources are cleaned and that the status manager makes the final status updates for the pod.</span><br><span class="hljs-comment">// As a result, set finished: false, to ensure a Terminated event will be sent and `SyncTerminatedPod` will run.</span><br>status = &amp;podSyncStatus&#123;<br>terminatedAt:       now,<br>terminatingAt:      now,<br>syncedAt:           now,<br>startedTerminating: <span class="hljs-literal">true</span>,<br>finished:           <span class="hljs-literal">false</span>,<br>fullname:           kubecontainer.BuildPodFullName(name, ns),<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br>p.podSyncStatuses[uid] = status<br>&#125;<br><br><span class="hljs-comment">// RunningPods represent an unknown pod execution and don&#x27;t contain pod spec information</span><br><span class="hljs-comment">// sufficient to perform any action other than termination. If we received a RunningPod</span><br><span class="hljs-comment">// after a real pod has already been provided, use the most recent spec instead. Also,</span><br><span class="hljs-comment">// once we observe a runtime pod we must drive it to completion, even if we weren&#x27;t the</span><br><span class="hljs-comment">// ones who started it.</span><br>pod := options.Pod<br><span class="hljs-keyword">if</span> isRuntimePod &#123;<br>status.observedRuntime = <span class="hljs-literal">true</span><br><span class="hljs-keyword">switch</span> &#123;<br><span class="hljs-keyword">case</span> status.pendingUpdate != <span class="hljs-literal">nil</span> &amp;&amp; status.pendingUpdate.Pod != <span class="hljs-literal">nil</span>:<br>pod = status.pendingUpdate.Pod<br>options.Pod = pod<br>options.RunningPod = <span class="hljs-literal">nil</span><br><span class="hljs-keyword">case</span> status.activeUpdate != <span class="hljs-literal">nil</span> &amp;&amp; status.activeUpdate.Pod != <span class="hljs-literal">nil</span>:<br>pod = status.activeUpdate.Pod<br>options.Pod = pod<br>options.RunningPod = <span class="hljs-literal">nil</span><br><span class="hljs-keyword">default</span>:<br><span class="hljs-comment">// we will continue to use RunningPod.ToAPIPod() as pod here, but</span><br><span class="hljs-comment">// options.Pod will be nil and other methods must handle that appropriately.</span><br>pod = options.RunningPod.ToAPIPod()<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// When we see a create update on an already terminating pod, that implies two pods with the same UID were created in</span><br><span class="hljs-comment">// close temporal proximity (usually static pod but it&#x27;s possible for an apiserver to extremely rarely do something</span><br><span class="hljs-comment">// similar) - flag the sync status to indicate that after the pod terminates it should be reset to &quot;not running&quot; to</span><br><span class="hljs-comment">// allow a subsequent add/update to start the pod worker again. This does not apply to the first time we see a pod,</span><br><span class="hljs-comment">// such as when the kubelet restarts and we see already terminated pods for the first time.</span><br><span class="hljs-keyword">if</span> !firstTime &amp;&amp; status.IsTerminationRequested() &#123;<br><span class="hljs-keyword">if</span> options.UpdateType == kubetypes.SyncPodCreate &#123;<br>status.restartRequested = <span class="hljs-literal">true</span><br>klog.V(<span class="hljs-number">4</span>).InfoS(<span class="hljs-string">&quot;Pod is terminating but has been requested to restart with same UID, will be reconciled later&quot;</span>, <span class="hljs-string">&quot;pod&quot;</span>, klog.KRef(ns, name), <span class="hljs-string">&quot;podUID&quot;</span>, uid, <span class="hljs-string">&quot;updateType&quot;</span>, options.UpdateType)<br><span class="hljs-keyword">return</span><br>&#125;<br>&#125;<br><br><span class="hljs-comment">// once a pod is terminated by UID, it cannot reenter the pod worker (until the UID is purged by housekeeping)</span><br><span class="hljs-keyword">if</span> status.IsFinished() &#123;<br>klog.V(<span class="hljs-number">4</span>).InfoS(<span class="hljs-string">&quot;Pod is finished processing, no further updates&quot;</span>, <span class="hljs-string">&quot;pod&quot;</span>, klog.KRef(ns, name), <span class="hljs-string">&quot;podUID&quot;</span>, uid, <span class="hljs-string">&quot;updateType&quot;</span>, options.UpdateType)<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-comment">// check for a transition to terminating</span><br><span class="hljs-keyword">var</span> becameTerminating <span class="hljs-type">bool</span><br><span class="hljs-keyword">if</span> !status.IsTerminationRequested() &#123;<br><span class="hljs-keyword">switch</span> &#123;<br><span class="hljs-keyword">case</span> isRuntimePod:<br>klog.V(<span class="hljs-number">4</span>).InfoS(<span class="hljs-string">&quot;Pod is orphaned and must be torn down&quot;</span>, <span class="hljs-string">&quot;pod&quot;</span>, klog.KRef(ns, name), <span class="hljs-string">&quot;podUID&quot;</span>, uid, <span class="hljs-string">&quot;updateType&quot;</span>, options.UpdateType)<br>status.deleted = <span class="hljs-literal">true</span><br>status.terminatingAt = now<br>becameTerminating = <span class="hljs-literal">true</span><br><span class="hljs-keyword">case</span> pod.DeletionTimestamp != <span class="hljs-literal">nil</span>:<br>klog.V(<span class="hljs-number">4</span>).InfoS(<span class="hljs-string">&quot;Pod is marked for graceful deletion, begin teardown&quot;</span>, <span class="hljs-string">&quot;pod&quot;</span>, klog.KRef(ns, name), <span class="hljs-string">&quot;podUID&quot;</span>, uid, <span class="hljs-string">&quot;updateType&quot;</span>, options.UpdateType)<br>status.deleted = <span class="hljs-literal">true</span><br>status.terminatingAt = now<br>becameTerminating = <span class="hljs-literal">true</span><br><span class="hljs-keyword">case</span> pod.Status.Phase == v1.PodFailed, pod.Status.Phase == v1.PodSucceeded:<br>klog.V(<span class="hljs-number">4</span>).InfoS(<span class="hljs-string">&quot;Pod is in a terminal phase (success/failed), begin teardown&quot;</span>, <span class="hljs-string">&quot;pod&quot;</span>, klog.KRef(ns, name), <span class="hljs-string">&quot;podUID&quot;</span>, uid, <span class="hljs-string">&quot;updateType&quot;</span>, options.UpdateType)<br>status.terminatingAt = now<br>becameTerminating = <span class="hljs-literal">true</span><br><span class="hljs-keyword">case</span> options.UpdateType == kubetypes.SyncPodKill:<br><span class="hljs-keyword">if</span> options.KillPodOptions != <span class="hljs-literal">nil</span> &amp;&amp; options.KillPodOptions.Evict &#123;<br>klog.V(<span class="hljs-number">4</span>).InfoS(<span class="hljs-string">&quot;Pod is being evicted by the kubelet, begin teardown&quot;</span>, <span class="hljs-string">&quot;pod&quot;</span>, klog.KRef(ns, name), <span class="hljs-string">&quot;podUID&quot;</span>, uid, <span class="hljs-string">&quot;updateType&quot;</span>, options.UpdateType)<br>status.evicted = <span class="hljs-literal">true</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>klog.V(<span class="hljs-number">4</span>).InfoS(<span class="hljs-string">&quot;Pod is being removed by the kubelet, begin teardown&quot;</span>, <span class="hljs-string">&quot;pod&quot;</span>, klog.KRef(ns, name), <span class="hljs-string">&quot;podUID&quot;</span>, uid, <span class="hljs-string">&quot;updateType&quot;</span>, options.UpdateType)<br>&#125;<br>status.terminatingAt = now<br>becameTerminating = <span class="hljs-literal">true</span><br>&#125;<br>&#125;<br><br><span class="hljs-comment">// once a pod is terminating, all updates are kills and the grace period can only decrease</span><br><span class="hljs-keyword">var</span> wasGracePeriodShortened <span class="hljs-type">bool</span><br><span class="hljs-keyword">switch</span> &#123;<br><span class="hljs-keyword">case</span> status.IsTerminated():<br><span class="hljs-comment">// A terminated pod may still be waiting for cleanup - if we receive a runtime pod kill request</span><br><span class="hljs-comment">// due to housekeeping seeing an older cached version of the runtime pod simply ignore it until</span><br><span class="hljs-comment">// after the pod worker completes.</span><br><span class="hljs-keyword">if</span> isRuntimePod &#123;<br>klog.V(<span class="hljs-number">3</span>).InfoS(<span class="hljs-string">&quot;Pod is waiting for termination, ignoring runtime-only kill until after pod worker is fully terminated&quot;</span>, <span class="hljs-string">&quot;pod&quot;</span>, klog.KRef(ns, name), <span class="hljs-string">&quot;podUID&quot;</span>, uid, <span class="hljs-string">&quot;updateType&quot;</span>, options.UpdateType)<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-keyword">if</span> options.KillPodOptions != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">if</span> ch := options.KillPodOptions.CompletedCh; ch != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">close</span>(ch)<br>&#125;<br>&#125;<br>options.KillPodOptions = <span class="hljs-literal">nil</span><br><br><span class="hljs-keyword">case</span> status.IsTerminationRequested():<br><span class="hljs-keyword">if</span> options.KillPodOptions == <span class="hljs-literal">nil</span> &#123;<br>options.KillPodOptions = &amp;KillPodOptions&#123;&#125;<br>&#125;<br><br><span class="hljs-keyword">if</span> ch := options.KillPodOptions.CompletedCh; ch != <span class="hljs-literal">nil</span> &#123;<br>status.notifyPostTerminating = <span class="hljs-built_in">append</span>(status.notifyPostTerminating, ch)<br>&#125;<br><span class="hljs-keyword">if</span> fn := options.KillPodOptions.PodStatusFunc; fn != <span class="hljs-literal">nil</span> &#123;<br>status.statusPostTerminating = <span class="hljs-built_in">append</span>(status.statusPostTerminating, fn)<br>&#125;<br><br>gracePeriod, gracePeriodShortened := calculateEffectiveGracePeriod(status, pod, options.KillPodOptions)<br><br>wasGracePeriodShortened = gracePeriodShortened<br>status.gracePeriod = gracePeriod<br><span class="hljs-comment">// always set the grace period for syncTerminatingPod so we don&#x27;t have to recalculate,</span><br><span class="hljs-comment">// will never be zero.</span><br>options.KillPodOptions.PodTerminationGracePeriodSecondsOverride = &amp;gracePeriod<br><br><span class="hljs-keyword">default</span>:<br><span class="hljs-comment">// KillPodOptions is not valid for sync actions outside of the terminating phase</span><br><span class="hljs-keyword">if</span> options.KillPodOptions != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">if</span> ch := options.KillPodOptions.CompletedCh; ch != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">close</span>(ch)<br>&#125;<br>options.KillPodOptions = <span class="hljs-literal">nil</span><br>&#125;<br>&#125;<br><br><span class="hljs-comment">// start the pod worker goroutine if it doesn&#x27;t exist</span><br>podUpdates, exists := p.podUpdates[uid]<br><span class="hljs-keyword">if</span> !exists &#123;<br><span class="hljs-comment">// buffer the channel to avoid blocking this method</span><br>podUpdates = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;, <span class="hljs-number">1</span>)<br>p.podUpdates[uid] = podUpdates<br><br><span class="hljs-comment">// ensure that static pods start in the order they are received by UpdatePod</span><br><span class="hljs-keyword">if</span> kubetypes.IsStaticPod(pod) &#123;<br>p.waitingToStartStaticPodsByFullname[status.fullname] =<br><span class="hljs-built_in">append</span>(p.waitingToStartStaticPodsByFullname[status.fullname], uid)<br>&#125;<br><br><span class="hljs-comment">// allow testing of delays in the pod update channel</span><br><span class="hljs-keyword">var</span> outCh &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;<br><span class="hljs-keyword">if</span> p.workerChannelFn != <span class="hljs-literal">nil</span> &#123;<br>outCh = p.workerChannelFn(uid, podUpdates)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>outCh = podUpdates<br>&#125;<br><br><span class="hljs-comment">// spawn a pod worker</span><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> this should be a wait.Until with backoff to handle panics, and</span><br><span class="hljs-comment">// accept a context for shutdown</span><br><span class="hljs-keyword">defer</span> runtime.HandleCrash()<br><span class="hljs-keyword">defer</span> klog.V(<span class="hljs-number">3</span>).InfoS(<span class="hljs-string">&quot;Pod worker has stopped&quot;</span>, <span class="hljs-string">&quot;podUID&quot;</span>, uid)<br>p.podWorkerLoop(uid, outCh)<br>&#125;()<br>&#125;<br><br><span class="hljs-comment">// measure the maximum latency between a call to UpdatePod and when the pod worker reacts to it</span><br><span class="hljs-comment">// by preserving the oldest StartTime</span><br><span class="hljs-keyword">if</span> status.pendingUpdate != <span class="hljs-literal">nil</span> &amp;&amp; !status.pendingUpdate.StartTime.IsZero() &amp;&amp; status.pendingUpdate.StartTime.Before(options.StartTime) &#123;<br>options.StartTime = status.pendingUpdate.StartTime<br>&#125;<br><br><span class="hljs-comment">// notify the pod worker there is a pending update</span><br>status.pendingUpdate = &amp;options<br>status.working = <span class="hljs-literal">true</span><br>klog.V(<span class="hljs-number">4</span>).InfoS(<span class="hljs-string">&quot;Notifying pod of pending update&quot;</span>, <span class="hljs-string">&quot;pod&quot;</span>, klog.KRef(ns, name), <span class="hljs-string">&quot;podUID&quot;</span>, uid, <span class="hljs-string">&quot;workType&quot;</span>, status.WorkType())<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> podUpdates &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;:<br><span class="hljs-keyword">default</span>:<br>&#125;<br><br><span class="hljs-keyword">if</span> (becameTerminating || wasGracePeriodShortened) &amp;&amp; status.cancelFn != <span class="hljs-literal">nil</span> &#123;<br>klog.V(<span class="hljs-number">3</span>).InfoS(<span class="hljs-string">&quot;Cancelling current pod sync&quot;</span>, <span class="hljs-string">&quot;pod&quot;</span>, klog.KRef(ns, name), <span class="hljs-string">&quot;podUID&quot;</span>, uid, <span class="hljs-string">&quot;workType&quot;</span>, status.WorkType())<br>status.cancelFn()<br><span class="hljs-keyword">return</span><br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><code>RuntimePod</code>是指正在被container runtime执行，但kubelet无法获取到对应Pod的相关配置信息的Pod。对于此种Pod，kubelet会执行<code>termination</code>操作。</p><ol><li>判断Pod是否为<code>RuntimePod</code></li><li>将Pod的相关状态信息更新到<code>p.podSyncStatuses[uid]</code></li><li>如果能从缓存中拿到该 pod 的缓存，而且 pod 处于终止状态，而这时候 options.UpdateType &#x3D;&#x3D; kubetypes.SyncPodCreate ，则说明使用相同 uid 的 pod 需要被重启，会被后续的程序处理。</li><li>检查 pod 是否转换到<code>Terminating</code>状态。并根据相关状态去更新<code>options</code>和<code>status</code>的值。</li><li>kubelet 会为每一个Pod创建一条单独的<code>goroutine</code>负责监听该Pod的更新事件并负责后续的状态更新，<code>p.podUpdates</code>负责跟踪kubelet所有启动的此类goroutine。若待更新的Pod不存在此<code>goroutine</code>，则调用<code>p.podWorkerLoop(uid, outCh)</code>创建。</li><li>每次更新实际都是将更新事件发送到 podUpdates 通道，这个通道的另一端就是 <code>p.podWorkerLoop(uid, outCh)</code> 在监听。</li></ol><h2 id="p-podWorkerLoop-uid-outCh"><a href="#p-podWorkerLoop-uid-outCh" class="headerlink" title="p.podWorkerLoop(uid, outCh)"></a>p.podWorkerLoop(uid, outCh)</h2><p><code>podWorkerLoop</code>负责管理 Pod 的顺序状态更新，直到达到最终状态后退出。这个循环主要负责推动 Pod 经过以下四个主要阶段：</p><ul><li><p>等待开始（Wait to start）：确保同一时间不会有两个具有相同 UID 或全名的 Pod 同时运行。</p></li><li><p>同步（Sync）：通过协调期望的 Pod 规格和 Pod 的运行时状态来安排 Pod 的设置，这是一个组织 Pod 设置过程的阶段。</p></li><li><p>终止中（Terminating）：确保 Pod 中所有正在运行的容器都被停止。</p></li><li><p>已终止（Terminated）：清理必须释放的任何资源，以便 Pod 可以被删除。</p></li></ul><p>其代码实现为：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *podWorkers)</span></span> podWorkerLoop(podUID types.UID, podUpdates &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;) &#123;<br><span class="hljs-keyword">var</span> lastSyncTime time.Time<br><span class="hljs-keyword">for</span> <span class="hljs-keyword">range</span> podUpdates &#123;<br>ctx, update, canStart, canEverStart, ok := p.startPodSync(podUID)<br><span class="hljs-comment">// If we had no update waiting, it means someone initialized the channel without filling out pendingUpdate.</span><br><span class="hljs-keyword">if</span> !ok &#123;<br><span class="hljs-keyword">continue</span><br>&#125;<br><span class="hljs-comment">// If the pod was terminated prior to the pod being allowed to start, we exit the loop.</span><br><span class="hljs-keyword">if</span> !canEverStart &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-comment">// If the pod is not yet ready to start, continue and wait for more updates.</span><br><span class="hljs-keyword">if</span> !canStart &#123;<br><span class="hljs-keyword">continue</span><br>&#125;<br><br>podUID, podRef := podUIDAndRefForUpdate(update.Options)<br><br>klog.V(<span class="hljs-number">4</span>).InfoS(<span class="hljs-string">&quot;Processing pod event&quot;</span>, <span class="hljs-string">&quot;pod&quot;</span>, podRef, <span class="hljs-string">&quot;podUID&quot;</span>, podUID, <span class="hljs-string">&quot;updateType&quot;</span>, update.WorkType)<br><span class="hljs-keyword">var</span> isTerminal <span class="hljs-type">bool</span><br>err := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span> &#123;<br><span class="hljs-comment">// The worker is responsible for ensuring the sync method sees the appropriate</span><br><span class="hljs-comment">// status updates on resyncs (the result of the last sync), transitions to</span><br><span class="hljs-comment">// terminating (no wait), or on terminated (whatever the most recent state is).</span><br><span class="hljs-comment">// Only syncing and terminating can generate pod status changes, while terminated</span><br><span class="hljs-comment">// pods ensure the most recent status makes it to the api server.</span><br><span class="hljs-keyword">var</span> status *kubecontainer.PodStatus<br><span class="hljs-keyword">var</span> err <span class="hljs-type">error</span><br><span class="hljs-keyword">switch</span> &#123;<br><span class="hljs-keyword">case</span> update.Options.RunningPod != <span class="hljs-literal">nil</span>:<br><span class="hljs-comment">// when we receive a running pod, we don&#x27;t need status at all because we are</span><br><span class="hljs-comment">// guaranteed to be terminating and we skip updates to the pod</span><br><span class="hljs-keyword">default</span>:<br><span class="hljs-comment">// wait until we see the next refresh from the PLEG via the cache (max 2s)</span><br><span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> this adds ~1s of latency on all transitions from sync to terminating</span><br><span class="hljs-comment">//  to terminated, and on all termination retries (including evictions). We should</span><br><span class="hljs-comment">//  improve latency by making the pleg continuous and by allowing pod status</span><br><span class="hljs-comment">//  changes to be refreshed when key events happen (killPod, sync-&gt;terminating).</span><br><span class="hljs-comment">//  Improving this latency also reduces the possibility that a terminated</span><br><span class="hljs-comment">//  container&#x27;s status is garbage collected before we have a chance to update the</span><br><span class="hljs-comment">//  API server (thus losing the exit code).</span><br>status, err = p.podCache.GetNewerThan(update.Options.Pod.UID, lastSyncTime)<br><br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-comment">// This is the legacy event thrown by manage pod loop all other events are now dispatched</span><br><span class="hljs-comment">// from syncPodFn</span><br>p.recorder.Eventf(update.Options.Pod, v1.EventTypeWarning, events.FailedSync, <span class="hljs-string">&quot;error determining status: %v&quot;</span>, err)<br><span class="hljs-keyword">return</span> err<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// Take the appropriate action (illegal phases are prevented by UpdatePod)</span><br><span class="hljs-keyword">switch</span> &#123;<br><span class="hljs-keyword">case</span> update.WorkType == TerminatedPod:<br>err = p.podSyncer.SyncTerminatedPod(ctx, update.Options.Pod, status)<br><br><span class="hljs-keyword">case</span> update.WorkType == TerminatingPod:<br><span class="hljs-keyword">var</span> gracePeriod *<span class="hljs-type">int64</span><br><span class="hljs-keyword">if</span> opt := update.Options.KillPodOptions; opt != <span class="hljs-literal">nil</span> &#123;<br>gracePeriod = opt.PodTerminationGracePeriodSecondsOverride<br>&#125;<br>podStatusFn := p.acknowledgeTerminating(podUID)<br><br><span class="hljs-comment">// if we only have a running pod, terminate it directly</span><br><span class="hljs-keyword">if</span> update.Options.RunningPod != <span class="hljs-literal">nil</span> &#123;<br>err = p.podSyncer.SyncTerminatingRuntimePod(ctx, update.Options.RunningPod)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>err = p.podSyncer.SyncTerminatingPod(ctx, update.Options.Pod, status, gracePeriod, podStatusFn)<br>&#125;<br><br><span class="hljs-keyword">default</span>:<br>isTerminal, err = p.podSyncer.SyncPod(ctx, update.Options.UpdateType, update.Options.Pod, update.Options.MirrorPod, status)<br>&#125;<br><br>lastSyncTime = p.clock.Now()<br><span class="hljs-keyword">return</span> err<br>&#125;()<br><br><span class="hljs-keyword">var</span> phaseTransition <span class="hljs-type">bool</span><br><span class="hljs-keyword">switch</span> &#123;<br><span class="hljs-keyword">case</span> errors.Is(err, context.Canceled):<br><span class="hljs-comment">// when the context is cancelled we expect an update to already be queued</span><br>klog.V(<span class="hljs-number">2</span>).InfoS(<span class="hljs-string">&quot;Sync exited with context cancellation error&quot;</span>, <span class="hljs-string">&quot;pod&quot;</span>, podRef, <span class="hljs-string">&quot;podUID&quot;</span>, podUID, <span class="hljs-string">&quot;updateType&quot;</span>, update.WorkType)<br><br><span class="hljs-keyword">case</span> err != <span class="hljs-literal">nil</span>:<br><span class="hljs-comment">// we will queue a retry</span><br>klog.ErrorS(err, <span class="hljs-string">&quot;Error syncing pod, skipping&quot;</span>, <span class="hljs-string">&quot;pod&quot;</span>, podRef, <span class="hljs-string">&quot;podUID&quot;</span>, podUID)<br><br><span class="hljs-keyword">case</span> update.WorkType == TerminatedPod:<br><span class="hljs-comment">// we can shut down the worker</span><br>p.completeTerminated(podUID)<br><span class="hljs-keyword">if</span> start := update.Options.StartTime; !start.IsZero() &#123;<br>metrics.PodWorkerDuration.WithLabelValues(<span class="hljs-string">&quot;terminated&quot;</span>).Observe(metrics.SinceInSeconds(start))<br>&#125;<br>klog.V(<span class="hljs-number">4</span>).InfoS(<span class="hljs-string">&quot;Processing pod event done&quot;</span>, <span class="hljs-string">&quot;pod&quot;</span>, podRef, <span class="hljs-string">&quot;podUID&quot;</span>, podUID, <span class="hljs-string">&quot;updateType&quot;</span>, update.WorkType)<br><span class="hljs-keyword">return</span><br><br><span class="hljs-keyword">case</span> update.WorkType == TerminatingPod:<br><span class="hljs-comment">// pods that don&#x27;t exist in config don&#x27;t need to be terminated, other loops will clean them up</span><br><span class="hljs-keyword">if</span> update.Options.RunningPod != <span class="hljs-literal">nil</span> &#123;<br>p.completeTerminatingRuntimePod(podUID)<br><span class="hljs-keyword">if</span> start := update.Options.StartTime; !start.IsZero() &#123;<br>metrics.PodWorkerDuration.WithLabelValues(update.Options.UpdateType.String()).Observe(metrics.SinceInSeconds(start))<br>&#125;<br>klog.V(<span class="hljs-number">4</span>).InfoS(<span class="hljs-string">&quot;Processing pod event done&quot;</span>, <span class="hljs-string">&quot;pod&quot;</span>, podRef, <span class="hljs-string">&quot;podUID&quot;</span>, podUID, <span class="hljs-string">&quot;updateType&quot;</span>, update.WorkType)<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-comment">// otherwise we move to the terminating phase</span><br>p.completeTerminating(podUID)<br>phaseTransition = <span class="hljs-literal">true</span><br><br><span class="hljs-keyword">case</span> isTerminal:<br><span class="hljs-comment">// if syncPod indicated we are now terminal, set the appropriate pod status to move to terminating</span><br>klog.V(<span class="hljs-number">4</span>).InfoS(<span class="hljs-string">&quot;Pod is terminal&quot;</span>, <span class="hljs-string">&quot;pod&quot;</span>, podRef, <span class="hljs-string">&quot;podUID&quot;</span>, podUID, <span class="hljs-string">&quot;updateType&quot;</span>, update.WorkType)<br>p.completeSync(podUID)<br>phaseTransition = <span class="hljs-literal">true</span><br>&#125;<br><br><span class="hljs-comment">// queue a retry if necessary, then put the next event in the channel if any</span><br>p.completeWork(podUID, phaseTransition, err)<br><span class="hljs-keyword">if</span> start := update.Options.StartTime; !start.IsZero() &#123;<br>metrics.PodWorkerDuration.WithLabelValues(update.Options.UpdateType.String()).Observe(metrics.SinceInSeconds(start))<br>&#125;<br>klog.V(<span class="hljs-number">4</span>).InfoS(<span class="hljs-string">&quot;Processing pod event done&quot;</span>, <span class="hljs-string">&quot;pod&quot;</span>, podRef, <span class="hljs-string">&quot;podUID&quot;</span>, podUID, <span class="hljs-string">&quot;updateType&quot;</span>, update.WorkType)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>调用<code>p.startPodSync(podUID)</code>判断是否pod是否已经启动，若未启动，则返回能否启动，同时在<code>p.startPodSync</code>内部更新了pod的缓存状态。</li><li><code> p.podCache.GetNewerThan(update.Options.Pod.UID, lastSyncTime)</code>从缓存中根据 uid 获取 pod 的状态信息</li><li>根据 &#96;update.WorkType&#96;&#96; 的不同调用不同的接口来同步 pod ，有以下接口。</li></ol><ul><li>p.syncPod() ，对新的 pod 进行同步。</li><li>p.syncTerminatedPod() ，对已退出状态的 pod 进行同步。</li><li>p.syncTerminatingPod() ，对正在退出状态的 pod 进行同步。</li><li>p.SyncTerminatingRuntimePod() ，对<code>RuntimePod</code>进行同步</li></ul><ol start="4"><li>根据同步类型的完成，不同的同步接口回调不同的完成接口。</li></ol><ul><li>p.completeTerminatingRuntimePod() ，当退出状态的孤儿 pod 完成同步时调用。</li><li>p.completeTerminating() ，当退出状态的 pod 完成同步时调用。</li><li>p.completeSync() ，当完成新 pod 的同步时调用。</li><li>p.completeWork() ，完成同步工作时调用。</li></ul><h3 id="p-syncPod"><a href="#p-syncPod" class="headerlink" title="p.syncPod()"></a>p.syncPod()</h3><p><code>p.syncPod()</code> 负责单个Pod的状态同步，这是一个可重入的方法，负责推进Pod的状态直到期望的状态为止，其代码实现为：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(kl *Kubelet)</span></span> SyncPod(ctx context.Context, updateType kubetypes.SyncPodType, pod, mirrorPod *v1.Pod, podStatus *kubecontainer.PodStatus) (isTerminal <span class="hljs-type">bool</span>, err <span class="hljs-type">error</span>) &#123;<br>ctx, otelSpan := kl.tracer.Start(ctx, <span class="hljs-string">&quot;syncPod&quot;</span>, trace.WithAttributes(<br>attribute.String(<span class="hljs-string">&quot;k8s.pod.uid&quot;</span>, <span class="hljs-type">string</span>(pod.UID)),<br>attribute.String(<span class="hljs-string">&quot;k8s.pod&quot;</span>, klog.KObj(pod).String()),<br>attribute.String(<span class="hljs-string">&quot;k8s.pod.name&quot;</span>, pod.Name),<br>attribute.String(<span class="hljs-string">&quot;k8s.pod.update_type&quot;</span>, updateType.String()),<br>attribute.String(<span class="hljs-string">&quot;k8s.namespace.name&quot;</span>, pod.Namespace),<br>))<br>klog.V(<span class="hljs-number">4</span>).InfoS(<span class="hljs-string">&quot;SyncPod enter&quot;</span>, <span class="hljs-string">&quot;pod&quot;</span>, klog.KObj(pod), <span class="hljs-string">&quot;podUID&quot;</span>, pod.UID)<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>klog.V(<span class="hljs-number">4</span>).InfoS(<span class="hljs-string">&quot;SyncPod exit&quot;</span>, <span class="hljs-string">&quot;pod&quot;</span>, klog.KObj(pod), <span class="hljs-string">&quot;podUID&quot;</span>, pod.UID, <span class="hljs-string">&quot;isTerminal&quot;</span>, isTerminal)<br>otelSpan.End()<br>&#125;()<br><br><span class="hljs-comment">// Latency measurements for the main workflow are relative to the</span><br><span class="hljs-comment">// first time the pod was seen by kubelet.</span><br><span class="hljs-keyword">var</span> firstSeenTime time.Time<br><span class="hljs-keyword">if</span> firstSeenTimeStr, ok := pod.Annotations[kubetypes.ConfigFirstSeenAnnotationKey]; ok &#123;<br>firstSeenTime = kubetypes.ConvertToTimestamp(firstSeenTimeStr).Get()<br>&#125;<br><br><span class="hljs-comment">// Record pod worker start latency if being created</span><br><span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> make pod workers record their own latencies</span><br><span class="hljs-keyword">if</span> updateType == kubetypes.SyncPodCreate &#123;<br><span class="hljs-keyword">if</span> !firstSeenTime.IsZero() &#123;<br><span class="hljs-comment">// This is the first time we are syncing the pod. Record the latency</span><br><span class="hljs-comment">// since kubelet first saw the pod if firstSeenTime is set.</span><br>metrics.PodWorkerStartDuration.Observe(metrics.SinceInSeconds(firstSeenTime))<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>klog.V(<span class="hljs-number">3</span>).InfoS(<span class="hljs-string">&quot;First seen time not recorded for pod&quot;</span>,<br><span class="hljs-string">&quot;podUID&quot;</span>, pod.UID,<br><span class="hljs-string">&quot;pod&quot;</span>, klog.KObj(pod))<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// Generate final API pod status with pod and status manager status</span><br>apiPodStatus := kl.generateAPIPodStatus(pod, podStatus, <span class="hljs-literal">false</span>)<br><span class="hljs-comment">// The pod IP may be changed in generateAPIPodStatus if the pod is using host network. (See #24576)</span><br><span class="hljs-comment">// TODO(random-liu): After writing pod spec into container labels, check whether pod is using host network, and</span><br><span class="hljs-comment">// set pod IP to hostIP directly in runtime.GetPodStatus</span><br>podStatus.IPs = <span class="hljs-built_in">make</span>([]<span class="hljs-type">string</span>, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(apiPodStatus.PodIPs))<br><span class="hljs-keyword">for</span> _, ipInfo := <span class="hljs-keyword">range</span> apiPodStatus.PodIPs &#123;<br>podStatus.IPs = <span class="hljs-built_in">append</span>(podStatus.IPs, ipInfo.IP)<br>&#125;<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(podStatus.IPs) == <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-built_in">len</span>(apiPodStatus.PodIP) &gt; <span class="hljs-number">0</span> &#123;<br>podStatus.IPs = []<span class="hljs-type">string</span>&#123;apiPodStatus.PodIP&#125;<br>&#125;<br><br><span class="hljs-comment">// If the pod is terminal, we don&#x27;t need to continue to setup the pod</span><br><span class="hljs-keyword">if</span> apiPodStatus.Phase == v1.PodSucceeded || apiPodStatus.Phase == v1.PodFailed &#123;<br>kl.statusManager.SetPodStatus(pod, apiPodStatus)<br>isTerminal = <span class="hljs-literal">true</span><br><span class="hljs-keyword">return</span> isTerminal, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// If the pod should not be running, we request the pod&#x27;s containers be stopped. This is not the same</span><br><span class="hljs-comment">// as termination (we want to stop the pod, but potentially restart it later if soft admission allows</span><br><span class="hljs-comment">// it later). Set the status and phase appropriately</span><br>runnable := kl.canRunPod(pod)<br><span class="hljs-keyword">if</span> !runnable.Admit &#123;<br><span class="hljs-comment">// Pod is not runnable; and update the Pod and Container statuses to why.</span><br><span class="hljs-keyword">if</span> apiPodStatus.Phase != v1.PodFailed &amp;&amp; apiPodStatus.Phase != v1.PodSucceeded &#123;<br>apiPodStatus.Phase = v1.PodPending<br>&#125;<br>apiPodStatus.Reason = runnable.Reason<br>apiPodStatus.Message = runnable.Message<br><span class="hljs-comment">// Waiting containers are not creating.</span><br><span class="hljs-keyword">const</span> waitingReason = <span class="hljs-string">&quot;Blocked&quot;</span><br><span class="hljs-keyword">for</span> _, cs := <span class="hljs-keyword">range</span> apiPodStatus.InitContainerStatuses &#123;<br><span class="hljs-keyword">if</span> cs.State.Waiting != <span class="hljs-literal">nil</span> &#123;<br>cs.State.Waiting.Reason = waitingReason<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span> _, cs := <span class="hljs-keyword">range</span> apiPodStatus.ContainerStatuses &#123;<br><span class="hljs-keyword">if</span> cs.State.Waiting != <span class="hljs-literal">nil</span> &#123;<br>cs.State.Waiting.Reason = waitingReason<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// Record the time it takes for the pod to become running</span><br><span class="hljs-comment">// since kubelet first saw the pod if firstSeenTime is set.</span><br>existingStatus, ok := kl.statusManager.GetPodStatus(pod.UID)<br><span class="hljs-keyword">if</span> !ok || existingStatus.Phase == v1.PodPending &amp;&amp; apiPodStatus.Phase == v1.PodRunning &amp;&amp;<br>!firstSeenTime.IsZero() &#123;<br>metrics.PodStartDuration.Observe(metrics.SinceInSeconds(firstSeenTime))<br>&#125;<br><br>kl.statusManager.SetPodStatus(pod, apiPodStatus)<br><br><span class="hljs-comment">// Pods that are not runnable must be stopped - return a typed error to the pod worker</span><br><span class="hljs-keyword">if</span> !runnable.Admit &#123;<br>klog.V(<span class="hljs-number">2</span>).InfoS(<span class="hljs-string">&quot;Pod is not runnable and must have running containers stopped&quot;</span>, <span class="hljs-string">&quot;pod&quot;</span>, klog.KObj(pod), <span class="hljs-string">&quot;podUID&quot;</span>, pod.UID, <span class="hljs-string">&quot;message&quot;</span>, runnable.Message)<br><span class="hljs-keyword">var</span> syncErr <span class="hljs-type">error</span><br>p := kubecontainer.ConvertPodStatusToRunningPod(kl.getRuntime().Type(), podStatus)<br><span class="hljs-keyword">if</span> err := kl.killPod(ctx, pod, p, <span class="hljs-literal">nil</span>); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">if</span> !wait.Interrupted(err) &#123;<br>kl.recorder.Eventf(pod, v1.EventTypeWarning, events.FailedToKillPod, <span class="hljs-string">&quot;error killing pod: %v&quot;</span>, err)<br>syncErr = fmt.Errorf(<span class="hljs-string">&quot;error killing pod: %w&quot;</span>, err)<br>utilruntime.HandleError(syncErr)<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// There was no error killing the pod, but the pod cannot be run.</span><br><span class="hljs-comment">// Return an error to signal that the sync loop should back off.</span><br>syncErr = fmt.Errorf(<span class="hljs-string">&quot;pod cannot be run: %v&quot;</span>, runnable.Message)<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>, syncErr<br>&#125;<br><br><span class="hljs-comment">// If the network plugin is not ready, only start the pod if it uses the host network</span><br><span class="hljs-keyword">if</span> err := kl.runtimeState.networkErrors(); err != <span class="hljs-literal">nil</span> &amp;&amp; !kubecontainer.IsHostNetworkPod(pod) &#123;<br>kl.recorder.Eventf(pod, v1.EventTypeWarning, events.NetworkNotReady, <span class="hljs-string">&quot;%s: %v&quot;</span>, NetworkNotReadyErrorMsg, err)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>, fmt.Errorf(<span class="hljs-string">&quot;%s: %v&quot;</span>, NetworkNotReadyErrorMsg, err)<br>&#125;<br><br><span class="hljs-comment">// ensure the kubelet knows about referenced secrets or configmaps used by the pod</span><br><span class="hljs-keyword">if</span> !kl.podWorkers.IsPodTerminationRequested(pod.UID) &#123;<br><span class="hljs-keyword">if</span> kl.secretManager != <span class="hljs-literal">nil</span> &#123;<br>kl.secretManager.RegisterPod(pod)<br>&#125;<br><span class="hljs-keyword">if</span> kl.configMapManager != <span class="hljs-literal">nil</span> &#123;<br>kl.configMapManager.RegisterPod(pod)<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// Create Cgroups for the pod and apply resource parameters</span><br><span class="hljs-comment">// to them if cgroups-per-qos flag is enabled.</span><br>pcm := kl.containerManager.NewPodContainerManager()<br><span class="hljs-comment">// If pod has already been terminated then we need not create</span><br><span class="hljs-comment">// or update the pod&#x27;s cgroup</span><br><span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> once context cancellation is added this check can be removed</span><br><span class="hljs-keyword">if</span> !kl.podWorkers.IsPodTerminationRequested(pod.UID) &#123;<br><span class="hljs-comment">// When the kubelet is restarted with the cgroups-per-qos</span><br><span class="hljs-comment">// flag enabled, all the pod&#x27;s running containers</span><br><span class="hljs-comment">// should be killed intermittently and brought back up</span><br><span class="hljs-comment">// under the qos cgroup hierarchy.</span><br><span class="hljs-comment">// Check if this is the pod&#x27;s first sync</span><br>firstSync := <span class="hljs-literal">true</span><br><span class="hljs-keyword">for</span> _, containerStatus := <span class="hljs-keyword">range</span> apiPodStatus.ContainerStatuses &#123;<br><span class="hljs-keyword">if</span> containerStatus.State.Running != <span class="hljs-literal">nil</span> &#123;<br>firstSync = <span class="hljs-literal">false</span><br><span class="hljs-keyword">break</span><br>&#125;<br>&#125;<br><span class="hljs-comment">// Don&#x27;t kill containers in pod if pod&#x27;s cgroups already</span><br><span class="hljs-comment">// exists or the pod is running for the first time</span><br>podKilled := <span class="hljs-literal">false</span><br><span class="hljs-keyword">if</span> !pcm.Exists(pod) &amp;&amp; !firstSync &#123;<br>p := kubecontainer.ConvertPodStatusToRunningPod(kl.getRuntime().Type(), podStatus)<br><span class="hljs-keyword">if</span> err := kl.killPod(ctx, pod, p, <span class="hljs-literal">nil</span>); err == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">if</span> wait.Interrupted(err) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>, err<br>&#125;<br>podKilled = <span class="hljs-literal">true</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>klog.ErrorS(err, <span class="hljs-string">&quot;KillPod failed&quot;</span>, <span class="hljs-string">&quot;pod&quot;</span>, klog.KObj(pod), <span class="hljs-string">&quot;podStatus&quot;</span>, podStatus)<br>&#125;<br>&#125;<br><span class="hljs-comment">// Create and Update pod&#x27;s Cgroups</span><br><span class="hljs-comment">// Don&#x27;t create cgroups for run once pod if it was killed above</span><br><span class="hljs-comment">// The current policy is not to restart the run once pods when</span><br><span class="hljs-comment">// the kubelet is restarted with the new flag as run once pods are</span><br><span class="hljs-comment">// expected to run only once and if the kubelet is restarted then</span><br><span class="hljs-comment">// they are not expected to run again.</span><br><span class="hljs-comment">// We don&#x27;t create and apply updates to cgroup if its a run once pod and was killed above</span><br><span class="hljs-keyword">if</span> !(podKilled &amp;&amp; pod.Spec.RestartPolicy == v1.RestartPolicyNever) &#123;<br><span class="hljs-keyword">if</span> !pcm.Exists(pod) &#123;<br><span class="hljs-keyword">if</span> err := kl.containerManager.UpdateQOSCgroups(); err != <span class="hljs-literal">nil</span> &#123;<br>klog.V(<span class="hljs-number">2</span>).InfoS(<span class="hljs-string">&quot;Failed to update QoS cgroups while syncing pod&quot;</span>, <span class="hljs-string">&quot;pod&quot;</span>, klog.KObj(pod), <span class="hljs-string">&quot;err&quot;</span>, err)<br>&#125;<br><span class="hljs-keyword">if</span> err := pcm.EnsureExists(pod); err != <span class="hljs-literal">nil</span> &#123;<br>kl.recorder.Eventf(pod, v1.EventTypeWarning, events.FailedToCreatePodContainer, <span class="hljs-string">&quot;unable to ensure pod container exists: %v&quot;</span>, err)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>, fmt.Errorf(<span class="hljs-string">&quot;failed to ensure that the pod: %v cgroups exist and are correctly applied: %v&quot;</span>, pod.UID, err)<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// Create Mirror Pod for Static Pod if it doesn&#x27;t already exist</span><br><span class="hljs-keyword">if</span> kubetypes.IsStaticPod(pod) &#123;<br>deleted := <span class="hljs-literal">false</span><br><span class="hljs-keyword">if</span> mirrorPod != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">if</span> mirrorPod.DeletionTimestamp != <span class="hljs-literal">nil</span> || !kubepod.IsMirrorPodOf(mirrorPod, pod) &#123;<br><span class="hljs-comment">// The mirror pod is semantically different from the static pod. Remove</span><br><span class="hljs-comment">// it. The mirror pod will get recreated later.</span><br>klog.InfoS(<span class="hljs-string">&quot;Trying to delete pod&quot;</span>, <span class="hljs-string">&quot;pod&quot;</span>, klog.KObj(pod), <span class="hljs-string">&quot;podUID&quot;</span>, mirrorPod.ObjectMeta.UID)<br>podFullName := kubecontainer.GetPodFullName(pod)<br><span class="hljs-keyword">var</span> err <span class="hljs-type">error</span><br>deleted, err = kl.mirrorPodClient.DeleteMirrorPod(podFullName, &amp;mirrorPod.ObjectMeta.UID)<br><span class="hljs-keyword">if</span> deleted &#123;<br>klog.InfoS(<span class="hljs-string">&quot;Deleted mirror pod because it is outdated&quot;</span>, <span class="hljs-string">&quot;pod&quot;</span>, klog.KObj(mirrorPod))<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>klog.ErrorS(err, <span class="hljs-string">&quot;Failed deleting mirror pod&quot;</span>, <span class="hljs-string">&quot;pod&quot;</span>, klog.KObj(mirrorPod))<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> mirrorPod == <span class="hljs-literal">nil</span> || deleted &#123;<br>node, err := kl.GetNode()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> || node.DeletionTimestamp != <span class="hljs-literal">nil</span> &#123;<br>klog.V(<span class="hljs-number">4</span>).InfoS(<span class="hljs-string">&quot;No need to create a mirror pod, since node has been removed from the cluster&quot;</span>, <span class="hljs-string">&quot;node&quot;</span>, klog.KRef(<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-type">string</span>(kl.nodeName)))<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>klog.V(<span class="hljs-number">4</span>).InfoS(<span class="hljs-string">&quot;Creating a mirror pod for static pod&quot;</span>, <span class="hljs-string">&quot;pod&quot;</span>, klog.KObj(pod))<br><span class="hljs-keyword">if</span> err := kl.mirrorPodClient.CreateMirrorPod(pod); err != <span class="hljs-literal">nil</span> &#123;<br>klog.ErrorS(err, <span class="hljs-string">&quot;Failed creating a mirror pod for&quot;</span>, <span class="hljs-string">&quot;pod&quot;</span>, klog.KObj(pod))<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// Make data directories for the pod</span><br><span class="hljs-keyword">if</span> err := kl.makePodDataDirs(pod); err != <span class="hljs-literal">nil</span> &#123;<br>kl.recorder.Eventf(pod, v1.EventTypeWarning, events.FailedToMakePodDataDirectories, <span class="hljs-string">&quot;error making pod data directories: %v&quot;</span>, err)<br>klog.ErrorS(err, <span class="hljs-string">&quot;Unable to make pod data directories for pod&quot;</span>, <span class="hljs-string">&quot;pod&quot;</span>, klog.KObj(pod))<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>, err<br>&#125;<br><br><span class="hljs-comment">// Wait for volumes to attach/mount</span><br><span class="hljs-keyword">if</span> err := kl.volumeManager.WaitForAttachAndMount(ctx, pod); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">if</span> !wait.Interrupted(err) &#123;<br>kl.recorder.Eventf(pod, v1.EventTypeWarning, events.FailedMountVolume, <span class="hljs-string">&quot;Unable to attach or mount volumes: %v&quot;</span>, err)<br>klog.ErrorS(err, <span class="hljs-string">&quot;Unable to attach or mount volumes for pod; skipping pod&quot;</span>, <span class="hljs-string">&quot;pod&quot;</span>, klog.KObj(pod))<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>, err<br>&#125;<br><br><span class="hljs-comment">// Fetch the pull secrets for the pod</span><br>pullSecrets := kl.getPullSecretsForPod(pod)<br><br><span class="hljs-comment">// Ensure the pod is being probed</span><br>kl.probeManager.AddPod(pod)<br><br><span class="hljs-keyword">if</span> utilfeature.DefaultFeatureGate.Enabled(features.InPlacePodVerticalScaling) &#123;<br><span class="hljs-comment">// Handle pod resize here instead of doing it in HandlePodUpdates because</span><br><span class="hljs-comment">// this conveniently retries any Deferred resize requests</span><br><span class="hljs-comment">// TODO(vinaykul,InPlacePodVerticalScaling): Investigate doing this in HandlePodUpdates + periodic SyncLoop scan</span><br><span class="hljs-comment">//     See: https://github.com/kubernetes/kubernetes/pull/102884#discussion_r663160060</span><br><span class="hljs-keyword">if</span> kl.podWorkers.CouldHaveRunningContainers(pod.UID) &amp;&amp; !kubetypes.IsStaticPod(pod) &#123;<br>pod = kl.handlePodResourcesResize(pod)<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// TODO(#113606): connect this with the incoming context parameter, which comes from the pod worker.</span><br><span class="hljs-comment">// Currently, using that context causes test failures. To remove this todoCtx, any wait.Interrupted</span><br><span class="hljs-comment">// errors need to be filtered from result and bypass the reasonCache - cancelling the context for</span><br><span class="hljs-comment">// SyncPod is a known and deliberate error, not a generic error.</span><br>todoCtx := context.TODO()<br><span class="hljs-comment">// Call the container runtime&#x27;s SyncPod callback</span><br>result := kl.containerRuntime.SyncPod(todoCtx, pod, podStatus, pullSecrets, kl.backOff)<br>kl.reasonCache.Update(pod.UID, result)<br><span class="hljs-keyword">if</span> err := result.Error(); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-comment">// Do not return error if the only failures were pods in backoff</span><br><span class="hljs-keyword">for</span> _, r := <span class="hljs-keyword">range</span> result.SyncResults &#123;<br><span class="hljs-keyword">if</span> r.Error != kubecontainer.ErrCrashLoopBackOff &amp;&amp; r.Error != images.ErrImagePullBackOff &#123;<br><span class="hljs-comment">// Do not record an event here, as we keep all event logging for sync pod failures</span><br><span class="hljs-comment">// local to container runtime, so we get better errors.</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>, err<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-keyword">if</span> utilfeature.DefaultFeatureGate.Enabled(features.InPlacePodVerticalScaling) &amp;&amp; isPodResizeInProgress(pod, &amp;apiPodStatus) &#123;<br><span class="hljs-comment">// While resize is in progress, periodically call PLEG to update pod cache</span><br>runningPod := kubecontainer.ConvertPodStatusToRunningPod(kl.getRuntime().Type(), podStatus)<br><span class="hljs-keyword">if</span> err, _ := kl.pleg.UpdateCache(&amp;runningPod, pod.UID); err != <span class="hljs-literal">nil</span> &#123;<br>klog.ErrorS(err, <span class="hljs-string">&quot;Failed to update pod cache&quot;</span>, <span class="hljs-string">&quot;pod&quot;</span>, klog.KObj(pod))<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>, err<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>, <span class="hljs-literal">nil</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>&#x2F;&#x2F;   - If the pod is being created, record pod worker start latency<br>&#x2F;&#x2F;   - Call generateAPIPodStatus to prepare an v1.PodStatus for the pod<br>&#x2F;&#x2F;   - If the pod is being seen as running for the first time, record pod<br>&#x2F;&#x2F;     start latency<br>&#x2F;&#x2F;   - Update the status of the pod in the status manager<br>&#x2F;&#x2F;   - Stop the pod’s containers if it should not be running due to soft<br>&#x2F;&#x2F;     admission<br>&#x2F;&#x2F;   - Ensure any background tracking for a runnable pod is started<br>&#x2F;&#x2F;   - Create a mirror pod if the pod is a static pod, and does not<br>&#x2F;&#x2F;     already have a mirror pod<br>&#x2F;&#x2F;   - Create the data directories for the pod if they do not exist<br>&#x2F;&#x2F;   - Wait for volumes to attach&#x2F;mount<br>&#x2F;&#x2F;   - Fetch the pull secrets for the pod<br>&#x2F;&#x2F;   - Call the container runtime’s SyncPod callback<br>&#x2F;&#x2F;   - Update the traffic shaping for the pod’s ingress and egress limits<br>&#x2F;&#x2F;</p><ol><li>调用<code>generateAPIPodStatus</code>为Pod生成一个<code>v1.PodStatus</code>结构体，并把信息更新到缓存中。</li><li>调用<code>kl.canRunPod(pod)</code>对 pod 进行软准入校验，检查扩展资源、节点是否处于正在关闭、security context 白名单、驱逐、拓扑等信息，如果检查不通过则终止掉 pod 。</li><li>创建和更新Pod的<code>Cgroups</code></li><li>判断是否是Static Pod，且 mirror pod 不存在，则创建 mirror pod 。</li><li>如果 pod 的相关数据目录不存在，则为 pod 创建相关数据目录。</li><li>等待 volumes 挂载&#x2F;卸载，拉取 secrets 或 configmap ，获取镜像拉取<code>pullSecrets</code>。</li><li>调用容器运行时的 <code>kl.containerRuntime.SyncPod()</code> 接口创建容器。</li></ol><h2 id="p-podSyncer-SyncTerminatedPod"><a href="#p-podSyncer-SyncTerminatedPod" class="headerlink" title="p.podSyncer.SyncTerminatedPod()"></a>p.podSyncer.SyncTerminatedPod()</h2><p><code>SyncTerminatedPod</code>负责清除已经处于terminated 状态的pod的相关资源，其代码实现如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(kl *Kubelet)</span></span> SyncTerminatedPod(ctx context.Context, pod *v1.Pod, podStatus *kubecontainer.PodStatus) <span class="hljs-type">error</span> &#123;<br>ctx, otelSpan := kl.tracer.Start(ctx, <span class="hljs-string">&quot;syncTerminatedPod&quot;</span>, trace.WithAttributes(<br>attribute.String(<span class="hljs-string">&quot;k8s.pod.uid&quot;</span>, <span class="hljs-type">string</span>(pod.UID)),<br>attribute.String(<span class="hljs-string">&quot;k8s.pod&quot;</span>, klog.KObj(pod).String()),<br>attribute.String(<span class="hljs-string">&quot;k8s.pod.name&quot;</span>, pod.Name),<br>attribute.String(<span class="hljs-string">&quot;k8s.namespace.name&quot;</span>, pod.Namespace),<br>))<br><span class="hljs-keyword">defer</span> otelSpan.End()<br>klog.V(<span class="hljs-number">4</span>).InfoS(<span class="hljs-string">&quot;SyncTerminatedPod enter&quot;</span>, <span class="hljs-string">&quot;pod&quot;</span>, klog.KObj(pod), <span class="hljs-string">&quot;podUID&quot;</span>, pod.UID)<br><span class="hljs-keyword">defer</span> klog.V(<span class="hljs-number">4</span>).InfoS(<span class="hljs-string">&quot;SyncTerminatedPod exit&quot;</span>, <span class="hljs-string">&quot;pod&quot;</span>, klog.KObj(pod), <span class="hljs-string">&quot;podUID&quot;</span>, pod.UID)<br><br><span class="hljs-comment">// generate the final status of the pod</span><br><span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> should we simply fold this into TerminatePod? that would give a single pod update</span><br>apiPodStatus := kl.generateAPIPodStatus(pod, podStatus, <span class="hljs-literal">true</span>)<br><br>kl.statusManager.SetPodStatus(pod, apiPodStatus)<br><br><span class="hljs-comment">// volumes are unmounted after the pod worker reports ShouldPodRuntimeBeRemoved (which is satisfied</span><br><span class="hljs-comment">// before syncTerminatedPod is invoked)</span><br><span class="hljs-keyword">if</span> err := kl.volumeManager.WaitForUnmount(ctx, pod); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br>klog.V(<span class="hljs-number">4</span>).InfoS(<span class="hljs-string">&quot;Pod termination unmounted volumes&quot;</span>, <span class="hljs-string">&quot;pod&quot;</span>, klog.KObj(pod), <span class="hljs-string">&quot;podUID&quot;</span>, pod.UID)<br><br><span class="hljs-keyword">if</span> !kl.keepTerminatedPodVolumes &#123;<br><span class="hljs-comment">// This waiting loop relies on the background cleanup which starts after pod workers respond</span><br><span class="hljs-comment">// true for ShouldPodRuntimeBeRemoved, which happens after `SyncTerminatingPod` is completed.</span><br><span class="hljs-keyword">if</span> err := wait.PollUntilContextCancel(ctx, <span class="hljs-number">100</span>*time.Millisecond, <span class="hljs-literal">true</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ctx context.Context)</span></span> (<span class="hljs-type">bool</span>, <span class="hljs-type">error</span>) &#123;<br>volumesExist := kl.podVolumesExist(pod.UID)<br><span class="hljs-keyword">if</span> volumesExist &#123;<br>klog.V(<span class="hljs-number">3</span>).InfoS(<span class="hljs-string">&quot;Pod is terminated, but some volumes have not been cleaned up&quot;</span>, <span class="hljs-string">&quot;pod&quot;</span>, klog.KObj(pod), <span class="hljs-string">&quot;podUID&quot;</span>, pod.UID)<br>&#125;<br><span class="hljs-keyword">return</span> !volumesExist, <span class="hljs-literal">nil</span><br>&#125;); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br>klog.V(<span class="hljs-number">3</span>).InfoS(<span class="hljs-string">&quot;Pod termination cleaned up volume paths&quot;</span>, <span class="hljs-string">&quot;pod&quot;</span>, klog.KObj(pod), <span class="hljs-string">&quot;podUID&quot;</span>, pod.UID)<br>&#125;<br><br><span class="hljs-comment">// After volume unmount is complete, let the secret and configmap managers know we&#x27;re done with this pod</span><br><span class="hljs-keyword">if</span> kl.secretManager != <span class="hljs-literal">nil</span> &#123;<br>kl.secretManager.UnregisterPod(pod)<br>&#125;<br><span class="hljs-keyword">if</span> kl.configMapManager != <span class="hljs-literal">nil</span> &#123;<br>kl.configMapManager.UnregisterPod(pod)<br>&#125;<br><br><span class="hljs-comment">// Note: we leave pod containers to be reclaimed in the background since dockershim requires the</span><br><span class="hljs-comment">// container for retrieving logs and we want to make sure logs are available until the pod is</span><br><span class="hljs-comment">// physically deleted.</span><br><br><span class="hljs-comment">// remove any cgroups in the hierarchy for pods that are no longer running.</span><br><span class="hljs-keyword">if</span> kl.cgroupsPerQOS &#123;<br>pcm := kl.containerManager.NewPodContainerManager()<br>name, _ := pcm.GetPodContainerName(pod)<br><span class="hljs-keyword">if</span> err := pcm.Destroy(name); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br>klog.V(<span class="hljs-number">4</span>).InfoS(<span class="hljs-string">&quot;Pod termination removed cgroups&quot;</span>, <span class="hljs-string">&quot;pod&quot;</span>, klog.KObj(pod), <span class="hljs-string">&quot;podUID&quot;</span>, pod.UID)<br>&#125;<br><br>kl.usernsManager.Release(pod.UID)<br><br><span class="hljs-comment">// mark the final pod status</span><br>kl.statusManager.TerminatePod(pod)<br>klog.V(<span class="hljs-number">4</span>).InfoS(<span class="hljs-string">&quot;Pod is terminated and will need no more status updates&quot;</span>, <span class="hljs-string">&quot;pod&quot;</span>, klog.KObj(pod), <span class="hljs-string">&quot;podUID&quot;</span>, pod.UID)<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><ol><li>卸载存储卷。</li><li>注销 secrets 和 configmap 。</li><li>移除 cgroup 资源限制，回收资源。</li><li>移除分配的user namespace</li><li>标注 pod 的最终状态。</li></ol><h3 id="p-podSyncer-SyncTerminatingPod"><a href="#p-podSyncer-SyncTerminatingPod" class="headerlink" title="p.podSyncer.SyncTerminatingPod"></a>p.podSyncer.SyncTerminatingPod</h3><p><code>SyncTerminatingPod</code>负责停止Pod内所有运行的容器，容器停止后，Pod的状态被置为<code>Terminated</code>，之后可以进行其余资源的清理。其代码实现为：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(kl *Kubelet)</span></span> SyncTerminatingPod(_ context.Context, pod *v1.Pod, podStatus *kubecontainer.PodStatus, gracePeriod *<span class="hljs-type">int64</span>, podStatusFn <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(*v1.PodStatus)</span></span>) <span class="hljs-type">error</span> &#123;<br><span class="hljs-comment">// TODO(#113606): connect this with the incoming context parameter, which comes from the pod worker.</span><br><span class="hljs-comment">// Currently, using that context causes test failures.</span><br>ctx, otelSpan := kl.tracer.Start(context.Background(), <span class="hljs-string">&quot;syncTerminatingPod&quot;</span>, trace.WithAttributes(<br>attribute.String(<span class="hljs-string">&quot;k8s.pod.uid&quot;</span>, <span class="hljs-type">string</span>(pod.UID)),<br>attribute.String(<span class="hljs-string">&quot;k8s.pod&quot;</span>, klog.KObj(pod).String()),<br>attribute.String(<span class="hljs-string">&quot;k8s.pod.name&quot;</span>, pod.Name),<br>attribute.String(<span class="hljs-string">&quot;k8s.namespace.name&quot;</span>, pod.Namespace),<br>))<br><span class="hljs-keyword">defer</span> otelSpan.End()<br>klog.V(<span class="hljs-number">4</span>).InfoS(<span class="hljs-string">&quot;SyncTerminatingPod enter&quot;</span>, <span class="hljs-string">&quot;pod&quot;</span>, klog.KObj(pod), <span class="hljs-string">&quot;podUID&quot;</span>, pod.UID)<br><span class="hljs-keyword">defer</span> klog.V(<span class="hljs-number">4</span>).InfoS(<span class="hljs-string">&quot;SyncTerminatingPod exit&quot;</span>, <span class="hljs-string">&quot;pod&quot;</span>, klog.KObj(pod), <span class="hljs-string">&quot;podUID&quot;</span>, pod.UID)<br><br>apiPodStatus := kl.generateAPIPodStatus(pod, podStatus, <span class="hljs-literal">false</span>)<br><span class="hljs-keyword">if</span> podStatusFn != <span class="hljs-literal">nil</span> &#123;<br>podStatusFn(&amp;apiPodStatus)<br>&#125;<br>kl.statusManager.SetPodStatus(pod, apiPodStatus)<br><br><span class="hljs-keyword">if</span> gracePeriod != <span class="hljs-literal">nil</span> &#123;<br>klog.V(<span class="hljs-number">4</span>).InfoS(<span class="hljs-string">&quot;Pod terminating with grace period&quot;</span>, <span class="hljs-string">&quot;pod&quot;</span>, klog.KObj(pod), <span class="hljs-string">&quot;podUID&quot;</span>, pod.UID, <span class="hljs-string">&quot;gracePeriod&quot;</span>, *gracePeriod)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>klog.V(<span class="hljs-number">4</span>).InfoS(<span class="hljs-string">&quot;Pod terminating with grace period&quot;</span>, <span class="hljs-string">&quot;pod&quot;</span>, klog.KObj(pod), <span class="hljs-string">&quot;podUID&quot;</span>, pod.UID, <span class="hljs-string">&quot;gracePeriod&quot;</span>, <span class="hljs-literal">nil</span>)<br>&#125;<br><br>kl.probeManager.StopLivenessAndStartup(pod)<br><br>p := kubecontainer.ConvertPodStatusToRunningPod(kl.getRuntime().Type(), podStatus)<br><span class="hljs-keyword">if</span> err := kl.killPod(ctx, pod, p, gracePeriod); err != <span class="hljs-literal">nil</span> &#123;<br>kl.recorder.Eventf(pod, v1.EventTypeWarning, events.FailedToKillPod, <span class="hljs-string">&quot;error killing pod: %v&quot;</span>, err)<br><span class="hljs-comment">// there was an error killing the pod, so we return that error directly</span><br>utilruntime.HandleError(err)<br><span class="hljs-keyword">return</span> err<br>&#125;<br><br><span class="hljs-comment">// Once the containers are stopped, we can stop probing for liveness and readiness.</span><br><span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> once a pod is terminal, certain probes (liveness exec) could be stopped immediately after</span><br><span class="hljs-comment">//   the detection of a container shutdown or (for readiness) after the first failure. Tracked as</span><br><span class="hljs-comment">//   https://github.com/kubernetes/kubernetes/issues/107894 although may not be worth optimizing.</span><br>kl.probeManager.RemovePod(pod)<br><br><span class="hljs-comment">// Guard against consistency issues in KillPod implementations by checking that there are no</span><br><span class="hljs-comment">// running containers. This method is invoked infrequently so this is effectively free and can</span><br><span class="hljs-comment">// catch race conditions introduced by callers updating pod status out of order.</span><br><span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> have KillPod return the terminal status of stopped containers and write that into the</span><br><span class="hljs-comment">//  cache immediately</span><br>podStatus, err := kl.containerRuntime.GetPodStatus(ctx, pod.UID, pod.Name, pod.Namespace)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>klog.ErrorS(err, <span class="hljs-string">&quot;Unable to read pod status prior to final pod termination&quot;</span>, <span class="hljs-string">&quot;pod&quot;</span>, klog.KObj(pod), <span class="hljs-string">&quot;podUID&quot;</span>, pod.UID)<br><span class="hljs-keyword">return</span> err<br>&#125;<br><span class="hljs-keyword">var</span> runningContainers []<span class="hljs-type">string</span><br><span class="hljs-keyword">type</span> container <span class="hljs-keyword">struct</span> &#123;<br>Name       <span class="hljs-type">string</span><br>State      <span class="hljs-type">string</span><br>ExitCode   <span class="hljs-type">int</span><br>FinishedAt <span class="hljs-type">string</span><br>&#125;<br><span class="hljs-keyword">var</span> containers []container<br>klogV := klog.V(<span class="hljs-number">4</span>)<br>klogVEnabled := klogV.Enabled()<br><span class="hljs-keyword">for</span> _, s := <span class="hljs-keyword">range</span> podStatus.ContainerStatuses &#123;<br><span class="hljs-keyword">if</span> s.State == kubecontainer.ContainerStateRunning &#123;<br>runningContainers = <span class="hljs-built_in">append</span>(runningContainers, s.ID.String())<br>&#125;<br><span class="hljs-keyword">if</span> klogVEnabled &#123;<br>containers = <span class="hljs-built_in">append</span>(containers, container&#123;Name: s.Name, State: <span class="hljs-type">string</span>(s.State), ExitCode: s.ExitCode, FinishedAt: s.FinishedAt.UTC().Format(time.RFC3339Nano)&#125;)<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> klogVEnabled &#123;<br>sort.Slice(containers, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i, j <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123; <span class="hljs-keyword">return</span> containers[i].Name &lt; containers[j].Name &#125;)<br>klog.V(<span class="hljs-number">4</span>).InfoS(<span class="hljs-string">&quot;Post-termination container state&quot;</span>, <span class="hljs-string">&quot;pod&quot;</span>, klog.KObj(pod), <span class="hljs-string">&quot;podUID&quot;</span>, pod.UID, <span class="hljs-string">&quot;containers&quot;</span>, containers)<br>&#125;<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(runningContainers) &gt; <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;detected running containers after a successful KillPod, CRI violation: %v&quot;</span>, runningContainers)<br>&#125;<br><br><span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> resources must be unprepared AFTER all containers have stopped</span><br><span class="hljs-comment">// and BEFORE the pod status is changed on the API server</span><br><span class="hljs-comment">// to avoid race conditions with the resource deallocation code in kubernetes core.</span><br><span class="hljs-keyword">if</span> utilfeature.DefaultFeatureGate.Enabled(features.DynamicResourceAllocation) &#123;<br><span class="hljs-keyword">if</span> err := kl.UnprepareDynamicResources(pod); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// Compute and update the status in cache once the pods are no longer running.</span><br><span class="hljs-comment">// The computation is done here to ensure the pod status used for it contains</span><br><span class="hljs-comment">// information about the container end states (including exit codes) - when</span><br><span class="hljs-comment">// SyncTerminatedPod is called the containers may already be removed.</span><br>apiPodStatus = kl.generateAPIPodStatus(pod, podStatus, <span class="hljs-literal">true</span>)<br>kl.statusManager.SetPodStatus(pod, apiPodStatus)<br><br><span class="hljs-comment">// we have successfully stopped all containers, the pod is terminating, our status is &quot;done&quot;</span><br>klog.V(<span class="hljs-number">4</span>).InfoS(<span class="hljs-string">&quot;Pod termination stopped all running containers&quot;</span>, <span class="hljs-string">&quot;pod&quot;</span>, klog.KObj(pod), <span class="hljs-string">&quot;podUID&quot;</span>, pod.UID)<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><ol><li>调用 <code>kl.killPod()</code> 容器运行时终止该 pod 上的所有容器，该接口会在容器完全终止前阻塞住。</li><li>停止 <code>liveness</code> 和 <code>startup</code> 探针。</li><li>更新 pod 状态到缓存中，检查是否所有容器都已经终止。</li><li>如果收到错误返回，则会在下一次循环继续。</li></ol><h3 id="p-podSyncer-SyncTerminatingRuntimePod"><a href="#p-podSyncer-SyncTerminatingRuntimePod" class="headerlink" title="p.podSyncer.SyncTerminatingRuntimePod()"></a>p.podSyncer.SyncTerminatingRuntimePod()</h3><p><code>SyncTerminatingRuntimePod</code>负责清理找不到配置的<code>RuntimePod</code>的Pod的容器，其代码实现为：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(kl *Kubelet)</span></span> SyncTerminatingRuntimePod(_ context.Context, runningPod *kubecontainer.Pod) <span class="hljs-type">error</span> &#123;<br><span class="hljs-comment">// TODO(#113606): connect this with the incoming context parameter, which comes from the pod worker.</span><br><span class="hljs-comment">// Currently, using that context causes test failures.</span><br>ctx := context.Background()<br>pod := runningPod.ToAPIPod()<br>klog.V(<span class="hljs-number">4</span>).InfoS(<span class="hljs-string">&quot;SyncTerminatingRuntimePod enter&quot;</span>, <span class="hljs-string">&quot;pod&quot;</span>, klog.KObj(pod), <span class="hljs-string">&quot;podUID&quot;</span>, pod.UID)<br><span class="hljs-keyword">defer</span> klog.V(<span class="hljs-number">4</span>).InfoS(<span class="hljs-string">&quot;SyncTerminatingRuntimePod exit&quot;</span>, <span class="hljs-string">&quot;pod&quot;</span>, klog.KObj(pod), <span class="hljs-string">&quot;podUID&quot;</span>, pod.UID)<br><br><span class="hljs-comment">// we kill the pod directly since we have lost all other information about the pod.</span><br>klog.V(<span class="hljs-number">4</span>).InfoS(<span class="hljs-string">&quot;Orphaned running pod terminating without grace period&quot;</span>, <span class="hljs-string">&quot;pod&quot;</span>, klog.KObj(pod), <span class="hljs-string">&quot;podUID&quot;</span>, pod.UID)<br><span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> this should probably be zero, to bypass any waiting (needs fixes in container runtime)</span><br>gracePeriod := <span class="hljs-type">int64</span>(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">if</span> err := kl.killPod(ctx, pod, *runningPod, &amp;gracePeriod); err != <span class="hljs-literal">nil</span> &#123;<br>kl.recorder.Eventf(pod, v1.EventTypeWarning, events.FailedToKillPod, <span class="hljs-string">&quot;error killing pod: %v&quot;</span>, err)<br><span class="hljs-comment">// there was an error killing the pod, so we return that error directly</span><br>utilruntime.HandleError(err)<br><span class="hljs-keyword">return</span> err<br>&#125;<br>klog.V(<span class="hljs-number">4</span>).InfoS(<span class="hljs-string">&quot;Pod termination stopped all running orphaned containers&quot;</span>, <span class="hljs-string">&quot;pod&quot;</span>, klog.KObj(pod), <span class="hljs-string">&quot;podUID&quot;</span>, pod.UID)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>确保 kubelet 识别到它已经没有任何容器运行了。</p><h3 id="p-completeTerminated-podUID"><a href="#p-completeTerminated-podUID" class="headerlink" title="p.completeTerminated(podUID)"></a>p.completeTerminated(podUID)</h3><p>这一步是终止 podWorker ，关停 PodUpdates channel 通道，并将 pod 从缓存中移除。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *podWorkers)</span></span> completeTerminated(podUID types.UID) &#123;<br>p.podLock.Lock()<br><span class="hljs-keyword">defer</span> p.podLock.Unlock()<br><br>klog.V(<span class="hljs-number">4</span>).InfoS(<span class="hljs-string">&quot;Pod is complete and the worker can now stop&quot;</span>, <span class="hljs-string">&quot;podUID&quot;</span>, podUID)<br><br>p.cleanupPodUpdates(podUID)<br><br>status, ok := p.podSyncStatuses[podUID]<br><span class="hljs-keyword">if</span> !ok &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">if</span> status.terminatingAt.IsZero() &#123;<br>klog.V(<span class="hljs-number">4</span>).InfoS(<span class="hljs-string">&quot;Pod worker is complete but did not have terminatingAt set, likely programmer error&quot;</span>, <span class="hljs-string">&quot;podUID&quot;</span>, podUID)<br>&#125;<br><span class="hljs-keyword">if</span> status.terminatedAt.IsZero() &#123;<br>klog.V(<span class="hljs-number">4</span>).InfoS(<span class="hljs-string">&quot;Pod worker is complete but did not have terminatedAt set, likely programmer error&quot;</span>, <span class="hljs-string">&quot;podUID&quot;</span>, podUID)<br>&#125;<br>status.finished = <span class="hljs-literal">true</span><br>status.working = <span class="hljs-literal">false</span><br><br><span class="hljs-keyword">if</span> p.startedStaticPodsByFullname[status.fullname] == podUID &#123;<br><span class="hljs-built_in">delete</span>(p.startedStaticPodsByFullname, status.fullname)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="p-completeTerminating-podUID"><a href="#p-completeTerminating-podUID" class="headerlink" title="p.completeTerminating(podUID)"></a>p.completeTerminating(podUID)</h3><p>这一意味着 pod 上的容器已经全部终止，且容器不会在后面的同步逻辑中继续启动了，更新 pod 相关状态，准备被后续的清理逻辑接管，并确保不被后面的同步逻辑同步，确保能被 kubelet 始别到它已经没有任何容器运行了</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *podWorkers)</span></span> completeTerminating(podUID types.UID) &#123;<br>p.podLock.Lock()<br><span class="hljs-keyword">defer</span> p.podLock.Unlock()<br><br>klog.V(<span class="hljs-number">4</span>).InfoS(<span class="hljs-string">&quot;Pod terminated all containers successfully&quot;</span>, <span class="hljs-string">&quot;podUID&quot;</span>, podUID)<br><br>status, ok := p.podSyncStatuses[podUID]<br><span class="hljs-keyword">if</span> !ok &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-comment">// update the status of the pod</span><br><span class="hljs-keyword">if</span> status.terminatingAt.IsZero() &#123;<br>klog.V(<span class="hljs-number">4</span>).InfoS(<span class="hljs-string">&quot;Pod worker was terminated but did not have terminatingAt set, likely programmer error&quot;</span>, <span class="hljs-string">&quot;podUID&quot;</span>, podUID)<br>&#125;<br>status.terminatedAt = p.clock.Now()<br><span class="hljs-keyword">for</span> _, ch := <span class="hljs-keyword">range</span> status.notifyPostTerminating &#123;<br><span class="hljs-built_in">close</span>(ch)<br>&#125;<br>status.notifyPostTerminating = <span class="hljs-literal">nil</span><br>status.statusPostTerminating = <span class="hljs-literal">nil</span><br><br><span class="hljs-comment">// the pod has now transitioned to terminated and we want to run syncTerminatedPod</span><br><span class="hljs-comment">// as soon as possible, so if no update is already waiting queue a synthetic update</span><br>p.requeueLastPodUpdate(podUID, status)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="p-completeSync-podUID"><a href="#p-completeSync-podUID" class="headerlink" title="p.completeSync(podUID)"></a>p.completeSync(podUID)</h3><p>这一步是处理在自然的生命周期内，pod 被终止了。类似驱逐、api驱使删除等非自然生命周期的处理，是走 UpdatePod() 这个接口的。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *podWorkers)</span></span> completeSync(podUID types.UID) &#123;<br>p.podLock.Lock()<br><span class="hljs-keyword">defer</span> p.podLock.Unlock()<br><br>klog.V(<span class="hljs-number">4</span>).InfoS(<span class="hljs-string">&quot;Pod indicated lifecycle completed naturally and should now terminate&quot;</span>, <span class="hljs-string">&quot;podUID&quot;</span>, podUID)<br><br>status, ok := p.podSyncStatuses[podUID]<br><span class="hljs-keyword">if</span> !ok &#123;<br>klog.V(<span class="hljs-number">4</span>).InfoS(<span class="hljs-string">&quot;Pod had no status in completeSync, programmer error?&quot;</span>, <span class="hljs-string">&quot;podUID&quot;</span>, podUID)<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-comment">// update the status of the pod</span><br><span class="hljs-keyword">if</span> status.terminatingAt.IsZero() &#123;<br>status.terminatingAt = p.clock.Now()<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>klog.V(<span class="hljs-number">4</span>).InfoS(<span class="hljs-string">&quot;Pod worker attempted to set terminatingAt twice, likely programmer error&quot;</span>, <span class="hljs-string">&quot;podUID&quot;</span>, podUID)<br>&#125;<br>status.startedTerminating = <span class="hljs-literal">true</span><br><br><span class="hljs-comment">// the pod has now transitioned to terminating and we want to run syncTerminatingPod</span><br><span class="hljs-comment">// as soon as possible, so if no update is already waiting queue a synthetic update</span><br>p.requeueLastPodUpdate(podUID, status)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="p-completeWork-podUID-phaseTransition-err"><a href="#p-completeWork-podUID-phaseTransition-err" class="headerlink" title="p.completeWork(podUID, phaseTransition, err)"></a>p.completeWork(podUID, phaseTransition, err)</h3><p>当 pod 同步出现错误时调用该接口，接口逻辑是检查错误类型，根据错误类型将 pod 立即或者按一定时间间隔重新加入到同步队列，直到 pod 完成同步</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *podWorkers)</span></span> completeWork(podUID types.UID, phaseTransition <span class="hljs-type">bool</span>, syncErr <span class="hljs-type">error</span>) &#123;<br><span class="hljs-comment">// Requeue the last update if the last sync returned error.</span><br><span class="hljs-keyword">switch</span> &#123;<br><span class="hljs-keyword">case</span> phaseTransition:<br>p.workQueue.Enqueue(podUID, <span class="hljs-number">0</span>)<br><span class="hljs-keyword">case</span> syncErr == <span class="hljs-literal">nil</span>:<br><span class="hljs-comment">// No error; requeue at the regular resync interval.</span><br>p.workQueue.Enqueue(podUID, wait.Jitter(p.resyncInterval, workerResyncIntervalJitterFactor))<br><span class="hljs-keyword">case</span> strings.Contains(syncErr.Error(), NetworkNotReadyErrorMsg):<br><span class="hljs-comment">// Network is not ready; back off for short period of time and retry as network might be ready soon.</span><br>p.workQueue.Enqueue(podUID, wait.Jitter(backOffOnTransientErrorPeriod, workerBackOffPeriodJitterFactor))<br><span class="hljs-keyword">default</span>:<br><span class="hljs-comment">// Error occurred during the sync; back off and then retry.</span><br>p.workQueue.Enqueue(podUID, wait.Jitter(p.backOffPeriod, workerBackOffPeriodJitterFactor))<br>&#125;<br><br><span class="hljs-comment">// if there is a pending update for this worker, requeue immediately, otherwise</span><br><span class="hljs-comment">// clear working status</span><br>p.podLock.Lock()<br><span class="hljs-keyword">defer</span> p.podLock.Unlock()<br><span class="hljs-keyword">if</span> status, ok := p.podSyncStatuses[podUID]; ok &#123;<br><span class="hljs-keyword">if</span> status.pendingUpdate != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> p.podUpdates[podUID] &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;:<br>klog.V(<span class="hljs-number">4</span>).InfoS(<span class="hljs-string">&quot;Requeueing pod due to pending update&quot;</span>, <span class="hljs-string">&quot;podUID&quot;</span>, podUID)<br><span class="hljs-keyword">default</span>:<br>klog.V(<span class="hljs-number">4</span>).InfoS(<span class="hljs-string">&quot;Pending update already queued&quot;</span>, <span class="hljs-string">&quot;podUID&quot;</span>, podUID)<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>status.working = <span class="hljs-literal">false</span><br>&#125;<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>kubernetes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>kubernetes</tag>
      
      <tag>kubelet</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kubernetes-klog简介</title>
    <link href="/2023/12/19/kubernetes-klog%E7%AE%80%E4%BB%8B/"/>
    <url>/2023/12/19/kubernetes-klog%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p><a href="https://github.com/kubernetes/klog.git">klog</a>是Kubernetes中用于记录日志的日志库。它旨在为Kubernetes生态系统中的不同组件和服务提供一致和统一的日志记录体验。名称“klog”代表“Kubernetes logger”。 </p><h2 id="功能简介"><a href="#功能简介" class="headerlink" title="功能简介"></a>功能简介</h2><ul><li>klog 支持不同的日志级别，包括 <code>INFO</code>、<code>WARNING</code>、<code>ERROR</code> 、<code>FATAL</code>和 <code>VERBOSE</code>。开发人员可以设置日志级别以根据他们的需求控制日志的详细程度。写入到高严重等级日志文件的消息也会被写入到所有严重等级比它低的日志文件中.</li><li>klog提供了由 -v 和 -vmodule&#x3D;file&#x3D;2 标志控制的 V-style 日志。</li><li>klog 支持结构化日志，这意味着日志消息可以包含键值对。这使得使用外部工具过滤和分析日志变得更加容易。</li><li>klog 允许通过命令行标志控制其行为。这些标志可以在启动 Go 应用程序时设置，以配置日志级别 (例如：–v&#x3D;2)、日志格式和其他与日志记录相关的设置。</li></ul><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>以下是在 Go 应用程序中使用 <code>klog</code> 的简单示例：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;k8s.io/klog/v2&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>klog.Info(<span class="hljs-string">&quot;这是一条信息消息&quot;</span>)<br>klog.Warning(<span class="hljs-string">&quot;这是一条警告消息&quot;</span>)<br>klog.Error(<span class="hljs-string">&quot;这是一条错误消息&quot;</span>)<br><span class="hljs-comment">// 可以使用 klog 包的其他功能进行额外的配置和日志记录。</span><br><br>klog.V(<span class="hljs-number">1</span>).Info(<span class="hljs-string">&quot;这是一条Level为1的消息&quot;</span>)<br>klog.V(<span class="hljs-number">2</span>).Info(<span class="hljs-string">&quot;这是一条Level为2的消息&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>通过设置 –v 标志，你可以调整日志的详细程度：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">./your_app --v=2<br></code></pre></td></tr></table></figure><p>例如，当我们想要查看 kubernetes的组件的详细信息时，我们可以通过调整<code>--v</code>标志调整其日志输出级别：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs golang">root@k8s002:pts/<span class="hljs-number">20</span>-&gt;/root (<span class="hljs-number">0</span>)<br>&gt; kubectl get pods -n kube-system<br>NAME                             READY   STATUS    RESTARTS   AGE<br>coredns<span class="hljs-number">-7</span>f89b7bc75<span class="hljs-number">-992</span>fg         <span class="hljs-number">1</span>/<span class="hljs-number">1</span>     Running   <span class="hljs-number">0</span>          <span class="hljs-number">85</span>d<br>coredns<span class="hljs-number">-7</span>f89b7bc75-zq9xn         <span class="hljs-number">1</span>/<span class="hljs-number">1</span>     Running   <span class="hljs-number">0</span>          <span class="hljs-number">85</span>d<br>etcd-k8s002                      <span class="hljs-number">1</span>/<span class="hljs-number">1</span>     Running   <span class="hljs-number">0</span>          <span class="hljs-number">85</span>d<br>kube-apiserver-k8s002            <span class="hljs-number">1</span>/<span class="hljs-number">1</span>     Running   <span class="hljs-number">0</span>          <span class="hljs-number">85</span>d<br>kube-controller-manager-k8s002   <span class="hljs-number">1</span>/<span class="hljs-number">1</span>     Running   <span class="hljs-number">28</span>         <span class="hljs-number">85</span>d<br>kube-proxy-lcwzq                 <span class="hljs-number">1</span>/<span class="hljs-number">1</span>     Running   <span class="hljs-number">0</span>          <span class="hljs-number">85</span>d<br>kube-scheduler-k8s002            <span class="hljs-number">1</span>/<span class="hljs-number">1</span>     Running   <span class="hljs-number">28</span>         <span class="hljs-number">85</span>d<br>-----------------------------------------------<br>root@k8s002:pts/<span class="hljs-number">20</span>-&gt;/root (<span class="hljs-number">0</span>)<br>&gt; kubectl get pods -n kube-system --v=<span class="hljs-number">6</span><br>I1219 <span class="hljs-number">23</span>:<span class="hljs-number">22</span>:<span class="hljs-number">41.474328</span>   <span class="hljs-number">25577</span> loader.<span class="hljs-keyword">go</span>:<span class="hljs-number">379</span>] Config loaded from file:  /root/.kube/config<br>I1219 <span class="hljs-number">23</span>:<span class="hljs-number">22</span>:<span class="hljs-number">41.491635</span>   <span class="hljs-number">25577</span> round_trippers.<span class="hljs-keyword">go</span>:<span class="hljs-number">445</span>] GET https:<span class="hljs-comment">//47.123.6.56:6443/api/v1/namespaces/kube-system/pods?limit=500 200 OK in 11 milliseconds</span><br>NAME                             READY   STATUS    RESTARTS   AGE<br>coredns<span class="hljs-number">-7</span>f89b7bc75<span class="hljs-number">-992</span>fg         <span class="hljs-number">1</span>/<span class="hljs-number">1</span>     Running   <span class="hljs-number">0</span>          <span class="hljs-number">85</span>d<br>coredns<span class="hljs-number">-7</span>f89b7bc75-zq9xn         <span class="hljs-number">1</span>/<span class="hljs-number">1</span>     Running   <span class="hljs-number">0</span>          <span class="hljs-number">85</span>d<br>etcd-k8s002                      <span class="hljs-number">1</span>/<span class="hljs-number">1</span>     Running   <span class="hljs-number">0</span>          <span class="hljs-number">85</span>d<br>kube-apiserver-k8s002            <span class="hljs-number">1</span>/<span class="hljs-number">1</span>     Running   <span class="hljs-number">0</span>          <span class="hljs-number">85</span>d<br>kube-controller-manager-k8s002   <span class="hljs-number">1</span>/<span class="hljs-number">1</span>     Running   <span class="hljs-number">28</span>         <span class="hljs-number">85</span>d<br>kube-proxy-lcwzq                 <span class="hljs-number">1</span>/<span class="hljs-number">1</span>     Running   <span class="hljs-number">0</span>          <span class="hljs-number">85</span>d<br>kube-scheduler-k8s002            <span class="hljs-number">1</span>/<span class="hljs-number">1</span>     Running   <span class="hljs-number">28</span>         <span class="hljs-number">85</span>d<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>kubernetes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>kubernetes</tag>
      
      <tag>klog</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kubernetes-Informer详解</title>
    <link href="/2023/12/11/kubernetes-Informer%E8%AF%A6%E8%A7%A3/"/>
    <url>/2023/12/11/kubernetes-Informer%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h2 id="informer简介"><a href="#informer简介" class="headerlink" title="informer简介"></a>informer简介</h2><p>在Kubernetes编程中,<code>informer</code>是Kubernetes Go client<code>client-go</code>官方library提供的一个高级别的抽象，来监听和处理k8s集群的资源变化。通过使用<code>informer</code>，开发者能有效的监听资源的变化，而无需通过手工<code>轮询</code>的方式。<code>informer</code>使用了<code>API Server</code>提供的函数接口，我们通过 apiserver 增删改某个 Kubernetes API 对象，该资源对应的控制器中的 Informer 会立即感知到这个事件并进行相应的处理</p><p>Informer 由三部分构成：</p><ul><li>Reflector：Informer 通过 Reflector 与 Kubernetes apiserver 建立连接并 ListAndWatch Kubernetes 资源对象的变化，并将此“增量” push 入 DeltaFIFO Queue</li><li>DeltaFIFO Queue：Informer 从该队列中 pop 增量，或创建或更新或删除本地缓存（Local Store）</li><li>Indexer：将增量中的 Kubernetes 资源对象保存到本地缓存中，并为其创建索引，这份缓存与 etcd 中的数据是完全一致的。控制器只从本地缓存通过索引读取数据，这样做减小了 apiserver 和 etcd 的压力。</li></ul><p><img src="https://pic.crazytaxii.com/21-03-31/22701732.jpg"></p><h2 id="Informer使用"><a href="#Informer使用" class="headerlink" title="Informer使用"></a>Informer使用</h2><p>informer的使用分为以下几步：</p><ol><li>引入相关依赖<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;k8s.io/client-go/informers&quot;</span><br><span class="hljs-string">&quot;k8s.io/client-go/kubernetes&quot;</span><br><span class="hljs-string">&quot;k8s.io/client-go/tools/cache&quot;</span><br>)<br></code></pre></td></tr></table></figure></li><li>初始化kubernetes clientset，与API server做交互<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs golang">clientset, err := kubernetes.NewForConfig(config)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err.Error())<br>&#125;<br></code></pre></td></tr></table></figure></li><li>使用初始化好的clientset创建对应资源的informer(e.g., Pods, Deployments, etc.).<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs golang">informerFactory := informers.NewSharedInformerFactory(clientset, time.Second*<span class="hljs-number">30</span>)<br>podInformer := informerFactory.Core().V1().Pods()<br></code></pre></td></tr></table></figure></li><li>添加事件回调<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs golang">podInformer.Informer().AddEventHandler(cache.ResourceEventHandlerFuncs&#123;<br>    AddFunc: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(obj <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br>        <span class="hljs-comment">// Handle added pod</span><br>    &#125;,<br>    UpdateFunc: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(oldObj, newObj <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br>        <span class="hljs-comment">// Handle updated pod</span><br>    &#125;,<br>    DeleteFunc: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(obj <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br>        <span class="hljs-comment">// Handle deleted pod</span><br>    &#125;,<br>&#125;)<br></code></pre></td></tr></table></figure></li></ol><p>5.启动informer并等待缓存同步。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs golang">stopCh := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)<br><span class="hljs-keyword">defer</span> <span class="hljs-built_in">close</span>(stopCh)<br><br>informerFactory.Start(stopCh)<br><span class="hljs-keyword">if</span> !cache.WaitForCacheSync(stopCh, podInformer.Informer().HasSynced) &#123;<br>    <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;Timed out waiting for caches to sync&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="源码实现"><a href="#源码实现" class="headerlink" title="源码实现"></a>源码实现</h2><p>在上面的代码示例种我们创建了一个<code>informerFactory</code>对象并通过调用<code>informerFactory.Start(stopCh)</code>初始化所有请求的informer，其内部的实现为：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f *sharedInformerFactory)</span></span> Start(stopCh &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;) &#123;<br>f.lock.Lock()<br><span class="hljs-keyword">defer</span> f.lock.Unlock()<br><br><span class="hljs-keyword">if</span> f.shuttingDown &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-keyword">for</span> informerType, informer := <span class="hljs-keyword">range</span> f.informers &#123;<br><span class="hljs-keyword">if</span> !f.startedInformers[informerType] &#123;<br>f.wg.Add(<span class="hljs-number">1</span>)<br><span class="hljs-comment">// We need a new variable in each loop iteration,</span><br><span class="hljs-comment">// otherwise the goroutine would use the loop variable</span><br><span class="hljs-comment">// and that keeps changing.</span><br>informer := informer<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> f.wg.Done()<br>informer.Run(stopCh)<br>&#125;()<br>f.startedInformers[informerType] = <span class="hljs-literal">true</span><br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>start调用就是for循环了内部所有informers，如果未启动的话就启动一下。<code>informer.Run(stopCh)</code>的实现为：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs golang"><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *sharedIndexInformer)</span></span> Run(stopCh &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;) &#123;<br><span class="hljs-keyword">defer</span> utilruntime.HandleCrash()<br><br><span class="hljs-keyword">if</span> s.HasStarted() &#123;<br>klog.Warningf(<span class="hljs-string">&quot;The sharedIndexInformer has started, run more than once is not allowed&quot;</span>)<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>s.startedLock.Lock()<br><span class="hljs-keyword">defer</span> s.startedLock.Unlock()<br><br>fifo := NewDeltaFIFOWithOptions(DeltaFIFOOptions&#123;<br>KnownObjects:          s.indexer,<br>EmitDeltaTypeReplaced: <span class="hljs-literal">true</span>,<br>Transformer:           s.transform,<br>&#125;)<br><br>cfg := &amp;Config&#123;<br>Queue:             fifo,<br>ListerWatcher:     s.listerWatcher,<br>ObjectType:        s.objectType,<br>ObjectDescription: s.objectDescription,<br>FullResyncPeriod:  s.resyncCheckPeriod,<br>RetryOnError:      <span class="hljs-literal">false</span>,<br>ShouldResync:      s.processor.shouldResync,<br><br>Process:           s.HandleDeltas,<br>WatchErrorHandler: s.watchErrorHandler,<br>&#125;<br><br>s.controller = New(cfg)<br>s.controller.(*controller).clock = s.clock<br>s.started = <span class="hljs-literal">true</span><br>&#125;()<br><br><span class="hljs-comment">// Separate stop channel because Processor should be stopped strictly after controller</span><br>processorStopCh := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)<br><span class="hljs-keyword">var</span> wg wait.Group<br><span class="hljs-keyword">defer</span> wg.Wait()              <span class="hljs-comment">// Wait for Processor to stop</span><br><span class="hljs-keyword">defer</span> <span class="hljs-built_in">close</span>(processorStopCh) <span class="hljs-comment">// Tell Processor to stop</span><br>wg.StartWithChannel(processorStopCh, s.cacheMutationDetector.Run)<br>wg.StartWithChannel(processorStopCh, s.processor.run)<br><br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>s.startedLock.Lock()<br><span class="hljs-keyword">defer</span> s.startedLock.Unlock()<br>s.stopped = <span class="hljs-literal">true</span> <span class="hljs-comment">// Don&#x27;t want any new listeners</span><br>&#125;()<br>s.controller.Run(stopCh)<br>&#125;<br></code></pre></td></tr></table></figure><p><code>informer.Run(stopCh)</code>做了一些变量的初始化，并且调用<code>s.controller.Run(stopCh)</code>，其内部实现为：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs golang"><br><span class="hljs-comment">// Run begins processing items, and will continue until a value is sent down stopCh or it is closed.</span><br><span class="hljs-comment">// It&#x27;s an error to call Run more than once.</span><br><span class="hljs-comment">// Run blocks; call via go.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *controller)</span></span> Run(stopCh &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;) &#123;<br><span class="hljs-keyword">defer</span> utilruntime.HandleCrash()<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>&lt;-stopCh<br>c.config.Queue.Close()<br>&#125;()<br>r := NewReflectorWithOptions(<br>c.config.ListerWatcher,<br>c.config.ObjectType,<br>c.config.Queue,<br>ReflectorOptions&#123;<br>ResyncPeriod:    c.config.FullResyncPeriod,<br>TypeDescription: c.config.ObjectDescription,<br>Clock:           c.clock,<br>&#125;,<br>)<br>r.ShouldResync = c.config.ShouldResync<br>r.WatchListPageSize = c.config.WatchListPageSize<br><span class="hljs-keyword">if</span> c.config.WatchErrorHandler != <span class="hljs-literal">nil</span> &#123;<br>r.watchErrorHandler = c.config.WatchErrorHandler<br>&#125;<br><br>c.reflectorMutex.Lock()<br>c.reflector = r<br>c.reflectorMutex.Unlock()<br><br><span class="hljs-keyword">var</span> wg wait.Group<br><br>wg.StartWithChannel(stopCh, r.Run)<br><br>wait.Until(c.processLoop, time.Second, stopCh)<br>wg.Wait()<br>&#125;<br></code></pre></td></tr></table></figure><p><code>s.controller.Run(stopCh)</code>里面做了两件事，</p><ol><li><code>wg.StartWithChannel(stopCh, r.Run)</code>:构建并运行了一个Reflector将资源对象&#x2F;事件通知从<code>c.config.ListerWatcher</code> 送到 <code>c.config.Queue</code>里。并进行不定期的<code>Resync</code>操作。</li><li><code>wait.Until(c.processLoop, time.Second, stopCh)</code>:周期性的从<code>c.config.Queue</code>里Pop出对象并且使用<code>Config&#39;s ProcessFunc</code>进行处理。</li></ol><p>我们首先来看下<code>Reflector</code>的<code>r.Run</code>函数实现：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-comment">// Run repeatedly uses the reflector&#x27;s ListAndWatch to fetch all the</span><br><span class="hljs-comment">// objects and subsequent deltas.</span><br><span class="hljs-comment">// Run will exit when stopCh is closed.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *Reflector)</span></span> Run(stopCh &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;) &#123;<br>klog.V(<span class="hljs-number">3</span>).Infof(<span class="hljs-string">&quot;Starting reflector %s (%s) from %s&quot;</span>, r.typeDescription, r.resyncPeriod, r.name)<br>wait.BackoffUntil(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">if</span> err := r.ListAndWatch(stopCh); err != <span class="hljs-literal">nil</span> &#123;<br>r.watchErrorHandler(r, err)<br>&#125;<br>&#125;, r.backoffManager, <span class="hljs-literal">true</span>, stopCh)<br>klog.V(<span class="hljs-number">3</span>).Infof(<span class="hljs-string">&quot;Stopping reflector %s (%s) from %s&quot;</span>, r.typeDescription, r.resyncPeriod, r.name)<br>&#125;<br></code></pre></td></tr></table></figure><p><code>wait.BackoffUntil</code>是一个工具函数，其功能可以认为是周期性的调用回调函数（第一个参数)，如果回调函数调用失败，则等待一段时候再次调用回调函数。回调函数内部又调用了<code>r.ListAndWatch(stopCh)</code>方法：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs golang"><br><span class="hljs-comment">// ListAndWatch first lists all items and get the resource version at the moment of call,</span><br><span class="hljs-comment">// and then use the resource version to watch.</span><br><span class="hljs-comment">// It returns error if ListAndWatch didn&#x27;t even try to initialize watch.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *Reflector)</span></span> ListAndWatch(stopCh &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;) <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">var</span> w watch.Interface<br>.....<br><span class="hljs-keyword">defer</span> <span class="hljs-built_in">close</span>(cancelCh)<br><span class="hljs-keyword">go</span> r.startResync(stopCh, cancelCh, resyncerrc)<br><span class="hljs-keyword">return</span> r.watch(w, stopCh, resyncerrc)<br>&#125;<br><br><span class="hljs-comment">// watch simply starts a watch request with the server.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *Reflector)</span></span> watch(w watch.Interface, stopCh &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;, resyncerrc <span class="hljs-keyword">chan</span> <span class="hljs-type">error</span>) <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">if</span> w == <span class="hljs-literal">nil</span> &#123;<br>            ......<br>w, err = r.listerWatcher.Watch(options)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br>&#125;<br>err = watchHandler(start, w, r.store, r.expectedType, r.expectedGVK, r.name, r.typeDescription, r.setLastSyncResourceVersion, <span class="hljs-literal">nil</span>, r.clock, resyncerrc, stopCh)<br><span class="hljs-comment">// Ensure that watch will not be reused across iterations.</span><br>w.Stop()<br>w = <span class="hljs-literal">nil</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>r.ListAndWatch(stopCh)</code>内部调用<code>r.watch(w, stopCh, resyncerrc)</code>，<code>r.watch(w, stopCh, resyncerrc)</code>首先使用<code>r.listerWatcher</code>初始化实现了<code>watch.Interface</code>接口的w对象，并调用了<code>watchHandler(start, w, r.store, r.expectedType, r.expectedGVK, r.name, r.typeDescription, r.setLastSyncResourceVersion, nil, r.clock, resyncerrc, stopCh</code>对资源对象进行真正的watch.</p><p><code>watch.Interface</code>的接口定义为：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-comment">// Interface can be implemented by anything that knows how to watch and report changes.</span><br><span class="hljs-keyword">type</span> Interface <span class="hljs-keyword">interface</span> &#123;<br><span class="hljs-comment">// Stop stops watching. Will close the channel returned by ResultChan(). Releases</span><br><span class="hljs-comment">// any resources used by the watch.</span><br>Stop()<br><br><span class="hljs-comment">// ResultChan returns a chan which will receive all the events. If an error occurs</span><br><span class="hljs-comment">// or Stop() is called, the implementation will close this channel and</span><br><span class="hljs-comment">// release any resources used by the watch.</span><br>ResultChan() &lt;-<span class="hljs-keyword">chan</span> Event<br>&#125;<br></code></pre></td></tr></table></figure><p>核心的函数为<code>ResultChan</code>可以返回一个<code>chan Event</code>, 被监听的资源的所有事件都可以通过这个chan获取到。</p><p><code>watchHandler</code>的实现为：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><code class="hljs golang"><br><span class="hljs-comment">// watchHandler watches w and sets setLastSyncResourceVersion</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">watchHandler</span><span class="hljs-params">(start time.Time,</span></span><br><span class="hljs-params"><span class="hljs-function">w watch.Interface,</span></span><br><span class="hljs-params"><span class="hljs-function">store Store,</span></span><br><span class="hljs-params"><span class="hljs-function">expectedType reflect.Type,</span></span><br><span class="hljs-params"><span class="hljs-function">expectedGVK *schema.GroupVersionKind,</span></span><br><span class="hljs-params"><span class="hljs-function">name <span class="hljs-type">string</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">expectedTypeName <span class="hljs-type">string</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">setLastSyncResourceVersion <span class="hljs-keyword">func</span>(<span class="hljs-type">string</span>)</span></span>,<br>exitOnInitialEventsEndBookmark *<span class="hljs-type">bool</span>,<br>clock clock.Clock,<br>errc <span class="hljs-keyword">chan</span> <span class="hljs-type">error</span>,<br>stopCh &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;,<br>) <span class="hljs-type">error</span> &#123;<br>eventCount := <span class="hljs-number">0</span><br><span class="hljs-keyword">if</span> exitOnInitialEventsEndBookmark != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-comment">// set it to false just in case somebody</span><br><span class="hljs-comment">// made it positive</span><br>*exitOnInitialEventsEndBookmark = <span class="hljs-literal">false</span><br>&#125;<br><br>loop:<br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-stopCh:<br><span class="hljs-keyword">return</span> errorStopRequested<br><span class="hljs-keyword">case</span> err := &lt;-errc:<br><span class="hljs-keyword">return</span> err<br><span class="hljs-keyword">case</span> event, ok := &lt;-w.ResultChan():<br><span class="hljs-keyword">if</span> !ok &#123;<br><span class="hljs-keyword">break</span> loop<br>&#125;<br><span class="hljs-keyword">if</span> event.Type == watch.Error &#123;<br><span class="hljs-keyword">return</span> apierrors.FromObject(event.Object)<br>&#125;<br><span class="hljs-keyword">if</span> expectedType != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">if</span> e, a := expectedType, reflect.TypeOf(event.Object); e != a &#123;<br>utilruntime.HandleError(fmt.Errorf(<span class="hljs-string">&quot;%s: expected type %v, but watch event object had type %v&quot;</span>, name, e, a))<br><span class="hljs-keyword">continue</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> expectedGVK != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">if</span> e, a := *expectedGVK, event.Object.GetObjectKind().GroupVersionKind(); e != a &#123;<br>utilruntime.HandleError(fmt.Errorf(<span class="hljs-string">&quot;%s: expected gvk %v, but watch event object had gvk %v&quot;</span>, name, e, a))<br><span class="hljs-keyword">continue</span><br>&#125;<br>&#125;<br>meta, err := meta.Accessor(event.Object)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>utilruntime.HandleError(fmt.Errorf(<span class="hljs-string">&quot;%s: unable to understand watch event %#v&quot;</span>, name, event))<br><span class="hljs-keyword">continue</span><br>&#125;<br>resourceVersion := meta.GetResourceVersion()<br><span class="hljs-keyword">switch</span> event.Type &#123;<br><span class="hljs-keyword">case</span> watch.Added:<br>err := store.Add(event.Object)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>utilruntime.HandleError(fmt.Errorf(<span class="hljs-string">&quot;%s: unable to add watch event object (%#v) to store: %v&quot;</span>, name, event.Object, err))<br>&#125;<br><span class="hljs-keyword">case</span> watch.Modified:<br>err := store.Update(event.Object)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>utilruntime.HandleError(fmt.Errorf(<span class="hljs-string">&quot;%s: unable to update watch event object (%#v) to store: %v&quot;</span>, name, event.Object, err))<br>&#125;<br><span class="hljs-keyword">case</span> watch.Deleted:<br><span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Will any consumers need access to the &quot;last known</span><br><span class="hljs-comment">// state&quot;, which is passed in event.Object? If so, may need</span><br><span class="hljs-comment">// to change this.</span><br>err := store.Delete(event.Object)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>utilruntime.HandleError(fmt.Errorf(<span class="hljs-string">&quot;%s: unable to delete watch event object (%#v) from store: %v&quot;</span>, name, event.Object, err))<br>&#125;<br><span class="hljs-keyword">case</span> watch.Bookmark:<br><span class="hljs-comment">// A `Bookmark` means watch has synced here, just update the resourceVersion</span><br><span class="hljs-keyword">if</span> _, ok := meta.GetAnnotations()[<span class="hljs-string">&quot;k8s.io/initial-events-end&quot;</span>]; ok &#123;<br><span class="hljs-keyword">if</span> exitOnInitialEventsEndBookmark != <span class="hljs-literal">nil</span> &#123;<br>*exitOnInitialEventsEndBookmark = <span class="hljs-literal">true</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">default</span>:<br>utilruntime.HandleError(fmt.Errorf(<span class="hljs-string">&quot;%s: unable to understand watch event %#v&quot;</span>, name, event))<br>&#125;<br>setLastSyncResourceVersion(resourceVersion)<br><span class="hljs-keyword">if</span> rvu, ok := store.(ResourceVersionUpdater); ok &#123;<br>rvu.UpdateResourceVersion(resourceVersion)<br>&#125;<br>eventCount++<br><span class="hljs-keyword">if</span> exitOnInitialEventsEndBookmark != <span class="hljs-literal">nil</span> &amp;&amp; *exitOnInitialEventsEndBookmark &#123;<br>watchDuration := clock.Since(start)<br>klog.V(<span class="hljs-number">4</span>).Infof(<span class="hljs-string">&quot;exiting %v Watch because received the bookmark that marks the end of initial events stream, total %v items received in %v&quot;</span>, name, eventCount, watchDuration)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br>&#125;<br>&#125;<br><br>watchDuration := clock.Since(start)<br><span class="hljs-keyword">if</span> watchDuration &lt; <span class="hljs-number">1</span>*time.Second &amp;&amp; eventCount == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;very short watch: %s: Unexpected watch close - watch lasted less than a second and no items received&quot;</span>, name)<br>&#125;<br>klog.V(<span class="hljs-number">4</span>).Infof(<span class="hljs-string">&quot;%s: Watch close - %v total %v items received&quot;</span>, name, expectedTypeName, eventCount)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>整个watch就是在不断的从<code>event, ok := &lt;-w.ResultChan()</code>并且将其塞进<code>store</code>里面，这个store就是我们在上面看到的<code>NewReflectorWithOptions(         c.config.ListerWatcher,         c.config.ObjectType,         c.config.Queue,         ReflectorOptions&#123;             ResyncPeriod:    c.config.FullResyncPeriod,             TypeDescription: c.config.ObjectDescription,             Clock:           c.clock,         &#125;,     )</code>里的<code>c.config.Queue</code>，对应上面informer流程图中的第2步——<code>AddObject</code>.</p><p>接下来我们看下<code>w, err = r.listerWatcher.Watch(options)</code>的listerWatcher是怎么来的。在初始化<code>Reflector</code>的时候我们通过<code>c.config.ListerWatcher</code>对<code>r.listerWatcher</code>进行了初始化，那<code>c.config.ListerWatcher</code>又是怎么来的呢？通过上面分析的<code>func (s *sharedIndexInformer) Run()</code>函数，我们知道<code>c.config.ListerWatcher</code>来自于sharedIndexInformer的<code>listerWatcher</code>。在我们的示例代码中，我们使用了<code>podInformer.Informer()</code>生成了一个pod的informer对象，其具体实现为：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f *podInformer)</span></span> Informer() cache.SharedIndexInformer &#123;<br><span class="hljs-keyword">return</span> f.factory.InformerFor(&amp;corev1.Pod&#123;&#125;, f.defaultInformer)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f *podInformer)</span></span> defaultInformer(client kubernetes.Interface, resyncPeriod time.Duration) cache.SharedIndexInformer &#123;<br><span class="hljs-keyword">return</span> NewFilteredPodInformer(client, f.namespace, resyncPeriod, cache.Indexers&#123;cache.NamespaceIndex: cache.MetaNamespaceIndexFunc&#125;, f.tweakListOptions)<br>&#125;<br><span class="hljs-comment">// NewFilteredPodInformer constructs a new informer for Pod type.</span><br><span class="hljs-comment">// Always prefer using an informer factory to get a shared informer instead of getting an independent</span><br><span class="hljs-comment">// one. This reduces memory footprint and number of connections to the server.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewFilteredPodInformer</span><span class="hljs-params">(client kubernetes.Interface, namespace <span class="hljs-type">string</span>, resyncPeriod time.Duration, indexers cache.Indexers, tweakListOptions internalinterfaces.TweakListOptionsFunc)</span></span> cache.SharedIndexInformer &#123;<br><span class="hljs-keyword">return</span> cache.NewSharedIndexInformer(<br>&amp;cache.ListWatch&#123;<br>ListFunc: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(options metav1.ListOptions)</span></span> (runtime.Object, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">if</span> tweakListOptions != <span class="hljs-literal">nil</span> &#123;<br>tweakListOptions(&amp;options)<br>&#125;<br><span class="hljs-keyword">return</span> client.CoreV1().Pods(namespace).List(context.TODO(), options)<br>&#125;,<br>WatchFunc: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(options metav1.ListOptions)</span></span> (watch.Interface, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">if</span> tweakListOptions != <span class="hljs-literal">nil</span> &#123;<br>tweakListOptions(&amp;options)<br>&#125;<br><span class="hljs-keyword">return</span> client.CoreV1().Pods(namespace).Watch(context.TODO(), options)<br>&#125;,<br>&#125;,<br>&amp;corev1.Pod&#123;&#125;,<br>resyncPeriod,<br>indexers,<br>)<br>&#125;<br><br></code></pre></td></tr></table></figure><p>通过k8s的代码的代码生成工具生成的相关代码中，都会有NewFilteredXXXInformer 函数，其中调用了 <code>NewSharedIndexInformer</code>，<code>ListWatch</code> 对象就是在这里初始化的。</p><p>具体的List&amp;Watch的流程为：</p><ol><li>首先 r.listerWatcher.List 获取所有资源数据<code>list</code>。本质上是调用 Kubernetes API 资源 NewFilteredPodInformer 时初始化 ListWatch 时传入的 ListFunc 函数，通过 ClientSet 客户端与 apiserver 交互并获取 Pod资源列表数据。</li><li>调用resourceVersion &#x3D; listMetaInterface.GetResourceVersion()<br>获取资源版本号。k8s内的每种资源都有资源版本号。注意，pod和pods是两种资源。当 Kubernetes 资源对象变化时，其资源版本也会发生变化</li><li>调用meta.ExtractList 将资源数据<code>list</code>转换为资源对象列表<code>items</code>。这里就是做一些类型转换。类似于将pods 资源对象转化为pod数组。</li><li>调用r.syncWith 将资源对象和资源版本号存储到 DeltaFIFO 队列中。这里是直接调用的<code>r.store.Replace(found, resourceVersion)</code>。</li><li>调用<code>r.setLastSyncResourceVersion(resourceVersion)</code>设置当前的资源版本号。</li></ol><p>至此，已经完成了资源对象的List操作，接下来进行资源对象的Watch操作。这里我们之前看到过，就是调用<code>r.watch()</code>，内部又调用<code>w, err = r.listerWatcher.Watch(options)</code>返回了了一个实现了watch接口的对象<code>w</code>，最终会调用到我们通过<code>NewFilteredPodInformer</code>生成的<code>WatchFunc</code>函数回调。</p><p>来看下<code>client.CoreV1().Pods(namespace).Watch</code>的函数实现：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-comment">// Watch returns a watch.Interface that watches the requested pods.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *pods)</span></span> Watch(ctx context.Context, opts metav1.ListOptions) (watch.Interface, <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-keyword">var</span> timeout time.Duration<br>    <span class="hljs-keyword">if</span> opts.TimeoutSeconds != <span class="hljs-literal">nil</span> &#123;<br>        timeout = time.Duration(*opts.TimeoutSeconds) * time.Second<br>    &#125;<br>    opts.Watch = <span class="hljs-literal">true</span><br>    <span class="hljs-keyword">return</span> c.client.Get().<br>        Namespace(c.ns).<br>        Resource(<span class="hljs-string">&quot;pods&quot;</span>).<br>        VersionedParams(&amp;opts, scheme.ParameterCodec).<br>        Timeout(timeout).<br>        Watch(ctx)<br>&#125;<br></code></pre></td></tr></table></figure><p>再来看下 <code>c.client.Get().         Namespace(c.ns).         Resource(&quot;pods&quot;).         VersionedParams(&amp;opts, scheme.ParameterCodec).         Timeout(timeout).         Watch(ctx)</code> 的实现:</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-comment">// Watch attempts to begin watching the requested location.</span><br><span class="hljs-comment">// Returns a watch.Interface, or an error.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *Request)</span></span> Watch(ctx context.Context) (watch.Interface, <span class="hljs-type">error</span>) &#123;<br><br>    url := r.URL().String()<br>    req, err := http.NewRequest(r.verb, url, r.body)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>    &#125;<br>    req = req.WithContext(ctx)<br>    req.Header = r.headers<br>    client := r.c.Client<br>    <span class="hljs-keyword">if</span> client == <span class="hljs-literal">nil</span> &#123;<br>        client = http.DefaultClient<br>    &#125;<br>    r.backoff.Sleep(r.backoff.CalculateBackoff(r.URL()))<br>    resp, err := client.Do(req)<br>    <span class="hljs-comment">// a lot of code here</span><br>    <span class="hljs-keyword">if</span> resp.StatusCode != http.StatusOK &#123;<br>        <span class="hljs-keyword">defer</span> resp.Body.Close()<br>        <span class="hljs-keyword">if</span> result := r.transformResponse(resp, req); result.err != <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, result.err<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;for request %s, got status: %v&quot;</span>, url, resp.StatusCode)<br>    &#125;<br><br>    contentType := resp.Header.Get(<span class="hljs-string">&quot;Content-Type&quot;</span>)<br>    mediaType, params, err := mime.ParseMediaType(contentType)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        klog.V(<span class="hljs-number">4</span>).Infof(<span class="hljs-string">&quot;Unexpected content type from the server: %q: %v&quot;</span>, contentType, err)<br>    &#125;<br>    objectDecoder, streamingSerializer, framer, err := r.c.content.Negotiator.StreamDecoder(mediaType, params)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>    &#125;<br><br>    frameReader := framer.NewFrameReader(resp.Body)<br>    watchEventDecoder := streaming.NewDecoder(frameReader, streamingSerializer)<br><br>    <span class="hljs-keyword">return</span> watch.NewStreamWatcher(<br>        restclientwatch.NewDecoder(watchEventDecoder, objectDecoder),<br>        <span class="hljs-comment">// use 500 to indicate that the cause of the error is unknown - other error codes</span><br>        <span class="hljs-comment">// are more specific to HTTP interactions, and set a reason</span><br>        errors.NewClientErrorReporter(http.StatusInternalServerError, r.verb, <span class="hljs-string">&quot;ClientWatchDecoding&quot;</span>),<br>    ), <span class="hljs-literal">nil</span><br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *Request)</span></span> newStreamWatcher(resp *http.Response) (watch.Interface, <span class="hljs-type">error</span>) &#123;<br>contentType := resp.Header.Get(<span class="hljs-string">&quot;Content-Type&quot;</span>)<br>mediaType, params, err := mime.ParseMediaType(contentType)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>klog.V(<span class="hljs-number">4</span>).Infof(<span class="hljs-string">&quot;Unexpected content type from the server: %q: %v&quot;</span>, contentType, err)<br>&#125;<br>objectDecoder, streamingSerializer, framer, err := r.c.content.Negotiator.StreamDecoder(mediaType, params)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><br>handleWarnings(resp.Header, r.warningHandler)<br><br>frameReader := framer.NewFrameReader(resp.Body)<br>watchEventDecoder := streaming.NewDecoder(frameReader, streamingSerializer)<br><br><span class="hljs-keyword">return</span> watch.NewStreamWatcher(<br>restclientwatch.NewDecoder(watchEventDecoder, objectDecoder),<br><span class="hljs-comment">// use 500 to indicate that the cause of the error is unknown - other error codes</span><br><span class="hljs-comment">// are more specific to HTTP interactions, and set a reason</span><br>errors.NewClientErrorReporter(http.StatusInternalServerError, r.verb, <span class="hljs-string">&quot;ClientWatchDecoding&quot;</span>),<br>), <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>很典型的 Golang HTTP 请求代码，但是 Kubernetes apiserver 首次应答的 HTTP Header 中会携带上 Transfer-Encoding: chunked，表示分块传输，客户端会保持这条 TCP 连接并等待下一个数据块。如此 apiserver 会主动将监听的 Kubernetes 资源对象的变化不断地推送给客户端：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">HTTP/1.1 200 OK<br>Content-Type: application/json<br>Transfer-Encoding: chunked<br><br>&#123;&quot;type&quot;:&quot;ADDED&quot;, &quot;object&quot;:&#123;&quot;kind&quot;:&quot;Pod&quot;,&quot;apiVersion&quot;:&quot;v1&quot;,...&#125;&#125;<br>&#123;&quot;type&quot;:&quot;ADDED&quot;, &quot;object&quot;:&#123;&quot;kind&quot;:&quot;Pod&quot;,&quot;apiVersion&quot;:&quot;v1&quot;,...&#125;&#125;<br>&#123;&quot;type&quot;:&quot;MODIFIED&quot;, &quot;object&quot;:&#123;&quot;kind&quot;:&quot;Pod&quot;,&quot;apiVersion&quot;:&quot;v1&quot;,...&#125;&#125;<br></code></pre></td></tr></table></figure><p>这样，Informer就已经完成了<code>List&amp;Watch</code>的过程。每一种资源的informer都会创建一个对应Relector，Relector<code>List &amp; Watch </code>某些资源对象，并将其推进对应的DeltaFifo队列里面。</p><p><code>Relector</code>进行List &amp; Watch的是在一条单独的go routine中执行中，informer会同时启动一个无限循环的函数，从DeltaFifo中取数据并进行后续的处理:</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *controller)</span></span> processLoop() &#123;<br><span class="hljs-keyword">for</span> &#123;<br>obj, err := c.config.Queue.Pop(PopProcessFunc(c.config.Process))<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">if</span> err == ErrFIFOClosed &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">if</span> c.config.RetryOnError &#123;<br><span class="hljs-comment">// This is the safe way to re-enqueue.</span><br>c.config.Queue.AddIfNotPresent(obj)<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>kubernetes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>kubernetes</tag>
      
      <tag>informer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang: pflag包</title>
    <link href="/2023/12/06/Golang-pflag%E5%8C%85/"/>
    <url>/2023/12/06/Golang-pflag%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><a href="https://github.com/spf13/pflag">pflag</a>是一个Go标准<code>flag</code>包的开箱即用的代替，实现了<code>POSIX/GNU</code>风格的flags。pflag的作用是帮助开发者定义命令行参数选项，命令行参数选项在实际开发中很常用，特别是在写工具的时候。</p><p>pflag的使用非常广泛，近些年大火的Kubernetes的大量组件的都是用的pflag代替Go原有的flag包。例如Kubelet：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs golang"><br><span class="hljs-comment">// NewKubeletCommand creates a *cobra.Command object with default parameters</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewKubeletCommand</span><span class="hljs-params">()</span></span> *cobra.Command &#123;<br>cleanFlagSet := pflag.NewFlagSet(componentKubelet, pflag.ContinueOnError)<br>cleanFlagSet.SetNormalizeFunc(cliflag.WordSepNormalizeFunc)<br>kubeletFlags := options.NewKubeletFlags()<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">go get github.com/spf13/pflag<br></code></pre></td></tr></table></figure><h2 id="定义参数"><a href="#定义参数" class="headerlink" title="定义参数"></a>定义参数</h2><p><code>pflag</code>完全兼容Go原生的flag包，因此只需简单的设置pflag，所有旧的代码都无需进行更改。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-keyword">import</span> flag <span class="hljs-string">&quot;github.com/spf13/pflag&quot;</span><br></code></pre></td></tr></table></figure><p>以下是一个更全的使用Demo:</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> flag <span class="hljs-string">&quot;github.com/spf13/pflag&quot;</span><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;strings&quot;</span><br>)<br><br><span class="hljs-comment">// 定义命令行参数对应的变量</span><br><span class="hljs-keyword">var</span> cliName = flag.StringP(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;n&quot;</span>, <span class="hljs-string">&quot;nick&quot;</span>, <span class="hljs-string">&quot;Input Your Name&quot;</span>)<br><span class="hljs-keyword">var</span> cliAge = flag.IntP(<span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-number">22</span>, <span class="hljs-string">&quot;Input Your Age&quot;</span>)<br><span class="hljs-keyword">var</span> cliGender = flag.StringP(<span class="hljs-string">&quot;gender&quot;</span>, <span class="hljs-string">&quot;g&quot;</span>,<span class="hljs-string">&quot;male&quot;</span>, <span class="hljs-string">&quot;Input Your Gender&quot;</span>)<br><span class="hljs-keyword">var</span> cliOK = flag.BoolP(<span class="hljs-string">&quot;ok&quot;</span>, <span class="hljs-string">&quot;o&quot;</span>, <span class="hljs-literal">false</span>, <span class="hljs-string">&quot;Input Are You OK&quot;</span>)<br><span class="hljs-keyword">var</span> cliDes = flag.StringP(<span class="hljs-string">&quot;des-detail&quot;</span>, <span class="hljs-string">&quot;d&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;Input Description&quot;</span>)<br><span class="hljs-keyword">var</span> cliOldFlag = flag.StringP(<span class="hljs-string">&quot;badflag&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;just for test&quot;</span>, <span class="hljs-string">&quot;Input badflag&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <br>    <span class="hljs-comment">// 为 age 参数设置 NoOptDefVal</span><br>    flag.Lookup(<span class="hljs-string">&quot;age&quot;</span>).NoOptDefVal = <span class="hljs-string">&quot;25&quot;</span><br><br>    <span class="hljs-comment">// 把 badflag 参数标记为即将废弃的，请用户使用 des-detail 参数</span><br>    flag.CommandLine.MarkDeprecated(<span class="hljs-string">&quot;badflag&quot;</span>, <span class="hljs-string">&quot;please use --des-detail instead&quot;</span>)<br>    <span class="hljs-comment">// 把 badflag 参数的 shorthand 标记为即将废弃的，请用户使用 des-detail 的 shorthand 参数</span><br>    flag.CommandLine.MarkShorthandDeprecated(<span class="hljs-string">&quot;badflag&quot;</span>, <span class="hljs-string">&quot;please use -d instead&quot;</span>)<br><br>    <span class="hljs-comment">// 在帮助文档中隐藏参数 gender</span><br>    flag.CommandLine.MarkHidden(<span class="hljs-string">&quot;badflag&quot;</span>)<br><br>    <span class="hljs-comment">// 把用户传递的命令行参数解析为对应变量的值</span><br>    flag.Parse()<br><br>    fmt.Println(<span class="hljs-string">&quot;name=&quot;</span>, *cliName)<br>    fmt.Println(<span class="hljs-string">&quot;age=&quot;</span>, *cliAge)<br>    fmt.Println(<span class="hljs-string">&quot;gender=&quot;</span>, *cliGender)<br>    fmt.Println(<span class="hljs-string">&quot;ok=&quot;</span>, *cliOK)<br>    fmt.Println(<span class="hljs-string">&quot;des=&quot;</span>, *cliDes)<br>&#125;<br></code></pre></td></tr></table></figure><p>与<code>flag</code>包不同，在pflag中，<code>-</code>和<code>--</code>代表的是不同的含义。<code>-</code>代表一系列flags的缩写，<code>--</code>代表完整的选项。所有的缩写都必须为boolean flags或者是具有默认值的参数。</p><p>定义好所有的flags后，需要调用<code>flag.Parse()</code>把命令行参数解析到定义好的flags里面。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>pflag命令行参数支持三种语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">--flag    // boolean flags, or flags with no option default values<br>--flag x  // only on flags without a default value<br>--flag=x<br></code></pre></td></tr></table></figure><ul><li>–flag写法只支持boolean或者没有可选默认值的flag</li><li>–flag x写法只支持没有默认值的flag</li></ul><p>pflag遇到<code>--</code>解析将会终止，例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">go build main.go<br>./main -A 1 -- -B 2<br></code></pre></td></tr></table></figure><p>-A 会被正常解析为1，-B则不会被解析，<code>--</code>之后的剩余参数会被保存在flag中，可以通过Args&#x2F;NArg&#x2F;Arg等方法访问。</p><h3 id="标准化选项的名称"><a href="#标准化选项的名称" class="headerlink" title="标准化选项的名称"></a>标准化选项的名称</h3><p><code>pflag</code>提供了<code>NormalizeFunc</code>可以实现标准化选项的功能。例如我们定义了一个flag为my-flag，用户在使用的时候写成了–my_flag&#x3D;3，我们希望这也能够正常工作，就通过 pflag 提供的 SetNormalizeFunc 功能轻松的解决这个问题。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">wordSepNormalizeFunc</span><span class="hljs-params">(f *flag.FlagSet, name <span class="hljs-type">string</span>)</span></span> flag.NormalizedName &#123;<br>    from := []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;-&quot;</span>, <span class="hljs-string">&quot;_&quot;</span>&#125;<br>    to := <span class="hljs-string">&quot;.&quot;</span><br>    <span class="hljs-keyword">for</span> _, sep := <span class="hljs-keyword">range</span> from &#123;<br>        name = strings.Replace(name, sep, to, <span class="hljs-number">-1</span>)<br>    &#125;<br>    <span class="hljs-keyword">return</span> flag.NormalizedName(name)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 设置标准化参数名称的函数</span><br>    flag.CommandLine.SetNormalizeFunc(wordSepNormalizeFunc)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="FlagSet"><a href="#FlagSet" class="headerlink" title="FlagSet"></a>FlagSet</h2><p><code>FlagSet</code>类型允许定义独立的标志集，例如在命令行界面中实现子命令。FlagSet的方法类似于命令行标志集的顶级函数。</p>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
      <tag>pflag</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ML入门-使用卷积和池化增强计算机视觉模型</title>
    <link href="/2023/12/05/ML%E5%85%A5%E9%97%A8-%E4%BD%BF%E7%94%A8%E5%8D%B7%E7%A7%AF%E5%92%8C%E6%B1%A0%E5%8C%96%E5%A2%9E%E5%BC%BA%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E6%A8%A1%E5%9E%8B/"/>
    <url>/2023/12/05/ML%E5%85%A5%E9%97%A8-%E4%BD%BF%E7%94%A8%E5%8D%B7%E7%A7%AF%E5%92%8C%E6%B1%A0%E5%8C%96%E5%A2%9E%E5%BC%BA%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是卷积"><a href="#什么是卷积" class="headerlink" title="什么是卷积"></a>什么是卷积</h2><p>卷积是一种过滤条件，可遍历图片、对其进行处理，然后提取重要的特征。事实上，卷积就是一种数学运算，跟加减乘除没有本质的区别。虽然这种运算本身很复杂，但它非常有助于简化更复杂的表达式.</p><p>假设您有一幅穿着运动鞋的人的图像。如何检测图像中是否存在运动鞋？为了让您的程序“看到”运动鞋的图像，您必须提取重要的特征，并对不必要的功能进行模糊处理。使用卷积输出的是一幅修改后的图像，这在深度学习中称为特征映射(feature map)。</p><p>从理论上说，特征映射过程非常简单。您将扫描图像中的每个像素，然后查看其相邻像素。您需将这些像素的值乘以过滤条件中的等效权重。</p><p>例如：</p><p><img src="https://developers.google.com/static/codelabs/tensorflow-3-convolutions/img/f7b0ab29e09a51f.png?hl=zh-cn" alt="图像上的卷积"></p><p>在这种情况下，系统会指定 3x3 的卷积矩阵（称之为卷积核）。卷积核的大小和模式为一个搅拌图片的方法。</p><blockquote><ul><li>单通道图片俗称灰度图，图片由二维矩阵构成，每个像素点都有一个值表示颜色。  </li><li>三通道图片：三通道分别指RGB(红，绿，蓝)通道。将通道红绿蓝三通道比作三个手电筒，那么RGB的值就是三个手电筒的灯光亮度。如果R,G,B三个通道的亮度一致，即R&#x3D;G&#x3D;B，那么这样的图片就是灰度模式的图片。如果这三个值不相等，那么就是彩色图。三通道图片由三个矩阵构成，其中每个元素都是0到255之间的一个整数。</li></ul></blockquote><p>当前的像素值为 192。您可以通过以下方式计算新像素的值：查看邻域值，将其乘以过滤条件中指定的值，并使新像素值设为最终值。(不同于矩阵乘法，却类似向量内积，这里是两个相同大小的矩阵的“点乘”)。当一个像素计算完毕后，移动一个像素到下一个区块执行相同的运算。</p><p><img src="https://pic1.zhimg.com/v2-625af6a961d1476dfff000ee0d936ce8_b.webp"></p><p>通常卷积神经网络并不学习单一的核，而是同时学习多层级的多个核。比如一个32x16x16的核用到256×256的图像上去会产生32个241×241个feature map。</p><blockquote><p>feature map的大小计算公式为：image size - kernel size +1。</p></blockquote><p>现在，您可以通过对 2D 灰度图像创建基本卷积来探索卷积的工作原理。</p><p>您将使用 <a href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.misc.ascent.html">SciPy 的升序图像</a>来进行演示。这是一个很好的内置图片工具，有许多角度和线条。</p><h3 id="卷积的应用场景"><a href="#卷积的应用场景" class="headerlink" title="卷积的应用场景"></a>卷积的应用场景</h3><ol><li>信号分析一个输入信号f(t)，经过一个线性系统（其特征可以用单位冲击响应函数g(t)描述）以后，输出信号应该是什么？实际上通过卷积运算就可以得到输出信号。</li><li>图像处理输入一幅图像f(x,y)，经过特定设计的卷积核g(x,y)进行卷积处理以后，输出图像将会得到模糊，边缘强化等各种效果。</li></ol><h2 id="开始编码"><a href="#开始编码" class="headerlink" title="开始编码"></a>开始编码</h2><p>首先导入一些 Python 库和升序图片：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">from</span> scipy <span class="hljs-keyword">import</span> misc<br>i = misc.ascent()<br></code></pre></td></tr></table></figure><p>接下来，使用 Pyplot 库 <code>matplotlib</code> 绘制图像，以便您了解图像：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br>plt.grid(<span class="hljs-literal">False</span>)<br>plt.gray()<br>plt.axis(<span class="hljs-string">&#x27;off&#x27;</span>)<br>plt.imshow(i)<br>plt.show()<br></code></pre></td></tr></table></figure><p><img src="https://developers.google.com/static/codelabs/tensorflow-3-convolutions/img/edb460dd5397f7f4.png?hl=zh-cn" alt="edb460dd5397f7f4.png"></p><p>您可以看到这是一张楼梯井的图像。您可以尝试并查明大量特征。例如，有很强的垂直线。</p><p>图像会存储为 NumPy 数组，因此我们只需复制该数组即可创建转换后的图像。size_x 和 size_y 变量将存储图像的尺寸，以便您稍后循环遍历该图像。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">i_transformed = np.copy(i)<br>size_x = i_transformed.shape[<span class="hljs-number">0</span>]<br>size_y = i_transformed.shape[<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><h2 id="创建卷积矩阵"><a href="#创建卷积矩阵" class="headerlink" title="创建卷积矩阵"></a>创建卷积矩阵</h2><p>首先，将卷积矩阵（或内核）构建成 3x3 数组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># This filter detects edges nicely</span><br><span class="hljs-comment"># It creates a filter that only passes through sharp edges and straight lines.</span><br><span class="hljs-comment"># Experiment with different values for fun effects.  </span><br><span class="hljs-built_in">filter</span> = [ [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>], [<span class="hljs-number">1</span>, -<span class="hljs-number">4</span>, <span class="hljs-number">1</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>]]<br><span class="hljs-comment"># A couple more filters to try for fun!filter = [ [-1, -2, -1], [0, 0, 0], [1, 2, 1]]</span><br><span class="hljs-comment">#filter = [ [-1, 0, 1], [-2, 0, 2], [-1, 0, 1]]</span><br><span class="hljs-comment"># If all the digits in the filter don&#x27;t add up to 0 or 1, you</span><br><span class="hljs-comment"># should probably do a weight to get it to do so</span><br><span class="hljs-comment"># so, for example, if your weights are 1,1,1 1,2,1 1,1,1</span><br><span class="hljs-comment"># They add up to 10, so you would set a weight of .1 if you want to normalize them</span><br>weight  = <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>现在，计算输出像素。迭代图像，保留 1 像素的外边距，并将当前像素的每个邻域乘以该过滤条件中定义的值。</p><p>这意味着当前像素的邻近像素和位于左侧的像素将乘以过滤条件中的左上角项。然后，用所得结果乘以权重，确保结果介于 0 到 255 之间。</p><p>最后，将新值加载到转换后的图像中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, size_x - <span class="hljs-number">1</span>):<br>    <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, size_y - <span class="hljs-number">1</span>):<br>        output_pixel = <span class="hljs-number">0.0</span><br>        <span class="hljs-comment"># 3x3 metric cal</span><br>        output_pixel = output_pixel + (i[x - <span class="hljs-number">1</span>, y - <span class="hljs-number">1</span>] * <span class="hljs-built_in">filter</span>[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>])<br>        output_pixel = output_pixel + (i[x, y - <span class="hljs-number">1</span>] * <span class="hljs-built_in">filter</span>[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>])<br>        output_pixel = output_pixel + (i[x + <span class="hljs-number">1</span>, y - <span class="hljs-number">1</span>] * <span class="hljs-built_in">filter</span>[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>])<br>        output_pixel = output_pixel + (i[x - <span class="hljs-number">1</span>, y] * <span class="hljs-built_in">filter</span>[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>])<br>        output_pixel = output_pixel + (i[x, y] * <span class="hljs-built_in">filter</span>[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>])<br>        output_pixel = output_pixel + (i[x + <span class="hljs-number">1</span>, y] * <span class="hljs-built_in">filter</span>[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>])<br>        output_pixel = output_pixel + (i[x - <span class="hljs-number">1</span>, y + <span class="hljs-number">1</span>] * <span class="hljs-built_in">filter</span>[<span class="hljs-number">2</span>][<span class="hljs-number">0</span>])<br>        output_pixel = output_pixel + (i[x, y + <span class="hljs-number">1</span>] * <span class="hljs-built_in">filter</span>[<span class="hljs-number">2</span>][<span class="hljs-number">1</span>])<br>        output_pixel = output_pixel + (i[x + <span class="hljs-number">1</span>, y + <span class="hljs-number">1</span>] * <span class="hljs-built_in">filter</span>[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>])<br>        output_pixel = output_pixel * weight<br>        <span class="hljs-keyword">if</span> output_pixel &lt; <span class="hljs-number">0</span>:<br>            output_pixel = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">if</span> output_pixel &gt; <span class="hljs-number">255</span>:<br>            output_pixel = <span class="hljs-number">255</span><br>        i_transformed[x, y] = output_pixel<br></code></pre></td></tr></table></figure><h2 id="查看返回的结果"><a href="#查看返回的结果" class="headerlink" title="查看返回的结果"></a><a href="https://developers.google.com/codelabs/tensorflow-3-convolutions?hl=zh-cn#4">查看返回的结果</a></h2><p>现在，绘制图像，查看通过过滤条件的效果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Plot the image. Note the size of the axes -- they are 512 by 512</span><br>plt.gray()<br>plt.grid(<span class="hljs-literal">False</span>)<br>plt.imshow(i_transformed)<br><span class="hljs-comment">#plt.axis(&#x27;off&#x27;)</span><br>plt.show()<br></code></pre></td></tr></table></figure><p><img src="https://developers.google.com/static/codelabs/tensorflow-3-convolutions/img/48ff667b2df812ad.png?hl=zh-cn" alt="48ff667b2df812ad.png"></p><p>请考虑以下过滤条件值及其对图像的影响。</p><p>使用 [-1,0,1,-2,0,2,-1,0,1] 获得一组很强的垂直线：</p><p><img src="https://developers.google.com/static/codelabs/tensorflow-3-convolutions/img/6f1cc59befac4d33.png?hl=zh-cn" alt="垂直线检测过滤条件"></p><p>使用 [-1,-2,-1,0,0,0,1,2,1] 获得水平线：</p><p><img src="https://developers.google.com/static/codelabs/tensorflow-3-convolutions/img/705ec1004fce21d4.png?hl=zh-cn" alt="水平线检测"></p><p>探索不同的值！此外，您还可以尝试其他尺寸的过滤条件，例如 5x5 或 7x7。</p><h2 id="了解池化"><a href="#了解池化" class="headerlink" title="了解池化"></a><a href="https://developers.google.com/codelabs/tensorflow-3-convolutions?hl=zh-cn#5">了解池化</a></h2><p>现在，您已确定了图像的基本特征，接下来要做什么？如何使用生成的特征图对图像进行分类？</p><p>与卷积类似，池化对特征检测有很大帮助。池化层可减少图像中的所有信息量，同时维持检测到的特征。</p><p>池化类型有多种，但您可以使用名为“最大池化”的池化类型。</p><p>迭代图片，并在每个点上考虑像素及其右侧、下方和右下方直接邻近像素。取其中最大的（即最大池化），并将其加载到新图像中。因此，新图像的大小将是旧图像的四分之一。<img src="https://developers.google.com/static/codelabs/tensorflow-3-convolutions/img/6029904d82700d8e.png?hl=zh-cn" alt="最大池化"></p><h2 id="编写池化代码"><a href="#编写池化代码" class="headerlink" title="编写池化代码"></a><a href="https://developers.google.com/codelabs/tensorflow-3-convolutions?hl=zh-cn#6">编写池化代码</a></h2><p>以下代码将显示 (2, 2) 池化。运行该代码以查看输出。</p><p>您会发现，虽然此图像大小是原始大小的四分之一，但保留了所有特征。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python">new_x = <span class="hljs-built_in">int</span>(size_x / <span class="hljs-number">2</span>)<br>new_y = <span class="hljs-built_in">int</span>(size_y / <span class="hljs-number">2</span>)<br>newImage = np.zeros((new_x, new_y))<br><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, size_x, <span class="hljs-number">2</span>):<br>    <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, size_y, <span class="hljs-number">2</span>):<br>        pixels = []<br>        pixels.append(i_transformed[x, y])<br>        pixels.append(i_transformed[x + <span class="hljs-number">1</span>, y])<br>        pixels.append(i_transformed[x, y + <span class="hljs-number">1</span>])<br>        pixels.append(i_transformed[x + <span class="hljs-number">1</span>, y + <span class="hljs-number">1</span>])<br>        pixels.sort(reverse=<span class="hljs-literal">True</span>)<br>        newImage[<span class="hljs-built_in">int</span>(x / <span class="hljs-number">2</span>), <span class="hljs-built_in">int</span>(y / <span class="hljs-number">2</span>)] = pixels[<span class="hljs-number">0</span>]<br><br><span class="hljs-comment"># Plot the image. Note the size of the axes -- now 256 pixels instead of 512</span><br>plt.gray()<br>plt.grid(<span class="hljs-literal">False</span>)<br>plt.imshow(newImage)<br><span class="hljs-comment"># plt.axis(&#x27;off&#x27;)</span><br>plt.show()<br></code></pre></td></tr></table></figure><p><img src="https://developers.google.com/static/codelabs/tensorflow-3-convolutions/img/1f5ebdafd1db2595.png?hl=zh-cn" alt="1f5ebdafd1db2595.png"></p><p>请注意该图表的轴。图像现在的尺寸为 256x256，是原始尺寸的四分之一，尽管现在图像中显示的数据较少，但检测到的特征也得到了增强。</p><h2 id="快速傅立叶变换"><a href="#快速傅立叶变换" class="headerlink" title="快速傅立叶变换"></a>快速傅立叶变换</h2><p>快速傅里叶变换是一种将时域和空域中的数据转换到频域上去的算法。傅里叶变换用一些正弦和余弦波的和来表示原函数。你可以在下面看到一个信号（一个以时间为参数的有周期的函数通常称为信号）是如何被傅里叶变换的：<br><img src="https://pic4.zhimg.com/v2-45259486c87abae677e7f4f4bb89176b_b.webp"></p><p>红色是时域，蓝色为频域</p><h2 id="三通道图片卷积操作"><a href="#三通道图片卷积操作" class="headerlink" title="三通道图片卷积操作"></a>三通道图片卷积操作</h2><p><img src="https://s2.51cto.com/images/blog/202302/15152631_63ec8927df6f311186.jpg?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_30,g_se,x_10,y_10,shadow_20,type_ZmFuZ3poZW5naGVpdGk=/format,webp/resize,m_fixed,w_1184"></p><p>左列的X是输入的三通道图像即彩色图像，中间红色的两列是我们的kernel（即3x3的filter），共两个（即输出的feature通道为2）。最后一列为卷积之后的特征（由于2个kernel，输出通道为2）。<br>由上面的过程可以看出，输入是3维（hight<em>width</em>channel）的，kernel实际上也是三维的。</p>]]></content>
    
    
    <categories>
      
      <category>Machine Learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ml</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ML入门-使用TensorFlow构建计算机视觉模型</title>
    <link href="/2023/12/05/ML%E5%85%A5%E9%97%A8-%E4%BD%BF%E7%94%A8TensorFlow%E6%9E%84%E5%BB%BA%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E6%A8%A1%E5%9E%8B/"/>
    <url>/2023/12/05/ML%E5%85%A5%E9%97%A8-%E4%BD%BF%E7%94%A8TensorFlow%E6%9E%84%E5%BB%BA%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>创建一个简单的深度神经网络（DNN），训练神经网络识别衣物</p><h2 id="数据准备"><a href="#数据准备" class="headerlink" title="数据准备"></a>数据准备</h2><p>我们使用名为 <a href="https://github.com/zalandoresearch/fashion-mnist">Fashion MNIST</a> 的常见数据集中识别衣物。该数据集包含 70000 种衣物，分为 10 个不同的类别。每件衣物都采用 28x28 的灰度图像。下面是一些示例：</p><p><img src="https://developers.google.com/static/codelabs/tensorflow-2-computervision/img/tenseimg10.png?hl=zh-cn"></p><p>与数据集关联的标签如下：</p><table><tbody><tr><td colspan="1" rowspan="1"><p><strong>标签</strong></p></td><td colspan="1" rowspan="1"><p><strong>说明</strong></p></td></tr><tr><td colspan="1" rowspan="1"><p>0</p></td><td colspan="1" rowspan="1"><p>T 恤衫/上衣</p></td></tr><tr><td colspan="1" rowspan="1"><p>1</p></td><td colspan="1" rowspan="1"><p>裤子</p></td></tr><tr><td colspan="1" rowspan="1"><p>2</p></td><td colspan="1" rowspan="1"><p>套衫</p></td></tr><tr><td colspan="1" rowspan="1"><p>3</p></td><td colspan="1" rowspan="1"><p>裙子</p></td></tr><tr><td colspan="1" rowspan="1"><p>4</p></td><td colspan="1" rowspan="1"><p>外套</p></td></tr><tr><td colspan="1" rowspan="1"><p>5</p></td><td colspan="1" rowspan="1"><p>凉鞋</p></td></tr><tr><td colspan="1" rowspan="1"><p>6</p></td><td colspan="1" rowspan="1"><p>衬衫</p></td></tr><tr><td colspan="1" rowspan="1"><p>7</p></td><td colspan="1" rowspan="1"><p>运动鞋</p></td></tr><tr><td colspan="1" rowspan="1"><p>8</p></td><td colspan="1" rowspan="1"><p>包</p></td></tr><tr><td colspan="1" rowspan="1"><p>9</p></td><td colspan="1" rowspan="1"><p>踝靴</p></td></tr></tbody></table><p>首先导入Tensorflow</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf<br><span class="hljs-built_in">print</span>(tf.__version__)<br></code></pre></td></tr></table></figure><p>获取Fashion MNIST数据集</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">mnist = tf.keras.datasets.fashion_mnist<br></code></pre></td></tr></table></figure><p>在该对象上调用 load_data 会生成两组列表，分别是训练值(training_images)和测试值(training_labels)，它们分别表示衣物及其标签。test_images用作测试集，用来评价模型在未遇到的数据集上的泛化效果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">(training_images, training_labels), (test_images, test_labels) = mnist.load_data()<br></code></pre></td></tr></table></figure><p>使用pyplot查看数据示例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br>plt.imshow(training_images[<span class="hljs-number">0</span>])<br><span class="hljs-built_in">print</span>(training_labels[<span class="hljs-number">0</span>])<br><span class="hljs-built_in">print</span>(training_images[<span class="hljs-number">0</span>])<br></code></pre></td></tr></table></figure><p>其输出如下所示：<br><img src="https://developers.google.com/static/codelabs/tensorflow-2-computervision/img/tenseimg20.png?hl=zh-cn"></p><p>所有值都是 0 到 255 之间的整数。在训练神经网络时，所有值在 0 到 1 之间处理起来更轻松，此过程称为归一化。幸运的是，Python 提供了一种无需循环便可归一化列表的简单方法</p><h2 id="设计模型"><a href="#设计模型" class="headerlink" title="设计模型"></a>设计模型</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">model = tf.keras.models.Sequential([tf.keras.layers.Flatten(),<br>                                    tf.keras.layers.Dense(<span class="hljs-number">128</span>, activation=tf.nn.relu),<br>                                    tf.keras.layers.Dense(<span class="hljs-number">10</span>, activation=tf.nn.softmax)])<br></code></pre></td></tr></table></figure><p>这里准备了一个三层的模型。</p><ul><li><code>Sequential</code> 定义了神经网络中的层序列。</li><li><code>Flatten</code> 会接受一个正方形并将其转换为一维矢量。</li><li><code>Dense</code> 会添加一层神经元。</li><li><code>Activation</code> 函数会告知各层神经元要执行的操作。选项有很多，但目前只采用以下选项：</li><li><code>Relu</code> 实际上意味着，如果 X 大于 0，则返回 X，否则返回 0。它只会将 0 或更大的值传递到网络中的下一层。</li><li><code>Softmax</code> 会接受一组值，并能有效地选择最大的值。例如，如果最后一层的输出是 [0.1, 0.1, 0.05, 0.1, 9.5, 0.1, 0.05, 0.05, 0.05]，那么您无需通过排序来获取最大值，它会返回 [0,0,0,0,1,0,0,0,0]。</li></ul><h2 id="编译和训练模型"><a href="#编译和训练模型" class="headerlink" title="编译和训练模型"></a>编译和训练模型</h2><p>现在已定义了模型，接下来要做的是构建模型。我们来创建模型，先使用 optimizer 和 loss 函数编译模型，然后使用训练数据和标签训练模型。</p><p>请注意，我们使用了 metrics&#x3D; 参数，这样的话，TensorFlow 可根据已知答案（标签）检查预测结果，从而报告训练准确率。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">model.<span class="hljs-built_in">compile</span>(optimizer = tf.keras.optimizers.Adam(),<br>              loss = <span class="hljs-string">&#x27;sparse_categorical_crossentropy&#x27;</span>,<br>              metrics=[<span class="hljs-string">&#x27;accuracy&#x27;</span>])<br><br>model.fit(training_images, training_labels, epochs=<span class="hljs-number">5</span>)<br></code></pre></td></tr></table></figure><p>model.fit 执行时，您会看到损失和准确率：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">Epoch 1/5<br>60000/60000 [=======] - 6s 101us/sample - loss: 0.4964 - acc: 0.8247<br>Epoch 2/5<br>60000/60000 [=======] - 5s 86us/sample - loss: 0.3720 - acc: 0.8656<br>Epoch 3/5<br>60000/60000 [=======] - 5s 85us/sample - loss: 0.3335 - acc: 0.8780<br>Epoch 4/5<br>60000/60000 [=======] - 6s 103us/sample - loss: 0.3134 - acc: 0.8844<br>Epoch 5/5<br>60000/60000 [=======] - 6s 94us/sample - loss: 0.2931 - acc: 0.8926<br></code></pre></td></tr></table></figure><p>模型完成训练后，您会在最后一个周期结束时看到准确率值。类似如上所示的 0.8926。这表明您的神经网络对训练数据进行分类时的准确率约为 89%。换言之，它可以找出图像与标签之间的模式匹配，成功率达到 89%。</p><h2 id="测试模型"><a href="#测试模型" class="headerlink" title="测试模型"></a>测试模型</h2><p>调用model.evaluate 并传入测试集，并报告每组的损失。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">model.evaluate(test_images, test_labels)<br></code></pre></td></tr></table></figure><p>输出内容如下所示：<br>10000&#x2F;10000 [&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;] - 1s 56us&#x2F;sample - loss: 0.3365 - acc: 0.8789<br>[0.33648381242752073, 0.8789]</p><p>该示例返回了 0.8789 的准确率，表示其准确率约为 88%。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li><p>经验法则1: 网络的第一层应与数据形状保持一致。图像的数据是28x28的图像，28 个包含 28 个神经元的层将不可行，因此将 28,28 平化为 784x1 更有意义。</p></li><li><p>经验法则2: 最后一层中的神经元数量应该与您要分类的类的数量相匹配。</p></li><li><p>经验法则3: In a nutshell, normalization reduces the complexity of the problem your network is trying to solve. This can potentially increase the accuracy of your model and speed up the training</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Machine Learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ml</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ML入门-机器学习概念介绍</title>
    <link href="/2023/12/05/ML%E5%85%A5%E9%97%A8-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%A6%82%E5%BF%B5%E4%BB%8B%E7%BB%8D/"/>
    <url>/2023/12/05/ML%E5%85%A5%E9%97%A8-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%A6%82%E5%BF%B5%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是机器学习"><a href="#什么是机器学习" class="headerlink" title="什么是机器学习"></a>什么是机器学习</h2><p>考虑传统的构建应用的方式，如下图所示：<br><img src="https://developers.google.com/static/codelabs/tensorflow-1-helloworld/img/c72f871306134e45.png?hl=zh-cn"><br>我们定义规则，并使用一种编程语言表达规则，这些规则根据数据执行操作，我们的程序会返回确定的答案。<br>通过机器学习构建应用的方式过程非常相似，只是轴线不同：<br><img src="https://developers.google.com/static/codelabs/tensorflow-1-helloworld/img/9b85a337ee816e1b.png?hl=zh-cn"><br>与传统的构建方式不同，我们不再需要定义规则并且也不需要用编程语言表达规则，我们只需提供答案（标签）以及数据，机器即可推断出用户确定答案与数据之间关系的规则。<br>例如，考虑到一个活动检测的场景，我们需要判断活动的类型：<br><img src="https://developers.google.com/static/codelabs/tensorflow-1-helloworld/img/6ff58697a85931f4.png?hl=zh-cn"><br>我们需要收集大量的数据，并有效地标记其为“WALKING”或者“RUNNING”。然后，计算机可以根据数据推断出决定某一特定活动的不同模式的规则。<br>在传统编程中，代码被编译为通常称为程序的二进制文件。在机器学习中，通过数据和标签创建的项称为模型。因此我们可以把通过机器学习构建应用的过程表示为：<br><img src="https://developers.google.com/static/codelabs/tensorflow-1-helloworld/img/693430bb4d7fa001.png?hl=zh-cn"><br>我们向模型传递一些数据，然后模型会使用从训练中推断的规则进行预测.</p><h2 id="构建模型"><a href="#构建模型" class="headerlink" title="构建模型"></a>构建模型</h2><p>以下是一组数据示例，我们该如何找出X和Y之间的关系？</p><table><tbody><tr><td colspan="1" rowspan="1"><p>X:</p></td><td colspan="1" rowspan="1"><p>-1</p></td><td colspan="1" rowspan="1"><p>0</p></td><td colspan="1" rowspan="1"><p>1</p></td><td colspan="1" rowspan="1"><p>2</p></td><td colspan="1" rowspan="1"><p>3</p></td><td colspan="1" rowspan="1"><p>4</p></td></tr><tr><td colspan="1" rowspan="1"><p>Y:</p></td><td colspan="1" rowspan="1"><p>-2</p></td><td colspan="1" rowspan="1"><p>1</p></td><td colspan="1" rowspan="1"><p>4</p></td><td colspan="1" rowspan="1"><p>7</p></td><td colspan="1" rowspan="1"><p>10</p></td><td colspan="1" rowspan="1"><p>13</p></td></tr></tbody></table>现在，我们来看一下执行该操作的代码，创建一个python文件。<h3 id="使用pip安装tensorflow"><a href="#使用pip安装tensorflow" class="headerlink" title="使用pip安装tensorflow"></a>使用pip安装tensorflow</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">pip install --upgrade tensorflow<br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#验证安装效果</span></span><br>python -c &quot;import tensorflow as tf;print(tf. reduce_sum(tf.random.normal([1000, 1000])))&quot;<br></code></pre></td></tr></table></figure><blockquote><p>TensorFlow是一个由Google开发的开源机器学习框架，它可以用于构建和训练各种机器学习模型，包括神经网络。TensorFlow使用数据流图来表示数学运算，其中节点表示操作，边表示数据流动。它提供了一个灵活的平台，可以在各种不同的硬件上运行，包括CPU、GPU和TPU。TensorFlow已经成为机器学习领域中最受欢迎的框架之一，被广泛应用于深度学习、自然语言处理、计算机视觉和许多其他领域。</p></blockquote><h3 id="导入依赖"><a href="#导入依赖" class="headerlink" title="导入依赖"></a>导入依赖</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">from</span> tensorflow <span class="hljs-keyword">import</span> keras<br></code></pre></td></tr></table></figure><ul><li>numpy:该库可以轻松而快速地以列表形式展示您的数据。</li><li>keras: tensorflow提供的将神经网络定义为一组顺序层的框架称为。</li></ul><h3 id="创建并编译神经网络"><a href="#创建并编译神经网络" class="headerlink" title="创建并编译神经网络"></a>创建并编译神经网络</h3><p>接下来，创建尽可能最简单的神经网络。该神经网络有一个层，该层有一个神经元，其输入形状只有一个值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">model = tf.keras.Sequential([keras.layers.Dense(units=<span class="hljs-number">1</span>, input_shape=[<span class="hljs-number">1</span>])])<br></code></pre></td></tr></table></figure><p>接下来，编写代码以编译神经网络。执行此操作时，您需要指定两个函数：<code>loss</code> 和 <code>optimizer</code>。</p><p>神经网络模型会进行猜测X与Y之间的关系，例如是 Y&#x3D;10X+10。<code>loss</code> 函数将猜测答案与已知正确答案进行对比，并衡量结果的好坏。</p><p>接下来，模型使用 <code>optimizer</code> 函数进行另一个猜测。它会根据损失函数的结果，最大限度地减少损失。此时，可能会得到 Y&#x3D;5X+5 之类的内容。虽然这样仍有些糟糕，但更接近正确的结果（损失更低）。</p><p>模型会针对即将经历的周期执行同样的操作。</p><p>首先，以下方法将告知模型使用 <code>mean_squared_error</code> 表示损失，以及随机梯度下降法 <strong>(</strong><code>sgd</code><strong>)</strong> 作为优化器。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">model.compile(<span class="hljs-attribute">optimizer</span>=<span class="hljs-string">&#x27;sgd&#x27;</span>, <span class="hljs-attribute">loss</span>=<span class="hljs-string">&#x27;mean_squared_error&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="准备数据"><a href="#准备数据" class="headerlink" title="准备数据"></a>准备数据</h3><p>我们使用numpy的python库用来将上表中的数据转化为模型的训练数据，在 numpy 中使用 <code>np.array[]</code> 将值指定为数组:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">xs = np.array([-<span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">2.0</span>, <span class="hljs-number">3.0</span>, <span class="hljs-number">4.0</span>], dtype=<span class="hljs-built_in">float</span>)<br>ys = np.array([-<span class="hljs-number">2.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">4.0</span>, <span class="hljs-number">7.0</span>, <span class="hljs-number">10.0</span>, <span class="hljs-number">13.0</span>], dtype=<span class="hljs-built_in">float</span>)<br></code></pre></td></tr></table></figure><p>现在，我们已经具备了定义神经网络所需的全部代码。下一步是训练该代码，查看它能否推断出这些数字之间的模式，并使用其创建模型。</p><h3 id="训练神经网络"><a href="#训练神经网络" class="headerlink" title="训练神经网络"></a>训练神经网络</h3><p>训练神经网络的过程是在 model.fit 调用中的，神经网络从其中了解 X 和 Y 之间的关系。在这种情况下，它会在进行猜测、衡量好坏（损失），或通过优化器做出另一个猜测之前遍历整个循环。它会按照您指定的周期数运行。运行该代码时，您会看到每个周期输出的损失:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">model.fit(xs, ys, epochs=<span class="hljs-number">500</span>)<br></code></pre></td></tr></table></figure><p>输出如下所示，随着训练的进行，损失会很快减小：<br><img src="https://developers.google.com/static/codelabs/tensorflow-1-helloworld/img/81ca5e71298b414b.png?hl=zh-cn"></p><h3 id="使用模型"><a href="#使用模型" class="headerlink" title="使用模型"></a>使用模型</h3><p>模型经过训练后已经了解了<code>X</code> 和 <code>Y</code> 之间的关系（当然不一定准确）。可以使用 model.predict 方法求出先前未知 X 的 Y。例如，如果 <code>X</code> 为 10，您认为 <code>Y</code> 为多少？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(model.predict([<span class="hljs-number">10.0</span>]))<br><span class="hljs-comment">##输出类似于：[[30.99968]]</span><br></code></pre></td></tr></table></figure><p>通过观察上面表格的数据，我们可以知道X和Y的关系为：Y&#x3D;3X+1。因此当<code>X</code>&#x3D;10时，<code>Y</code>应该为31。但模型的输出不一定为31。神经网络处理概率，因此它计算出 X 和 Y 之间的关系有很高的概率为 Y&#x3D;3X+1，但仅凭 6 个数据点不可能确定其关系。所得结果接近 31，但不一定是 31。</p>]]></content>
    
    
    <categories>
      
      <category>Machine Learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ml</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kube-batch详解</title>
    <link href="/2023/12/03/kube-batch%E8%AF%A6%E8%A7%A3/"/>
    <url>/2023/12/03/kube-batch%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>Kubernetes提供了默认的kube scheduler调度器将未调度的 Pod 按照调度策略绑定到合适的 Node，其调度的流程如下图所示：<br><img src="https://raw.githubusercontent.com/kubernetes/enhancements/master/keps/sig-scheduling/624-scheduling-framework/scheduling-framework-extensions.png" alt="kube scheduler调度流程"><br>kube scheduler调度主要分为以下几个部分：</p><ul><li>预选过程:过滤掉不满足条件的节点，这个过程称为Predicates</li><li>优选过程:对通过的节点按照优先级排序，称之为Priorities</li></ul><p>最后从中选择优先级最高的节点，将Pod调度到此节点上。</p><p>从上面的调度流程可以看到，Kube Scheduler 是基于单个Pod的调度，Kube Scheduler的调度目标是给单个Pod找到最优的节点，这个特性对于需要涉及到多个Pod的作业来说（分布式AI训练&#x2F;大数据）是不够友好的。以AI为例，分布式训练需要所有 worker 都启动后，训练才能够开始进行。使用原生调度器，可能会出现以下问题：</p><ul><li>一个任务包含 10 个 worker, 但是集群剩余资源只满足 9 个 worker。原生调度器会将任务的 9 个 worker 调度并启动，而最后一个 worker 一直无法启动。这样训练一直无法开始，9 个已经启动的 worker 资源就会被浪费。</li><li>两个任务，各包含 10 个 worker, 集群资源只能启动 10 个 worker。两个任务分别有 5 个 worker 被启动，但两个任务都无法开始训练。10 个 worker 的资源被浪费了。</li></ul><p>Kubernetes社区提供了<a href="https://github.com/kubernetes-retired/kube-batch/edit/master/doc/usage/tutorial.md">kube batch</a>调度器，帮助 Kubernetes弥补在“高性能计算”方面的不足，帮助Kubernetes构建统一的容器平台。</p><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p><img src="https://pic3.zhimg.com/80/v2-057fae99cb1a1a620b98bb4b96f0127e_1440w.webp" alt="kube batch架构"></p><p>可以看到kube batch提供的两个核心能力为：</p><ul><li>提供一个资源调度的中间层,为计算类作业提供了相应的调度算法支持</li><li>多租户之间的隔离</li></ul><p>Kube Batch 内部包含如下几个模块：</p><ul><li>Cache，缓存 Kubernetes 集群内的 Node、Pod、PodGroup、Queue 等资源对象信息。</li><li>Session，该模块用于管理 Kube Batch 的调度过程，每次调度称为一次 Session 过程。</li><li>Action，一次调度包括多个 Action 操作，Action根据配置的Plugins内容将作业调度到具体的节点上。</li><li>Plugin，用于实现不同调度策略，例如 DRF、Gang Scheduling。</li></ul><p>当前kube batch支持的actions和plugins包括：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs golang">actions: <span class="hljs-string">&quot;allocate, backfill&quot;</span><br>tiers:<br>- plugins:<br>  - name: priority<br>  - name: gang<br>- plugins:<br>  - name: drf<br>  - name: predicates<br>  - name: proportion<br>  - name: nodeorder<br></code></pre></td></tr></table></figure><p>Kube Batch默认启动的配置包括allocate和backfill两个action，</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-keyword">var</span> defaultSchedulerConf = <span class="hljs-string">`</span><br><span class="hljs-string">actions: &quot;allocate, backfill&quot;</span><br><span class="hljs-string">tiers:</span><br><span class="hljs-string">- plugins:</span><br><span class="hljs-string">  - name: priority</span><br><span class="hljs-string">  - name: gang</span><br><span class="hljs-string">- plugins:</span><br><span class="hljs-string">  - name: drf</span><br><span class="hljs-string">  - name: predicates</span><br><span class="hljs-string">  - name: proportion</span><br><span class="hljs-string">  - name: nodeorder`</span><br></code></pre></td></tr></table></figure><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>......<br><span class="hljs-keyword">if</span> err := app.Run(s); err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Fprintf(os.Stderr, <span class="hljs-string">&quot;%v\n&quot;</span>, err)<br>os.Exit(<span class="hljs-number">1</span>)<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// Run the kubeBatch scheduler</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Run</span><span class="hljs-params">(opt *options.ServerOption)</span></span> <span class="hljs-type">error</span> &#123;<br><span class="hljs-comment">// Start policy controller to allocate resources.</span><br>sched, err := scheduler.NewScheduler(config,<br>opt.SchedulerName,<br>opt.SchedulerConf,<br>opt.SchedulePeriod,<br>opt.DefaultQueue)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><br>run := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ctx context.Context)</span></span> &#123;<br>sched.Run(ctx.Done())<br>&lt;-ctx.Done()<br>&#125;<br><br><span class="hljs-keyword">if</span> !opt.EnableLeaderElection &#123;<br>run(context.TODO())<br><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;finished without leader elect&quot;</span>)<br>&#125;<br><br>leaderelection.RunOrDie(context.TODO(), leaderelection.LeaderElectionConfig&#123;<br>Lock:          rl,<br>LeaseDuration: leaseDuration,<br>RenewDeadline: renewDeadline,<br>RetryPeriod:   retryPeriod,<br>Callbacks: leaderelection.LeaderCallbacks&#123;<br>OnStartedLeading: run,<br>OnStoppedLeading: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>glog.Fatalf(<span class="hljs-string">&quot;leaderelection lost&quot;</span>)<br>&#125;,<br>&#125;,<br>&#125;)<br><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;lost lease&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>kube batch的<a href="https://github.com/kubernetes-retired/kube-batch/blob/1ebe60e4af4f164cab0818bc1530e541ed7aa1a5/cmd/kube-batch/app/server.go">启动流程</a>：</p><ol><li>判断是否需要进行leader election，若不需要，调用sched.Run(ctx.Done())启动调度</li><li>若需要，先进行leader election，leader再调用sched.Run(ctx.Done())启动调度</li></ol><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(pc *Scheduler)</span></span> Run(stopCh &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;) &#123;<br>     <span class="hljs-comment">// Start cache for policy.</span><br>    <span class="hljs-keyword">go</span> pc.cache.Run(stopCh)<br>    ......<br>    pc.actions, pc.pluginArgs = loadSchedulerConf(conf)<br><br>    <span class="hljs-keyword">go</span> wait.Until(pc.runOnce, <span class="hljs-number">1</span>*time.Second, stopCh)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(pc *Scheduler)</span></span> runOnce() &#123;<br>    ssn := framework.OpenSession(pc.cache, pc.pluginArgs)<br>    <span class="hljs-keyword">defer</span> framework.CloseSession(ssn)<br><br>    <span class="hljs-keyword">for</span> _, action := <span class="hljs-keyword">range</span> pc.actions &#123;<br>        action.Execute(ssn)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>sched的调度过程如上：</p><ol><li>调用cache模块，通过Informer同步集群内Pod&#x2F;Node等相关信息。</li><li>加载配置文件</li><li>每隔<code>1*time.Second</code>调用一次<code>sched.runOnce()</code>，执行调度</li><li><code>runOnce</code>依次执行OpenSession-&gt;action.Execute(ssn)-&gt;CloseSession()</li></ol><h3 id="cache"><a href="#cache" class="headerlink" title="cache"></a>cache</h3><p>cache的具体实现为：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-comment">// Run  starts the schedulerCache</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(sc *SchedulerCache)</span></span> Run(stopCh &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;) &#123;<br><span class="hljs-keyword">go</span> sc.pdbInformer.Informer().Run(stopCh)<br><span class="hljs-keyword">go</span> sc.podInformer.Informer().Run(stopCh)<br><span class="hljs-keyword">go</span> sc.nodeInformer.Informer().Run(stopCh)<br><span class="hljs-keyword">go</span> sc.podGroupInformerv1alpha1.Informer().Run(stopCh)<br><span class="hljs-keyword">go</span> sc.podGroupInformerv1alpha2.Informer().Run(stopCh)<br><span class="hljs-keyword">go</span> sc.pvInformer.Informer().Run(stopCh)<br><span class="hljs-keyword">go</span> sc.pvcInformer.Informer().Run(stopCh)<br><span class="hljs-keyword">go</span> sc.scInformer.Informer().Run(stopCh)<br><span class="hljs-keyword">go</span> sc.queueInformerv1alpha1.Informer().Run(stopCh)<br><span class="hljs-keyword">go</span> sc.queueInformerv1alpha2.Informer().Run(stopCh)<br><br><span class="hljs-keyword">if</span> options.ServerOpts.EnablePriorityClass &#123;<br><span class="hljs-keyword">go</span> sc.pcInformer.Informer().Run(stopCh)<br>&#125;<br><br><span class="hljs-comment">// Re-sync error tasks.</span><br><span class="hljs-keyword">go</span> wait.Until(sc.processResyncTask, <span class="hljs-number">0</span>, stopCh)<br><br><span class="hljs-comment">// Cleanup jobs.</span><br><span class="hljs-keyword">go</span> wait.Until(sc.processCleanupJob, <span class="hljs-number">0</span>, stopCh)<br>&#125;<br></code></pre></td></tr></table></figure><p>除了缓存pod&#x2F;Node&#x2F;PV&#x2F;PVC等相关信息外，kube batch还定义了一系列的CRDs，以实现批量调度和多租户之间的隔离。</p><h3 id="session"><a href="#session" class="headerlink" title="session"></a>session</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-comment">// OpenSession start the session</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">OpenSession</span><span class="hljs-params">(cache cache.Cache, tiers []conf.Tier)</span></span> *Session &#123;<br>ssn := openSession(cache)<br><br><span class="hljs-keyword">for</span> _, plugin := <span class="hljs-keyword">range</span> ssn.plugins &#123;<br>plugin.OnSessionOpen(ssn)<br>&#125;<br><span class="hljs-keyword">return</span> ssn<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">openSession</span><span class="hljs-params">(cache cache.Cache)</span></span> *Session &#123;<br>ssn := &amp;Session&#123;<br>UID:   uuid.NewUUID(),<br>cache: cache<br>&#125;<br><br>snapshot := cache.Snapshot()<br><br>ssn.Jobs = snapshot.Jobs<br>ssn.Nodes = snapshot.Nodes<br>ssn.Queues = snapshot.Queues<br><span class="hljs-keyword">return</span> ssn<br>&#125;<br></code></pre></td></tr></table></figure><p>OpenSession首先调用了<code>openSession(cache cache.Cache)</code>获取到本次调度的session，<code>openSession(cache cache.Cache)</code>内部对当前缓存的cache进行了快照，并将快照里的信息保存在了session中。然后调用注册的plugins的<code>OnSessionOpen</code>方法通知新一轮的调度开始。</p><p>plugins在<code>OnSessionOpen</code>做的事情主要为注册一系列的函数，以Gang plugin为例，其<code>OnSessionOpen</code>的实现为：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(gp *gangPlugin)</span></span> OnSessionOpen(ssn *framework.Session) &#123;<br>validJobFn := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(obj <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> *api.ValidateResult &#123;<br>....<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br>ssn.AddJobValidFn(gp.Name(), validJobFn)<br><br>preemptableFn := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(preemptor *api.TaskInfo, preemptees []*api.TaskInfo)</span></span> []*api.TaskInfo &#123;<br>...<br><span class="hljs-keyword">return</span> victims<br>&#125;<br><br><span class="hljs-comment">// TODO(k82cn): Support preempt/reclaim batch job.</span><br>ssn.AddReclaimableFn(gp.Name(), preemptableFn)<br>ssn.AddPreemptableFn(gp.Name(), preemptableFn)<br><br>jobOrderFn := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(l, r <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> <span class="hljs-type">int</span> &#123;<br>...<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>&#125;<br><br>ssn.AddJobOrderFn(gp.Name(), jobOrderFn)<br>ssn.AddJobReadyFn(gp.Name(), <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(obj <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> <span class="hljs-type">bool</span> &#123;<br>ji := obj.(*api.JobInfo)<br><span class="hljs-keyword">return</span> ji.Ready()<br>&#125;)<br>ssn.AddJobPipelinedFn(gp.Name(), <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(obj <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> <span class="hljs-type">bool</span> &#123;<br>ji := obj.(*api.JobInfo)<br><span class="hljs-keyword">return</span> ji.Pipelined()<br>&#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>每个plugin都定义了一系列的回调函数，并且在每次调度周期开始时需要注册到ssn里面。ssn里面定义了很多的map用来存在每个plugin的回调函数，并在调度时依次调用。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-keyword">type</span> Sesssion <span class="hljs-keyword">struct</span>&#123;<br>jobOrderFns      <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]api.CompareFn<br>queueOrderFns    <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]api.CompareFn<br>taskOrderFns     <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]api.CompareFn<br>predicateFns     <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]api.PredicateFn<br>preemptableFns   <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]api.EvictableFn<br>reclaimableFns   <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]api.EvictableFn<br>overusedFns      <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]api.ValidateFn<br>jobReadyFns      <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]api.ValidateFn<br>jobPipelinedFns  <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]api.ValidateFn<br>jobValidFns      <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]api.ValidateExFn<br>nodePrioritizers <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>][]priorities.PriorityConfig<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="action"><a href="#action" class="headerlink" title="action"></a>action</h3><p>以allocate action为例，其实现为：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(alloc *allocateAction)</span></span> Execute(ssn *framework.Session) &#123;<br>queues := util.NewPriorityQueue(ssn.QueueOrderFn)<br><span class="hljs-keyword">for</span> _, job := <span class="hljs-keyword">range</span> ssn.Jobs &#123;<br><span class="hljs-keyword">if</span> queue, found := ssn.Queues[job.Queue]; found &#123;<br>queues.Push(queue)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>glog.Warningf(<span class="hljs-string">&quot;Skip adding Job &lt;%s/%s&gt; because its queue %s is not found&quot;</span>,<br>job.Namespace, job.Name, job.Queue)<br><span class="hljs-keyword">continue</span><br>&#125;<br><br>&#125;<br><br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">if</span> queues.Empty() &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br><br>queue := queues.Pop().(*api.QueueInfo)<br><br>jobs, found := jobsMap[queue.UID]<br><br>job := jobs.Pop().(*api.JobInfo)<br><br>tasks := pendingTasks[job.UID]<br><br><span class="hljs-keyword">for</span> !tasks.Empty() &#123;<br>task := tasks.Pop().(*api.TaskInfo)<br>predicateNodes := util.PredicateNodes(task, allNodes, predicateFn)<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(predicateNodes) == <span class="hljs-number">0</span> &#123;<br><span class="hljs-comment">// Further Tasks should be checked because tasks are ordered in priority, so it affects taskPriority within Job,</span><br><span class="hljs-comment">// so if one task fails predicates, it should not check further tasks in same job, should skip to next job.</span><br><span class="hljs-keyword">break</span><br>&#125;<br>priorityList, err := util.PrioritizeNodes(task, predicateNodes, ssn.NodePrioritizers())<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>glog.Errorf(<span class="hljs-string">&quot;Prioritize Nodes for task %s err: %v&quot;</span>, task.UID, err)<br><span class="hljs-keyword">break</span><br>&#125;<br>nodeName := util.SelectBestNode(priorityList)<br>            ......<br>&#125;<br><span class="hljs-comment">// Added Queue back until no job in Queue.</span><br>queues.Push(queue)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看出，在单个Session中，Job首先按照Queue进行聚合，然后依次遍历每条队列里的每个Job，将这个Job内部的Task依次执行调度。调度过程也跟默认的Kube Scheduler调度器差不多:<code>PredicateNodes-&gt;PrioritizeNodes-&gt;SelectBestNode</code>。在调用Action之前，OpenSession为配置的Plugins注册了一系列Func，在执行不同Action的时候，使用这些Func对Node进行选择，并且判断Job是否符合调度条件。</p><p>kube-batch问题：在alloca action的在每个周期中，所有的Job按照plugins定义的顺序进行遍历。对于每个Job，都尝试在同一份Node缓存里进行分配。因此，若排在前面的Job占据了资源，但最终Job.Ready()返回false从而在没有实际BINDING对应的Pod到节点上，这部分资源也不会释放。因此很容易出现由于一个不“正确”的Job卡住后续的所有Job的情况。因此一般需要多个action配合使用，避免这种问题。</p>]]></content>
    
    
    <categories>
      
      <category>kubernetes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>kubernetes</tag>
      
      <tag>kube-batch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kubernetes Leader Election机制详解</title>
    <link href="/2023/12/02/Kubernetes-Leader-Election%E6%9C%BA%E5%88%B6/"/>
    <url>/2023/12/02/Kubernetes-Leader-Election%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>分布式应用通常会创建多个service的副本以提高service的可靠性和可伸缩性，但通常有必要指定一个副本负责所有副本之间的协调，kubernetes的SIG已经提供了这方面的能力，主要是通过configmap&#x2F;lease&#x2F;endpoint的资源实现选Leader的功能。通常在<code>Leader Election</code>的选举过程中，会有一组确定的candidates（候选人）都竞相宣称自己是Leader，其中会有一个candidates选举成功。一旦选举获胜，Leader就会按照固定的间隔不断的发送“心跳”以维持其领导人的地位(在稳定的环境中，实例一旦成为了leader，通常情况是不会释放锁的，会保持一直运行的状态，这样有利于业务的稳定和Controller快速的对资源的状态变化做成相应的操作)。其他竞选失败的candidates会周期性地进行新的尝试，以确保当当前的Leader因为某种原因而失败，新的Leader能够被迅速的确定。</p><p>为了执行Kubernetes内部的Leader Election，需要用到Kubernetes API对象的两个属性：</p><ul><li>ResourceVersions - Every API object has a unique ResourceVersion, and you can use these versions to perform compare-and-swap on Kubernetes objects</li><li>Annotations - Every API object can be annotated with arbitrary key&#x2F;value pairs to be used by clients.</li></ul><h2 id="启动选举"><a href="#启动选举" class="headerlink" title="启动选举"></a>启动选举</h2><p>Kubernetes提供了<a href="https://github.com/kubernetes-retired/kube-batch/blob/1ebe60e4af4f164cab0818bc1530e541ed7aa1a5/vendor/k8s.io/client-go/tools/leaderelection/resourcelock/interface.go">Endpoints、ConfigMap 和 Lease</a>三种资源锁，Leader Election 选主的实现方式就是基于这三种资源锁。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-keyword">const</span> (<br>EndpointsResourceLock             = <span class="hljs-string">&quot;endpoints&quot;</span><br>ConfigMapsResourceLock            = <span class="hljs-string">&quot;configmaps&quot;</span><br>LeasesResourceLock                = <span class="hljs-string">&quot;leases&quot;</span><br>)<br></code></pre></td></tr></table></figure><p>开始选举时需要通过那么在开始选举先需要<code>resourcelock.New</code>先通过方法 resourcelock.New 获取资源锁的对象。以kube-batch为例：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs golang">rl, err := resourcelock.New(resourcelock.ConfigMapsResourceLock,<br>opt.LockObjectNamespace,<br><span class="hljs-string">&quot;kube-batch&quot;</span>,<br>leaderElectionClient.CoreV1(),<br>leaderElectionClient.CoordinationV1(),<br>resourcelock.ResourceLockConfig&#123;<br>Identity:      id,<br>EventRecorder: eventRecorder,<br>&#125;)<br></code></pre></td></tr></table></figure><p>也可以通过<code>resourcelock.NewFromKubeconfig</code>的方法创建资源锁，该方法对 resourcelock.New 进行了封装。以control manager为例：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs golang">rl, err := resourcelock.NewFromKubeconfig(resourceLock,  <br>   c.ComponentConfig.Generic.LeaderElection.ResourceNamespace,  <br>   leaseName,  <br>   resourcelock.ResourceLockConfig&#123;  <br>      Identity:      lockIdentity,  <br>      EventRecorder: c.EventRecorder,  <br>   &#125;,  <br>   c.Kubeconfig,  <br>   c.ComponentConfig.Generic.LeaderElection.RenewDeadline.Duration)<br></code></pre></td></tr></table></figure><p>创建好资源锁后，通过<code>leaderelection.RunOrDie</code>启动选举：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs golang">leaderelection.RunOrDie(context.TODO(), leaderelection.LeaderElectionConfig&#123;<br>Lock:          rl,<br>LeaseDuration: leaseDuration,<br>RenewDeadline: renewDeadline,<br>RetryPeriod:   retryPeriod,<br>Callbacks: leaderelection.LeaderCallbacks&#123;<br>OnStartedLeading: run,<br>OnStoppedLeading: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>glog.Fatalf(<span class="hljs-string">&quot;leaderelection lost&quot;</span>)<br>&#125;,<br>&#125;,<br>&#125;)<br></code></pre></td></tr></table></figure><p>其中LeaseDuration为租约时长，非leader的candidate等待LeaseDuration后会强制重新选举；RenewDeadline为leader刷新资源锁超时时间；RetryPeriod为调用资源锁间隔。Callbacks的定义如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-keyword">type</span> LeaderCallbacks <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-comment">// OnStartedLeading is called when a LeaderElector client starts leading</span><br>OnStartedLeading <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(context.Context)</span></span><br><span class="hljs-comment">// OnStoppedLeading is called when a LeaderElector client stops leading</span><br>OnStoppedLeading <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span><br><span class="hljs-comment">// OnNewLeader is called when the client observes a leader that is</span><br><span class="hljs-comment">// not the previously observed leader. This includes the first observed</span><br><span class="hljs-comment">// leader when the client starts.</span><br>OnNewLeader <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(identity <span class="hljs-type">string</span>)</span></span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="选举主流程"><a href="#选举主流程" class="headerlink" title="选举主流程"></a>选举主流程</h2><p>启动选举后，RunOrDie 方法会调用 le.Run(ctx) 方法开始真正的选举流程，le.Run的接口实现为：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(le *LeaderElector)</span></span> Run(ctx context.Context) &#123;<br>  ......  <br>  <span class="hljs-comment">// 竞选获取锁，如果没有获取到，就一直等待</span><br>  <span class="hljs-keyword">if</span> !le.acquire(ctx) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-comment">// ctx signalled done</span><br>  &#125;<br>  ctx, cancel := context.WithCancel(ctx)<br>  <span class="hljs-keyword">defer</span> cancel()<br>  <span class="hljs-comment">// 获取到锁后，需要调用回调函数中的OnStartedLeading，运行controller的代码</span><br>  <span class="hljs-keyword">go</span> le.config.Callbacks.OnStartedLeading(ctx)<br>  <br>  <span class="hljs-comment">// 获取到锁后，需要不断地进行renew操作</span><br>  le.renew(ctx)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="竞选"><a href="#竞选" class="headerlink" title="竞选"></a>竞选</h3><p><code>le.acquire</code>竞选获取锁，如果没有获取到(即没有成为Leader)，则会一直等待。其实现为：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(le *LeaderElector)</span></span> acquire(ctx context.Context) <span class="hljs-type">bool</span> &#123;<br>ctx, cancel := context.WithCancel(ctx)<br><span class="hljs-keyword">defer</span> cancel()<br>succeeded := <span class="hljs-literal">false</span><br><span class="hljs-comment">// wait.JitterUntil间隔 RetryPeriod 执行一次</span><br>wait.JitterUntil(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 竞选</span><br>succeeded = le.tryAcquireOrRenew(ctx)<br><span class="hljs-comment">// leader 变化回调</span><br>le.maybeReportTransition()<br><span class="hljs-comment">// 竞选失败返回</span><br><span class="hljs-keyword">if</span> !succeeded &#123;<br>klog.V(<span class="hljs-number">4</span>).Infof(<span class="hljs-string">&quot;failed to acquire lease %v&quot;</span>, desc)<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-comment">// 成功则退出竞选函数</span><br>le.config.Lock.RecordEvent(<span class="hljs-string">&quot;became leader&quot;</span>)<br>le.metrics.leaderOn(le.config.Name)<br>klog.Infof(<span class="hljs-string">&quot;successfully acquired lease %v&quot;</span>, desc)<br>cancel()<br>&#125;, le.config.RetryPeriod, JitterFactor, <span class="hljs-literal">true</span>, ctx.Done())<br><span class="hljs-keyword">return</span> succeeded<br>&#125;<br></code></pre></td></tr></table></figure><p><code>wait.JitterUntil</code>间隔<code>RetryPeriod</code>执行一次, 若获取锁成功，则会调用ctx的cancel方法中止 wait.JitterUntil 循环。返回<code>succeeded</code>。<br>所以 acquire 函数只会有两种情况会返回：</p><ul><li>当选 leader；</li><li>ctx 被取消（外部要求中止选举流程）</li></ul><h3 id="抢锁"><a href="#抢锁" class="headerlink" title="抢锁"></a>抢锁</h3><p>candidate抢锁关键的实现在于tryAcquireOrRenew，而tryAcquireOrRenew就是依赖锁的状态转移机制完成核心逻辑。其实现为：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(le *LeaderElector)</span></span> tryAcquireOrRenew(ctx context.Context) <span class="hljs-type">bool</span> &#123;<br>  now := metav1.Now()<br>  leaderElectionRecord := rl.LeaderElectionRecord&#123;<br>    HolderIdentity:       le.config.Lock.Identity(),<br>    LeaseDurationSeconds: <span class="hljs-type">int</span>(le.config.LeaseDuration / time.Second),<br>    RenewTime:            now,<br>    AcquireTime:          now,<br>  &#125;<br>​<br>  <span class="hljs-comment">// 1. obtain or create the ElectionRecord</span><br>  <span class="hljs-comment">// 检查锁有没有</span><br>  oldLeaderElectionRecord, oldLeaderElectionRawRecord, err := le.config.Lock.Get(ctx)<br>  <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-comment">// 没有锁的资源，就创建一个</span><br>    <span class="hljs-keyword">if</span> !errors.IsNotFound(err) &#123;<br>      klog.Errorf(<span class="hljs-string">&quot;error retrieving resource lock %v: %v&quot;</span>, le.config.Lock.Describe(), err)<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> err = le.config.Lock.Create(ctx, leaderElectionRecord); err != <span class="hljs-literal">nil</span> &#123;<br>      klog.Errorf(<span class="hljs-string">&quot;error initially creating leader election record: %v&quot;</span>, err)<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br>    <span class="hljs-comment">//对外宣称自己成为了leader</span><br>    le.setObservedRecord(&amp;leaderElectionRecord)<br>​<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>  &#125;<br>​<br>  <span class="hljs-comment">// 2. Record obtained, check the Identity &amp; Time</span><br>  <span class="hljs-keyword">if</span> !bytes.Equal(le.observedRawRecord, oldLeaderElectionRawRecord) &#123;<br>    <span class="hljs-comment">// 这个机制很重要，会如果leader会不断正常renew这个锁，oldLeaderElectionRawRecord会一直发生变化，发生变化会更新le.observedTime</span><br>    le.setObservedRecord(oldLeaderElectionRecord)<br>    le.observedRawRecord = oldLeaderElectionRawRecord<br>  &#125;<br>  <br>  <span class="hljs-comment">// 如果还没超时并且此实例不是leader（leader是其他实例），那么就直接退出</span><br>  <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(oldLeaderElectionRecord.HolderIdentity) &gt; <span class="hljs-number">0</span> &amp;&amp;<br>    le.observedTime.Add(le.config.LeaseDuration).After(now.Time) &amp;&amp;<br>    !le.IsLeader() &#123;<br>    klog.V(<span class="hljs-number">4</span>).Infof(<span class="hljs-string">&quot;lock is held by %v and has not yet expired&quot;</span>, oldLeaderElectionRecord.HolderIdentity)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>  &#125;<br>​<br>  <span class="hljs-comment">// 3. We&#x27;re going to try to update. The leaderElectionRecord is set to it&#x27;s default</span><br>  <span class="hljs-comment">// here. Let&#x27;s correct it before updating.</span><br>  <span class="hljs-comment">// 如果是leader，就更新时间RenewTime，保证其他实例（非主）可以观察到：主还活着</span><br>  <span class="hljs-keyword">if</span> le.IsLeader() &#123;<br>    leaderElectionRecord.AcquireTime = oldLeaderElectionRecord.AcquireTime<br>    leaderElectionRecord.LeaderTransitions = oldLeaderElectionRecord.LeaderTransitions<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-comment">// 不是leader，那么锁就发生了转移</span><br>    leaderElectionRecord.LeaderTransitions = oldLeaderElectionRecord.LeaderTransitions + <span class="hljs-number">1</span><br>  &#125;<br>  <br>  <span class="hljs-comment">// 更新锁</span><br>  <span class="hljs-comment">// update the lock itself</span><br>  <span class="hljs-keyword">if</span> err = le.config.Lock.Update(ctx, leaderElectionRecord); err != <span class="hljs-literal">nil</span> &#123;<br>    klog.Errorf(<span class="hljs-string">&quot;Failed to update lock: %v&quot;</span>, err)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>  &#125;<br>​<br>  le.setObservedRecord(&amp;leaderElectionRecord)<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>tryAcquireOrRenew</code>的流程</p><ul><li>获取ElectionRecord对象。<ul><li>若ElectionRecord对象不存在，则创建新的ElectionRecord对象，创建成功后宣称成为Leader。</li><li>若ElectionRecord对象存在，则将获取的oldLeaderElectionRecord更新到该le(LeaderElector)的observedRecord缓存中。<ul><li>若observedRecord不是该le创建且未过期，获取锁失败，退出。</li><li>否则调用<code> le.config.Lock.Update(leaderElectionRecord)</code>使用该le(LeaderElector)的信息尝试更新 ElectionRecord对象，更新成功后宣称成为Leader。</li></ul></li></ul></li></ul><h4 id="选举原理"><a href="#选举原理" class="headerlink" title="选举原理"></a>选举原理</h4><p><code>tryAcquireOrRenew</code>的代码的核心逻辑主要为更新<code>le.observedTime</code>,更新的时机为：</p><ul><li>锁（ElectionRecord对象）不存在，创建锁成功时更新；</li><li>获取到锁记录和缓存的不同，说明上次尝试获取锁到现在的间隔内 leader 变化了，更新缓存；</li><li>leader 超期没续期且当前节点抢锁成功，更新缓存。</li></ul><p>如果锁对象不存在或者leader在任期时间内未更新锁对象，则该le会执行抢锁的逻辑，尝试成为新的leader。</p><h2 id="Leader续期"><a href="#Leader续期" class="headerlink" title="Leader续期"></a>Leader续期</h2><p>在获取到锁成为 leader 后，会进入 le.renew(ctx) 方法进行定期续期操作。其实现如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(le *LeaderElector)</span></span> renew(ctx context.Context) &#123;<br>ctx, cancel := context.WithCancel(ctx)<br><span class="hljs-keyword">defer</span> cancel()<br><span class="hljs-comment">// 定期续期，每 RetryPeriod 执行一次续期</span><br>wait.Until(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>timeoutCtx, timeoutCancel := context.WithTimeout(ctx, le.config.RenewDeadline)<br><span class="hljs-keyword">defer</span> timeoutCancel()<br><span class="hljs-comment">// 执行续期，直到成功或超时</span><br>err := wait.PollImmediateUntil(le.config.RetryPeriod, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> (<span class="hljs-type">bool</span>, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">return</span> le.tryAcquireOrRenew(timeoutCtx), <span class="hljs-literal">nil</span><br>&#125;, timeoutCtx.Done())<br><br>le.maybeReportTransition()<br>desc := le.config.Lock.Describe()<br><span class="hljs-comment">// 若renew成功，则Until会不断循环</span><br><span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &#123;<br>klog.V(<span class="hljs-number">5</span>).Infof(<span class="hljs-string">&quot;successfully renewed lease %v&quot;</span>, desc)<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-comment">// 若renew失败，引发超时错误，说明续期失败，退出续期流程</span><br>le.config.Lock.RecordEvent(<span class="hljs-string">&quot;stopped leading&quot;</span>)<br>le.metrics.leaderOff(le.config.Name)<br>klog.Infof(<span class="hljs-string">&quot;failed to renew lease %v: %v&quot;</span>, desc, err)<br>cancel()<br>&#125;, le.config.RetryPeriod, ctx.Done())<br><br><span class="hljs-comment">// if we hold the lease, give it up</span><br><span class="hljs-keyword">if</span> le.config.ReleaseOnCancel &#123;<br>le.release()<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>renew 方法如果在任期内续期失败则会退出续期循环，主流程结束，其它candidate会尝试成为新的leader。旧的leader若想重新参与竞选，则需要再次调用<code>leaderelection.RunOrDie</code>, Kubernetes的组件一般直接退出，通过重启Pod实现重新参与选举。</p>]]></content>
    
    
    <categories>
      
      <category>kubernetes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>kubernetes</tag>
      
      <tag>leader election</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kubelet详解</title>
    <link href="/2023/11/30/Kubelet%E8%AF%A6%E8%A7%A3/"/>
    <url>/2023/11/30/Kubelet%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h2 id="kubelet简介"><a href="#kubelet简介" class="headerlink" title="kubelet简介"></a>kubelet简介</h2><p><img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/06/15/20210613091144.png" alt="Kubernetes 的架构图"></p><p>kubelet 的功能介绍：</p><ul><li>kubelet 是每个 Node 节点上都运行的主要“节点代理”。使用如下的一个向 apiserver 注册 Node 节点：主机的 <code>hostname</code>；覆盖 <code>host</code> 的参数；或者云提供商指定的逻辑。</li><li>kubelet 基于 <code>PodSpec</code> 工作。<code>PodSpec</code> 是用 <code>YAML</code> 或者 <code>JSON</code> 对象来描述 Pod。Kubelet 接受通过各种机制（主要是 apiserver）提供的一组 <code>PodSpec</code>，并确保里面描述的容器良好运行。</li></ul><h2 id="kubelet-架构"><a href="#kubelet-架构" class="headerlink" title="kubelet 架构"></a>kubelet 架构</h2><p><img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/06/15/20210614215508.png" alt="2021-06-14-21-55-08"></p><h3 id="重要组件"><a href="#重要组件" class="headerlink" title="重要组件"></a>重要组件</h3><p>kubelet 的架构由 N 多的组件组成，下面简单介绍下比较重要的几个：</p><h4 id="PLEG"><a href="#PLEG" class="headerlink" title="[PLEG]"></a>[PLEG]</h4><p>即 <strong>Pod Lifecycle Event Generator</strong>，字面意思 Pod 生命周期事件（<code>ContainerStarted</code>、<code>ContainerDied</code>、<code>ContainerRemoved</code>、<code>ContainerChanged</code>）生成器。</p><p>其维护着 Pod 缓存；定期通过 <code>ContainerRuntime</code> 获取 Pod 的信息，与缓存中的信息比较，生成如上的事件；将事件写入其维护的通道（channel）中。</p><h4 id="PodWorkers"><a href="#PodWorkers" class="headerlink" title="[PodWorkers]"></a>[PodWorkers]</h4><p>处理事件中 Pod 的同步。核心方法 <code>managePodLoop()</code> 间接调用 <code>kubelet.syncPod()</code> 完成 Pod 的同步：</p><ul><li>如果 Pod 正在被创建，记录其延迟</li><li>生成 Pod 的 API Status，即 <code>v1.PodStatus</code>：从运行时的 status 转换成 api status</li><li>记录 Pod 从 <code>pending</code> 到 <code>running</code> 的耗时</li><li>在 <code>StatusManager</code> 中更新 pod 的状态</li><li>杀掉不应该运行的 Pod</li><li>如果网络插件未就绪，只启动使用了主机网络（host network）的 Pod</li><li>如果 static pod 不存在，为其创建镜像（Mirror）Pod</li><li>为 Pod 创建文件系统目录：Pod 目录、卷目录、插件目录</li><li>使用 <code>VolumeManager</code> 为 Pod 挂载卷</li><li>获取 image pull secrets</li><li>调用容器运行时（container runtime）的 <code>#SyncPod()</code> 方法</li></ul><h4 id="PodManager"><a href="#PodManager" class="headerlink" title="PodManager"></a><a href="https://atbug.com/kubelet-source-code-analysis/#podmanager">PodManager</a></h4><p>存储 Pod 的期望状态，kubelet 服务的不同渠道的 Pod</p><h4 id="StatsProvider"><a href="#StatsProvider" class="headerlink" title="StatsProvider"></a><a href="https://atbug.com/kubelet-source-code-analysis/#statsprovider">StatsProvider</a></h4><p>提供节点和容器的统计信息，有 <code>cAdvisor</code> 和 <code>CRI</code> 两种实现。</p><h4 id="ContainerRuntime"><a href="#ContainerRuntime" class="headerlink" title="ContainerRuntime"></a><a href="https://atbug.com/kubelet-source-code-analysis/#containerruntime">ContainerRuntime</a></h4><p>顾名思义，容器运行时。与遵循 CRI 规范的高级容器运行时进行交互。</p><h4 id="Deps-PodConfig"><a href="#Deps-PodConfig" class="headerlink" title="Deps.PodConfig"></a><a href="https://atbug.com/kubelet-source-code-analysis/#depspodconfig">Deps.PodConfig</a></h4><p>PodConfig 是一个配置多路复用器，它将许多 Pod 配置源合并成一个单一的一致结构，然后按顺序向监听器传递增量变更通知。</p><p>配置源有：文件、apiserver、HTTP</p><h4 id="SyncLoop"><a href="#SyncLoop" class="headerlink" title="SyncLoop"></a><a href="https://atbug.com/kubelet-source-code-analysis/#syncloop">SyncLoop</a></h4><p>接收来自 <code>PodConfig</code> 的 Pod 变更通知、定时任务、<code>PLEG</code> 的事件，以及 <code>ProbeManager</code> 的事件，将 Pod 同步到<strong>期望状态</strong>。</p><h4 id="PodAdmitHandlers"><a href="#PodAdmitHandlers" class="headerlink" title="PodAdmitHandlers"></a><a href="https://atbug.com/kubelet-source-code-analysis/#podadmithandlers">PodAdmitHandlers</a></h4><p>Pod admission 过程中调用的一系列处理器，比如 eviction handler（节点内存有压力时，不会驱逐 QoS 设置为 <code>BestEffort</code> 的 Pod）、shutdown admit handler（当节点关闭时，不处理 pod 的同步操作）等。</p><h4 id="OOMWatcher"><a href="#OOMWatcher" class="headerlink" title="OOMWatcher"></a><a href="https://atbug.com/kubelet-source-code-analysis/#oomwatcher">OOMWatcher</a></h4><p>从系统日志中获取容器的 OOM 日志，将其封装成事件并记录。</p><h4 id="VolumeManger"><a href="#VolumeManger" class="headerlink" title="VolumeManger"></a><a href="https://atbug.com/kubelet-source-code-analysis/#volumemanger">VolumeManger</a></h4><p>VolumeManager 运行一组异步循环，根据在此节点上调度的 pod 确定需要附加&#x2F;挂载&#x2F;卸载&#x2F;分离哪些卷并执行操作。</p><h4 id="CertificateManager"><a href="#CertificateManager" class="headerlink" title="CertificateManager"></a><a href="https://atbug.com/kubelet-source-code-analysis/#certificatemanager">CertificateManager</a></h4><p>处理证书轮换。</p><h4 id="ProbeManager"><a href="#ProbeManager" class="headerlink" title="ProbeManager"></a><a href="https://atbug.com/kubelet-source-code-analysis/#probemanager">ProbeManager</a></h4><p>实际上包含了三种 Probe，提供 probe 结果缓存和通道。</p><ul><li>LivenessManager</li><li>ReadinessManager</li><li>StartupManager</li></ul><h4 id="EvictionManager"><a href="#EvictionManager" class="headerlink" title="EvictionManager"></a><a href="https://atbug.com/kubelet-source-code-analysis/#evictionmanager">EvictionManager</a></h4><p>监控 Node 节点的资源占用情况，根据驱逐规则驱逐 Pod 释放资源，缓解节点的压力。</p><h4 id="PluginManager"><a href="#PluginManager" class="headerlink" title="PluginManager"></a><a href="https://atbug.com/kubelet-source-code-analysis/#pluginmanager">PluginManager</a></h4><p>PluginManager 运行一组异步循环，根据此节点确定哪些插件需要注册&#x2F;取消注册并执行。如 CSI 驱动和设备管理器插件（Device Plugin）。</p><h5 id="CSI"><a href="#CSI" class="headerlink" title="CSI"></a><a href="https://atbug.com/kubelet-source-code-analysis/#csi">CSI</a></h5><p>Container Storage Interface，由存储厂商实现的存储驱动。</p><h5 id="设备管理器插件（Device-Plugin）"><a href="#设备管理器插件（Device-Plugin）" class="headerlink" title="设备管理器插件（Device Plugin）"></a><a href="https://atbug.com/kubelet-source-code-analysis/#%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86%E5%99%A8%E6%8F%92%E4%BB%B6device-plugin">设备管理器插件（Device Plugin）</a></h5><p>Kubernetes 提供了一个 设备插件框架，你可以用它来将系统硬件资源发布到 Kubelet。</p><p>供应商可以实现设备插件，由你手动部署或作为 DaemonSet 来部署，而不必定制 Kubernetes 本身的代码。目标设备包括 GPU、高性能 NIC、FPGA、 InfiniBand 适配器以及其他类似的、可能需要特定于供应商的初始化和设置的计算资源。</p><h2 id="kubelet-的启动流程"><a href="#kubelet-的启动流程" class="headerlink" title="kubelet 的启动流程"></a><a href="https://atbug.com/kubelet-source-code-analysis/#kubelet-%E7%9A%84%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B">kubelet 的启动流程</a></h2><p>要分析 kubelet 的启动流程，可以从 kubelet 运行方式着手。找一个 Node 节点，很容易就能找到 kubelet 的进程。由于其是以 <code>systemd</code> 的方式启动，也可以通过 <code>systemctl</code> 查看其状态。</p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a><a href="https://atbug.com/kubelet-source-code-analysis/#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90">源码分析</a></h3><p>从 <code>git@github.com:kubernetes/kubernetes.git</code> 仓库获取代码，使用最新的 <code>release-1.21</code> 分支。</p><ul><li><code>cmd/kubelet/kubelet.go:35</code> 的 <code>main</code> 方法为程序入口。<ul><li>调用 <code>NewKubeletCommand</code> 方法，创建 command</li><li>执行 command<ul><li><code>cmd/kubelet/app/server.go:434</code> 的 <code>Run</code> 方法。<ul><li>调用 <code>RunKubelet</code> 方法。<ul><li>调用 <code>createAndInitKubelet</code> 方法，创建并初始化 kubelet<ul><li><code>pkg/kubelet/kubelet.go</code> 的 <code>NewMainKubelet</code> 方法，创建 kubelet的 各种组件。共十几个组件，见 <a href="https://atbug.com/kubelet-source-code-analysis/#kubelet-%E6%9E%B6%E6%9E%84">kubelet 的构架</a>。</li><li>调用 <code>BirtyCry</code> 方法：放出 <code>Starting</code> 事件</li><li>调用 <code>StartGarbageCollection</code> 方法，开启 <code>ContainerGC</code> 和 <code>ImageGC</code></li></ul></li><li>调用 <code>startKubelet</code> 方法（大量使用 goroutine 和通道）<ul><li>goroutine：<code>kubelet.Run()</code><ul><li>初始化模块<ul><li>metrics 相关</li><li>创建文件系统目录目录</li><li>创建容器日志目录</li><li>启动 <code>ImageGCManager</code></li><li>启动 <code>ServerCertificateManager</code></li><li>启动 <code>OOMWatcher</code></li><li>启动 <code>ResourceAnalyzer</code></li></ul></li><li>goroutine：<code>VolumeManager.Run()</code> 开始处理 Pod Volume 的卸载和挂载</li><li>goroutine：状态更新 <code>fastStatusUpdateOnce()</code> （更新 Pod CIDR -&gt; 更新 <code>ContainerRuntime</code> 状态 -&gt; 更新 Node 节点状态）</li><li>goroutine： <code>NodeLeaseController.Run()</code> 更新节点租约</li><li>goroutine：<code>podKiller.PerformPodKillingWork</code> 杀掉未被正确处理的 pod</li><li><code>StatusManager.Start()</code> 开始向 apiserver 更新 Pod 状态</li><li><code>RuntimeClassManager.Start()</code></li><li><code>PLEG.Start()</code>：持续从 <code>ContainerRuntime</code> 获取 Pod&#x2F;容器的状态，并与 kubelet 本地 cache 中的比较，生成对应的 <code>Event</code></li><li><code>syncLoop()</code> 重点，**<em>持续监控并处理来自文件、apiserver、http 的变更</em>**。包括 Pod 的增加、更新、优雅删除、非优雅删除、调和。</li></ul></li></ul></li></ul></li><li>启动 server，暴露 <code>/healthz</code> 端点</li><li>通知 <code>systemd</code> <code>kuberlet</code> 服务已经启动</li></ul></li></ul></li></ul></li></ul><h2 id="kubelet-的工作原理"><a href="#kubelet-的工作原理" class="headerlink" title="kubelet 的工作原理"></a><a href="https://atbug.com/kubelet-source-code-analysis/#kubelet-%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86">kubelet 的工作原理</a></h2><p><img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/06/15/20210615000611.png"></p><ol><li>静态文件、apiserver 以及 HTTP 请求的 Pod 配置变更，被发送到 <code>kubelet.syncLoop</code></li><li>PLEG 会定期通过容器运行时获取节点上 Pod 的状态，与其缓存中的 Pod 信息进行比较，封装成事件，进入 PLEG 的通道</li><li>定期检查工作队列中的 Pod</li><li>ProbeManager 的通道中的 Pod</li><li>以上 1~4，都会进入 <code>syncLoopIteration</code>，并从对应的通道中获取到对应 Pod，将 Pod 的信息保存到 <code>PodManager</code>；然后分发给 <code>PodWorker</code>，[完成一些列的同步工作]</li></ol><p>转载自：<a href="https://atbug.com/kubelet-source-code-analysis/#syncloop">https://atbug.com/kubelet-source-code-analysis/#syncloop</a></p>]]></content>
    
    
    <categories>
      
      <category>kubernetes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>kubernetes</tag>
      
      <tag>kubelet</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kubelet详解（一）- Kubelet启动流程</title>
    <link href="/2023/11/30/Kubelet%E8%AF%A6%E8%A7%A3%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2023/11/30/Kubelet%E8%AF%A6%E8%A7%A3%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="kubelet简介"><a href="#kubelet简介" class="headerlink" title="kubelet简介"></a>kubelet简介</h2><p><img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/06/15/20210613091144.png" alt="Kubernetes 的架构图"></p><p>kubelet 的功能介绍：</p><ul><li>kubelet 是每个 Node 节点上都运行的主要“节点代理”。使用如下的一个向 apiserver 注册 Node 节点：主机的 <code>hostname</code>；覆盖 <code>host</code> 的参数；或者云提供商指定的逻辑。</li><li>kubelet 基于 <code>PodSpec</code> 工作。<code>PodSpec</code> 是用 <code>YAML</code> 或者 <code>JSON</code> 对象来描述 Pod。Kubelet 接受通过各种机制（主要是 apiserver）提供的一组 <code>PodSpec</code>，并确保里面描述的容器良好运行。</li></ul><h2 id="kubelet-架构"><a href="#kubelet-架构" class="headerlink" title="kubelet 架构"></a>kubelet 架构</h2><p><img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/06/15/20210614215508.png" alt="2021-06-14-21-55-08"></p><h3 id="重要组件"><a href="#重要组件" class="headerlink" title="重要组件"></a>重要组件</h3><p>kubelet 的架构由 N 多的组件组成，下面简单介绍下比较重要的几个：</p><h4 id="PLEG"><a href="#PLEG" class="headerlink" title="[PLEG]"></a>[PLEG]</h4><p>即 <strong>Pod Lifecycle Event Generator</strong>，字面意思 Pod 生命周期事件（<code>ContainerStarted</code>、<code>ContainerDied</code>、<code>ContainerRemoved</code>、<code>ContainerChanged</code>）生成器。</p><p>其维护着 Pod 缓存；定期通过 <code>ContainerRuntime</code> 获取 Pod 的信息，与缓存中的信息比较，生成如上的事件；将事件写入其维护的通道（channel）中。</p><h4 id="PodWorkers"><a href="#PodWorkers" class="headerlink" title="[PodWorkers]"></a>[PodWorkers]</h4><p>处理事件中 Pod 的同步。核心方法 <code>managePodLoop()</code> 间接调用 <code>kubelet.syncPod()</code> 完成 Pod 的同步：</p><ul><li>如果 Pod 正在被创建，记录其延迟</li><li>生成 Pod 的 API Status，即 <code>v1.PodStatus</code>：从运行时的 status 转换成 api status</li><li>记录 Pod 从 <code>pending</code> 到 <code>running</code> 的耗时</li><li>在 <code>StatusManager</code> 中更新 pod 的状态</li><li>杀掉不应该运行的 Pod</li><li>如果网络插件未就绪，只启动使用了主机网络（host network）的 Pod</li><li>如果 static pod 不存在，为其创建镜像（Mirror）Pod</li><li>为 Pod 创建文件系统目录：Pod 目录、卷目录、插件目录</li><li>使用 <code>VolumeManager</code> 为 Pod 挂载卷</li><li>获取 image pull secrets</li><li>调用容器运行时（container runtime）的 <code>#SyncPod()</code> 方法</li></ul><h4 id="PodManager"><a href="#PodManager" class="headerlink" title="PodManager"></a><a href="https://atbug.com/kubelet-source-code-analysis/#podmanager">PodManager</a></h4><p>存储 Pod 的期望状态，kubelet 服务的不同渠道的 Pod</p><h4 id="StatsProvider"><a href="#StatsProvider" class="headerlink" title="StatsProvider"></a><a href="https://atbug.com/kubelet-source-code-analysis/#statsprovider">StatsProvider</a></h4><p>提供节点和容器的统计信息，有 <code>cAdvisor</code> 和 <code>CRI</code> 两种实现。</p><h4 id="ContainerRuntime"><a href="#ContainerRuntime" class="headerlink" title="ContainerRuntime"></a><a href="https://atbug.com/kubelet-source-code-analysis/#containerruntime">ContainerRuntime</a></h4><p>顾名思义，容器运行时。与遵循 CRI 规范的高级容器运行时进行交互。</p><h4 id="Deps-PodConfig"><a href="#Deps-PodConfig" class="headerlink" title="Deps.PodConfig"></a><a href="https://atbug.com/kubelet-source-code-analysis/#depspodconfig">Deps.PodConfig</a></h4><p>PodConfig 是一个配置多路复用器，它将许多 Pod 配置源合并成一个单一的一致结构，然后按顺序向监听器传递增量变更通知。</p><p>配置源有：文件、apiserver、HTTP</p><h4 id="SyncLoop"><a href="#SyncLoop" class="headerlink" title="SyncLoop"></a><a href="https://atbug.com/kubelet-source-code-analysis/#syncloop">SyncLoop</a></h4><p>接收来自 <code>PodConfig</code> 的 Pod 变更通知、定时任务、<code>PLEG</code> 的事件，以及 <code>ProbeManager</code> 的事件，将 Pod 同步到<strong>期望状态</strong>。</p><h4 id="PodAdmitHandlers"><a href="#PodAdmitHandlers" class="headerlink" title="PodAdmitHandlers"></a><a href="https://atbug.com/kubelet-source-code-analysis/#podadmithandlers">PodAdmitHandlers</a></h4><p>Pod admission 过程中调用的一系列处理器，比如 eviction handler（节点内存有压力时，不会驱逐 QoS 设置为 <code>BestEffort</code> 的 Pod）、shutdown admit handler（当节点关闭时，不处理 pod 的同步操作）等。</p><h4 id="OOMWatcher"><a href="#OOMWatcher" class="headerlink" title="OOMWatcher"></a><a href="https://atbug.com/kubelet-source-code-analysis/#oomwatcher">OOMWatcher</a></h4><p>从系统日志中获取容器的 OOM 日志，将其封装成事件并记录。</p><h4 id="VolumeManger"><a href="#VolumeManger" class="headerlink" title="VolumeManger"></a><a href="https://atbug.com/kubelet-source-code-analysis/#volumemanger">VolumeManger</a></h4><p>VolumeManager 运行一组异步循环，根据在此节点上调度的 pod 确定需要附加&#x2F;挂载&#x2F;卸载&#x2F;分离哪些卷并执行操作。</p><h4 id="CertificateManager"><a href="#CertificateManager" class="headerlink" title="CertificateManager"></a><a href="https://atbug.com/kubelet-source-code-analysis/#certificatemanager">CertificateManager</a></h4><p>处理证书轮换。</p><h4 id="ProbeManager"><a href="#ProbeManager" class="headerlink" title="ProbeManager"></a><a href="https://atbug.com/kubelet-source-code-analysis/#probemanager">ProbeManager</a></h4><p>实际上包含了三种 Probe，提供 probe 结果缓存和通道。</p><ul><li>LivenessManager</li><li>ReadinessManager</li><li>StartupManager</li></ul><h4 id="EvictionManager"><a href="#EvictionManager" class="headerlink" title="EvictionManager"></a><a href="https://atbug.com/kubelet-source-code-analysis/#evictionmanager">EvictionManager</a></h4><p>监控 Node 节点的资源占用情况，根据驱逐规则驱逐 Pod 释放资源，缓解节点的压力。</p><h4 id="PluginManager"><a href="#PluginManager" class="headerlink" title="PluginManager"></a><a href="https://atbug.com/kubelet-source-code-analysis/#pluginmanager">PluginManager</a></h4><p>PluginManager 运行一组异步循环，根据此节点确定哪些插件需要注册&#x2F;取消注册并执行。如 CSI 驱动和设备管理器插件（Device Plugin）。</p><h5 id="CSI"><a href="#CSI" class="headerlink" title="CSI"></a><a href="https://atbug.com/kubelet-source-code-analysis/#csi">CSI</a></h5><p>Container Storage Interface，由存储厂商实现的存储驱动。</p><h5 id="设备管理器插件（Device-Plugin）"><a href="#设备管理器插件（Device-Plugin）" class="headerlink" title="设备管理器插件（Device Plugin）"></a><a href="https://atbug.com/kubelet-source-code-analysis/#%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86%E5%99%A8%E6%8F%92%E4%BB%B6device-plugin">设备管理器插件（Device Plugin）</a></h5><p>Kubernetes 提供了一个 设备插件框架，你可以用它来将系统硬件资源发布到 Kubelet。</p><p>供应商可以实现设备插件，由你手动部署或作为 DaemonSet 来部署，而不必定制 Kubernetes 本身的代码。目标设备包括 GPU、高性能 NIC、FPGA、 InfiniBand 适配器以及其他类似的、可能需要特定于供应商的初始化和设置的计算资源。</p><h2 id="kubelet-的启动流程"><a href="#kubelet-的启动流程" class="headerlink" title="kubelet 的启动流程"></a><a href="https://atbug.com/kubelet-source-code-analysis/#kubelet-%E7%9A%84%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B">kubelet 的启动流程</a></h2><p>要分析 kubelet 的启动流程，可以从 kubelet 运行方式着手。找一个 Node 节点，很容易就能找到 kubelet 的进程。由于其是以 <code>systemd</code> 的方式启动，也可以通过 <code>systemctl</code> 查看其状态。</p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a><a href="https://atbug.com/kubelet-source-code-analysis/#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90">源码分析</a></h3><p>从 <code>git@github.com:kubernetes/kubernetes.git</code> 仓库获取代码，使用最新的 <code>release-1.21</code> 分支。</p><ul><li><code>cmd/kubelet/kubelet.go:35</code> 的 <code>main</code> 方法为程序入口。<ul><li>调用 <code>NewKubeletCommand</code> 方法，创建 command</li><li>执行 command<ul><li><code>cmd/kubelet/app/server.go:434</code> 的 <code>Run</code> 方法。<ul><li>调用 <code>RunKubelet</code> 方法。<ul><li>调用 <code>createAndInitKubelet</code> 方法，创建并初始化 kubelet<ul><li><code>pkg/kubelet/kubelet.go</code> 的 <code>NewMainKubelet</code> 方法，创建 kubelet的 各种组件。共十几个组件，见 <a href="https://atbug.com/kubelet-source-code-analysis/#kubelet-%E6%9E%B6%E6%9E%84">kubelet 的构架</a>。</li><li>调用 <code>BirtyCry</code> 方法：放出 <code>Starting</code> 事件</li><li>调用 <code>StartGarbageCollection</code> 方法，开启 <code>ContainerGC</code> 和 <code>ImageGC</code></li></ul></li><li>调用 <code>startKubelet</code> 方法（大量使用 goroutine 和通道）<ul><li>goroutine：<code>kubelet.Run()</code><ul><li>初始化模块<ul><li>metrics 相关</li><li>创建文件系统目录目录</li><li>创建容器日志目录</li><li>启动 <code>ImageGCManager</code></li><li>启动 <code>ServerCertificateManager</code></li><li>启动 <code>OOMWatcher</code></li><li>启动 <code>ResourceAnalyzer</code></li></ul></li><li>goroutine：<code>VolumeManager.Run()</code> 开始处理 Pod Volume 的卸载和挂载</li><li>goroutine：状态更新 <code>fastStatusUpdateOnce()</code> （更新 Pod CIDR -&gt; 更新 <code>ContainerRuntime</code> 状态 -&gt; 更新 Node 节点状态）</li><li>goroutine： <code>NodeLeaseController.Run()</code> 更新节点租约</li><li>goroutine：<code>podKiller.PerformPodKillingWork</code> 杀掉未被正确处理的 pod</li><li><code>StatusManager.Start()</code> 开始向 apiserver 更新 Pod 状态</li><li><code>RuntimeClassManager.Start()</code></li><li><code>PLEG.Start()</code>：持续从 <code>ContainerRuntime</code> 获取 Pod&#x2F;容器的状态，并与 kubelet 本地 cache 中的比较，生成对应的 <code>Event</code></li><li><code>syncLoop()</code> 重点，**<em>持续监控并处理来自文件、apiserver、http 的变更</em>**。包括 Pod 的增加、更新、优雅删除、非优雅删除、调和。</li></ul></li></ul></li></ul></li><li>启动 server，暴露 <code>/healthz</code> 端点</li><li>通知 <code>systemd</code> <code>kuberlet</code> 服务已经启动</li></ul></li></ul></li></ul></li></ul><h2 id="kubelet-的工作原理"><a href="#kubelet-的工作原理" class="headerlink" title="kubelet 的工作原理"></a><a href="https://atbug.com/kubelet-source-code-analysis/#kubelet-%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86">kubelet 的工作原理</a></h2><p><img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/06/15/20210615000611.png"></p><ol><li>静态文件、apiserver 以及 HTTP 请求的 Pod 配置变更，被发送到 <code>kubelet.syncLoop</code></li><li>PLEG 会定期通过容器运行时获取节点上 Pod 的状态，与其缓存中的 Pod 信息进行比较，封装成事件，进入 PLEG 的通道</li><li>定期检查工作队列中的 Pod</li><li>ProbeManager 的通道中的 Pod</li><li>以上 1~4，都会进入 <code>syncLoopIteration</code>，并从对应的通道中获取到对应 Pod，将 Pod 的信息保存到 <code>PodManager</code>；然后分发给 <code>PodWorker</code>，[完成一些列的同步工作]</li></ol><p>转载自：<a href="https://atbug.com/kubelet-source-code-analysis/#syncloop">https://atbug.com/kubelet-source-code-analysis/#syncloop</a></p>]]></content>
    
    
    <categories>
      
      <category>kubernetes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>kubernetes</tag>
      
      <tag>kubelet</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Containerd详解</title>
    <link href="/2023/11/30/Containerd%E8%AF%A6%E8%A7%A3/"/>
    <url>/2023/11/30/Containerd%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p>containerd 是一个工业级标准的容器运行时，它强调<strong>简单性</strong>、<strong>健壮性</strong>和<strong>可移植性</strong>，containerd 可以负责干下面这些事情：</p><ul><li>管理容器的生命周期（从创建容器到销毁容器）</li><li>拉取&#x2F;推送容器镜像</li><li>存储管理（管理镜像及容器数据的存储）</li><li>调用 runc 运行容器（与 runc 等容器运行时交互）</li><li>管理容器网络接口及网络</li></ul><h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><p>containerd 可用作 Linux 和 Windows 的守护程序，它管理其主机系统完整的容器生命周期，从镜像传输和存储到容器执行和监测，再到底层存储到网络附件等等。</p><p><img src="https://picdn.youdianzhishi.com/images/20210810134700.png" alt="containerd 架构"></p><p>上图是 containerd 官方提供的架构图，可以看出 containerd 采用的也是 C&#x2F;S 架构，服务端通过 unix domain socket 暴露低层的 gRPC API 接口出去，客户端通过这些 API 管理节点上的容器，每个 containerd 只负责一台机器，Pull 镜像，对容器的操作（启动、停止等），网络，存储都是由 containerd 完成。具体运行容器由 runc 负责，实际上只要是符合 OCI 规范的容器都可以支持。</p><p>为了解耦，containerd 将系统划分成了不同的组件，每个组件都由一个或多个模块协作完成（Core 部分），每一种类型的模块都以插件的形式集成到 Containerd 中，而且插件之间是相互依赖的，例如，上图中的每一个长虚线的方框都表示一种类型的插件，包括 Service Plugin、Metadata Plugin、GC Plugin、Runtime Plugin 等，其中 Service Plugin 又会依赖 Metadata Plugin、GC Plugin 和 Runtime Plugin。每一个小方框都表示一个细分的插件，例如 Metadata Plugin 依赖 Containers Plugin、Content Plugin 等。比如:</p><ul><li><code>Content Plugin</code>: 提供对镜像中可寻址内容的访问，所有不可变的内容都被存储在这里。</li><li><code>Snapshot Plugin</code>: 用来管理容器镜像的文件系统快照，镜像中的每一层都会被解压成文件系统快照，类似于 Docker 中的 graphdriver。</li></ul><p>总体来看 containerd 可以分为三个大块：Storage、Metadata 和 Runtime。</p><p><img src="https://picdn.youdianzhishi.com/images/20210810145929.png" alt="containerd 架构2"></p><h2 id="contained安装与使用"><a href="#contained安装与使用" class="headerlink" title="contained安装与使用"></a>contained安装与使用</h2><p>这里我使用的系统是 <code>Linux Mint 20.2</code>，首先需要安装 <code>seccomp</code> 依赖：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">➜  ~ apt-get update<br>➜  ~ apt-get install libseccomp2 -y<br></code></pre></td></tr></table></figure><p>由于 containerd 需要调用 runc，所以我们也需要先安装 runc，不过 containerd 提供了一个包含相关依赖的压缩包 <code>cri-containerd-cni-$&#123;VERSION&#125;.$&#123;OS&#125;-$&#123;ARCH&#125;.tar.gz</code>，可以直接使用这个包来进行安装。首先从 <a href="https://github.com/containerd/containerd/releases">release 页面</a>下载最新版本的压缩包，当前为 1.5.5 版本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">➜  ~ wget https://github.com/containerd/containerd/releases/download/v1.5.5/cri-containerd-cni-1.5.5-linux-amd64.tar.gz<br><span class="hljs-meta prompt_"># </span><span class="language-bash">如果有限制，也可以替换成下面的 URL 加速下载</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">wget https://download.fastgit.org/containerd/containerd/releases/download/v1.5.5/cri-containerd-cni-1.5.5-linux-amd64.tar.gz</span><br></code></pre></td></tr></table></figure><p>可以通过 tar 的 <code>-t</code> 选项直接看到压缩包中包含哪些文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs shell">➜  ~ tar -tf cri-containerd-cni-1.4.3-linux-amd64.tar.gz<br>etc/<br>etc/cni/<br>etc/cni/net.d/<br>etc/cni/net.d/10-containerd-net.conflist<br>etc/crictl.yaml<br>etc/systemd/<br>etc/systemd/system/<br>etc/systemd/system/containerd.service<br>usr/<br>usr/local/<br>usr/local/bin/<br>usr/local/bin/containerd-shim-runc-v2<br>usr/local/bin/ctr<br>usr/local/bin/containerd-shim<br>usr/local/bin/containerd-shim-runc-v1<br>usr/local/bin/crictl<br>usr/local/bin/critest<br>usr/local/bin/containerd<br>usr/local/sbin/<br>usr/local/sbin/runc<br>opt/<br>opt/cni/<br>opt/cni/bin/<br>opt/cni/bin/vlan<br>opt/cni/bin/host-local<br>opt/cni/bin/flannel<br>opt/cni/bin/bridge<br>opt/cni/bin/host-device<br>opt/cni/bin/tuning<br>opt/cni/bin/firewall<br>opt/cni/bin/bandwidth<br>opt/cni/bin/ipvlan<br>opt/cni/bin/sbr<br>opt/cni/bin/dhcp<br>opt/cni/bin/portmap<br>opt/cni/bin/ptp<br>opt/cni/bin/static<br>opt/cni/bin/macvlan<br>opt/cni/bin/loopback<br>opt/containerd/<br>opt/containerd/cluster/<br>opt/containerd/cluster/version<br>opt/containerd/cluster/gce/<br>opt/containerd/cluster/gce/cni.template<br>opt/containerd/cluster/gce/configure.sh<br>opt/containerd/cluster/gce/cloud-init/<br>opt/containerd/cluster/gce/cloud-init/master.yaml<br>opt/containerd/cluster/gce/cloud-init/node.yaml<br>opt/containerd/cluster/gce/env<br></code></pre></td></tr></table></figure><p>直接将压缩包解压到系统的各个目录中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">➜  ~ tar -C / -xzf cri-containerd-cni-1.5.5-linux-amd64.tar.gz<br></code></pre></td></tr></table></figure><p>当然要记得将 <code>/usr/local/bin</code> 和 <code>/usr/local/sbin</code> 追加到 <code>~/.bashrc</code> 文件的 <code>PATH</code> 环境变量中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">export PATH=$PATH:/usr/local/bin:/usr/local/sbin<br></code></pre></td></tr></table></figure><p>然后执行下面的命令使其立即生效：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">➜  ~ source ~/.bashrc<br></code></pre></td></tr></table></figure><p>containerd 的默认配置文件为 <code>/etc/containerd/config.toml</code>，我们可以通过如下所示的命令生成一个默认的配置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">➜  ~ mkdir /etc/containerd<br>➜  ~ containerd config default &gt; /etc/containerd/config.toml<br></code></pre></td></tr></table></figure><p>由于上面我们下在的 containerd 压缩包中包含一个 <code>etc/systemd/system/containerd.service</code> 的文件，这样我们就可以通过 systemd 来配置 containerd 作为守护进程运行了，内容如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs shell">➜  ~ cat /etc/systemd/system/containerd.service<br>[Unit]<br>Description=containerd container runtime<br>Documentation=https://containerd.io<br>After=network.target local-fs.target<br><br>[Service]<br>ExecStartPre=-/sbin/modprobe overlay<br>ExecStart=/usr/local/bin/containerd<br><br>Type=notify<br>Delegate=yes<br>KillMode=process<br>Restart=always<br>RestartSec=5<br><span class="hljs-meta prompt_"># </span><span class="language-bash">Having non-zero Limit*s causes performance problems due to accounting overhead</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-keyword">in</span> the kernel. We recommend using cgroups to <span class="hljs-keyword">do</span> container-local accounting.</span><br>LimitNPROC=infinity<br>LimitCORE=infinity<br>LimitNOFILE=1048576<br><span class="hljs-meta prompt_"># </span><span class="language-bash">Comment TasksMax <span class="hljs-keyword">if</span> your systemd version does not supports it.</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Only systemd 226 and above support this version.</span><br>TasksMax=infinity<br>OOMScoreAdjust=-999<br><br>[Install]<br>WantedBy=multi-user.target<br></code></pre></td></tr></table></figure><p>这里有两个重要的参数：</p><ul><li><p><code>Delegate</code>: 这个选项允许 containerd 以及运行时自己管理自己创建容器的 cgroups。如果不设置这个选项，systemd 就会将进程移到自己的 cgroups 中，从而导致 containerd 无法正确获取容器的资源使用情况。</p></li><li><p><code>KillMode</code>: 这个选项用来处理 containerd 进程被杀死的方式。默认情况下，systemd 会在进程的 cgroup 中查找并杀死 containerd 的所有子进程。KillMode 字段可以设置的值如下。</p><ul><li><code>control-group</code>（默认值）：当前控制组里面的所有子进程，都会被杀掉</li><li><code>process</code>：只杀主进程</li><li><code>mixed</code>：主进程将收到 SIGTERM 信号，子进程收到 SIGKILL 信号</li><li><code>none</code>：没有进程会被杀掉，只是执行服务的 stop 命令</li></ul></li></ul><p>我们需要将 KillMode 的值设置为 process，这样可以确保升级或重启 containerd 时不杀死现有的容器。</p><p>现在我们就可以启动 containerd 了，直接执行下面的命令即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">➜  ~ systemctl enable containerd --now<br></code></pre></td></tr></table></figure><p>启动完成后就可以使用 containerd 的本地 CLI 工具 <code>ctr</code> 了，比如查看版本：</p><p><img src="https://picdn.youdianzhishi.com/images/20210810164519.png" alt="ctr version"></p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>我们首先来查看下上面默认生成的配置文件 <code>/etc/containerd/config.toml</code>：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br></pre></td><td class="code"><pre><code class="hljs toml"><span class="hljs-attr">disabled_plugins</span> = []<br><span class="hljs-attr">imports</span> = []<br><span class="hljs-attr">oom_score</span> = <span class="hljs-number">0</span><br><span class="hljs-attr">plugin_dir</span> = <span class="hljs-string">&quot;&quot;</span><br><span class="hljs-attr">required_plugins</span> = []<br><span class="hljs-attr">root</span> = <span class="hljs-string">&quot;/var/lib/containerd&quot;</span><br><span class="hljs-attr">state</span> = <span class="hljs-string">&quot;/run/containerd&quot;</span><br><span class="hljs-attr">version</span> = <span class="hljs-number">2</span><br><br><span class="hljs-section">[cgroup]</span><br>  <span class="hljs-attr">path</span> = <span class="hljs-string">&quot;&quot;</span><br><br><span class="hljs-section">[debug]</span><br>  <span class="hljs-attr">address</span> = <span class="hljs-string">&quot;&quot;</span><br>  <span class="hljs-attr">format</span> = <span class="hljs-string">&quot;&quot;</span><br>  <span class="hljs-attr">gid</span> = <span class="hljs-number">0</span><br>  <span class="hljs-attr">level</span> = <span class="hljs-string">&quot;&quot;</span><br>  <span class="hljs-attr">uid</span> = <span class="hljs-number">0</span><br><br><span class="hljs-section">[grpc]</span><br>  <span class="hljs-attr">address</span> = <span class="hljs-string">&quot;/run/containerd/containerd.sock&quot;</span><br>  <span class="hljs-attr">gid</span> = <span class="hljs-number">0</span><br>  <span class="hljs-attr">max_recv_message_size</span> = <span class="hljs-number">16777216</span><br>  <span class="hljs-attr">max_send_message_size</span> = <span class="hljs-number">16777216</span><br>  <span class="hljs-attr">tcp_address</span> = <span class="hljs-string">&quot;&quot;</span><br>  <span class="hljs-attr">tcp_tls_cert</span> = <span class="hljs-string">&quot;&quot;</span><br>  <span class="hljs-attr">tcp_tls_key</span> = <span class="hljs-string">&quot;&quot;</span><br>  <span class="hljs-attr">uid</span> = <span class="hljs-number">0</span><br><br><span class="hljs-section">[metrics]</span><br>  <span class="hljs-attr">address</span> = <span class="hljs-string">&quot;&quot;</span><br>  <span class="hljs-attr">grpc_histogram</span> = <span class="hljs-literal">false</span><br><br><span class="hljs-section">[plugins]</span><br><br>  <span class="hljs-section">[plugins.&quot;io.containerd.gc.v1.scheduler&quot;]</span><br>    <span class="hljs-attr">deletion_threshold</span> = <span class="hljs-number">0</span><br>    <span class="hljs-attr">mutation_threshold</span> = <span class="hljs-number">100</span><br>    <span class="hljs-attr">pause_threshold</span> = <span class="hljs-number">0.02</span><br>    <span class="hljs-attr">schedule_delay</span> = <span class="hljs-string">&quot;0s&quot;</span><br>    <span class="hljs-attr">startup_delay</span> = <span class="hljs-string">&quot;100ms&quot;</span><br><br>  <span class="hljs-section">[plugins.&quot;io.containerd.grpc.v1.cri&quot;]</span><br>    <span class="hljs-attr">disable_apparmor</span> = <span class="hljs-literal">false</span><br>    <span class="hljs-attr">disable_cgroup</span> = <span class="hljs-literal">false</span><br>    <span class="hljs-attr">disable_hugetlb_controller</span> = <span class="hljs-literal">true</span><br>    <span class="hljs-attr">disable_proc_mount</span> = <span class="hljs-literal">false</span><br>    <span class="hljs-attr">disable_tcp_service</span> = <span class="hljs-literal">true</span><br>    <span class="hljs-attr">enable_selinux</span> = <span class="hljs-literal">false</span><br>    <span class="hljs-attr">enable_tls_streaming</span> = <span class="hljs-literal">false</span><br>    <span class="hljs-attr">ignore_image_defined_volumes</span> = <span class="hljs-literal">false</span><br>    <span class="hljs-attr">max_concurrent_downloads</span> = <span class="hljs-number">3</span><br>    <span class="hljs-attr">max_container_log_line_size</span> = <span class="hljs-number">16384</span><br>    <span class="hljs-attr">netns_mounts_under_state_dir</span> = <span class="hljs-literal">false</span><br>    <span class="hljs-attr">restrict_oom_score_adj</span> = <span class="hljs-literal">false</span><br>    <span class="hljs-attr">sandbox_image</span> = <span class="hljs-string">&quot;k8s.gcr.io/pause:3.5&quot;</span><br>    <span class="hljs-attr">selinux_category_range</span> = <span class="hljs-number">1024</span><br>    <span class="hljs-attr">stats_collect_period</span> = <span class="hljs-number">10</span><br>    <span class="hljs-attr">stream_idle_timeout</span> = <span class="hljs-string">&quot;4h0m0s&quot;</span><br>    <span class="hljs-attr">stream_server_address</span> = <span class="hljs-string">&quot;127.0.0.1&quot;</span><br>    <span class="hljs-attr">stream_server_port</span> = <span class="hljs-string">&quot;0&quot;</span><br>    <span class="hljs-attr">systemd_cgroup</span> = <span class="hljs-literal">false</span><br>    <span class="hljs-attr">tolerate_missing_hugetlb_controller</span> = <span class="hljs-literal">true</span><br>    <span class="hljs-attr">unset_seccomp_profile</span> = <span class="hljs-string">&quot;&quot;</span><br><br>    <span class="hljs-section">[plugins.&quot;io.containerd.grpc.v1.cri&quot;.cni]</span><br>      <span class="hljs-attr">bin_dir</span> = <span class="hljs-string">&quot;/opt/cni/bin&quot;</span><br>      <span class="hljs-attr">conf_dir</span> = <span class="hljs-string">&quot;/etc/cni/net.d&quot;</span><br>      <span class="hljs-attr">conf_template</span> = <span class="hljs-string">&quot;&quot;</span><br>      <span class="hljs-attr">max_conf_num</span> = <span class="hljs-number">1</span><br><br>    <span class="hljs-section">[plugins.&quot;io.containerd.grpc.v1.cri&quot;.containerd]</span><br>      <span class="hljs-attr">default_runtime_name</span> = <span class="hljs-string">&quot;runc&quot;</span><br>      <span class="hljs-attr">disable_snapshot_annotations</span> = <span class="hljs-literal">true</span><br>      <span class="hljs-attr">discard_unpacked_layers</span> = <span class="hljs-literal">false</span><br>      <span class="hljs-attr">no_pivot</span> = <span class="hljs-literal">false</span><br>      <span class="hljs-attr">snapshotter</span> = <span class="hljs-string">&quot;overlayfs&quot;</span><br><br>      <span class="hljs-section">[plugins.&quot;io.containerd.grpc.v1.cri&quot;.containerd.default_runtime]</span><br>        <span class="hljs-attr">base_runtime_spec</span> = <span class="hljs-string">&quot;&quot;</span><br>        <span class="hljs-attr">container_annotations</span> = []<br>        <span class="hljs-attr">pod_annotations</span> = []<br>        <span class="hljs-attr">privileged_without_host_devices</span> = <span class="hljs-literal">false</span><br>        <span class="hljs-attr">runtime_engine</span> = <span class="hljs-string">&quot;&quot;</span><br>        <span class="hljs-attr">runtime_root</span> = <span class="hljs-string">&quot;&quot;</span><br>        <span class="hljs-attr">runtime_type</span> = <span class="hljs-string">&quot;&quot;</span><br><br>        <span class="hljs-section">[plugins.&quot;io.containerd.grpc.v1.cri&quot;.containerd.default_runtime.options]</span><br><br>      <span class="hljs-section">[plugins.&quot;io.containerd.grpc.v1.cri&quot;.containerd.runtimes]</span><br><br>        <span class="hljs-section">[plugins.&quot;io.containerd.grpc.v1.cri&quot;.containerd.runtimes.runc]</span><br>          <span class="hljs-attr">base_runtime_spec</span> = <span class="hljs-string">&quot;&quot;</span><br>          <span class="hljs-attr">container_annotations</span> = []<br>          <span class="hljs-attr">pod_annotations</span> = []<br>          <span class="hljs-attr">privileged_without_host_devices</span> = <span class="hljs-literal">false</span><br>          <span class="hljs-attr">runtime_engine</span> = <span class="hljs-string">&quot;&quot;</span><br>          <span class="hljs-attr">runtime_root</span> = <span class="hljs-string">&quot;&quot;</span><br>          <span class="hljs-attr">runtime_type</span> = <span class="hljs-string">&quot;io.containerd.runc.v2&quot;</span><br><br>          <span class="hljs-section">[plugins.&quot;io.containerd.grpc.v1.cri&quot;.containerd.runtimes.runc.options]</span><br>            <span class="hljs-attr">BinaryName</span> = <span class="hljs-string">&quot;&quot;</span><br>            <span class="hljs-attr">CriuImagePath</span> = <span class="hljs-string">&quot;&quot;</span><br>            <span class="hljs-attr">CriuPath</span> = <span class="hljs-string">&quot;&quot;</span><br>            <span class="hljs-attr">CriuWorkPath</span> = <span class="hljs-string">&quot;&quot;</span><br>            <span class="hljs-attr">IoGid</span> = <span class="hljs-number">0</span><br>            <span class="hljs-attr">IoUid</span> = <span class="hljs-number">0</span><br>            <span class="hljs-attr">NoNewKeyring</span> = <span class="hljs-literal">false</span><br>            <span class="hljs-attr">NoPivotRoot</span> = <span class="hljs-literal">false</span><br>            <span class="hljs-attr">Root</span> = <span class="hljs-string">&quot;&quot;</span><br>            <span class="hljs-attr">ShimCgroup</span> = <span class="hljs-string">&quot;&quot;</span><br>            <span class="hljs-attr">SystemdCgroup</span> = <span class="hljs-literal">false</span><br><br>      <span class="hljs-section">[plugins.&quot;io.containerd.grpc.v1.cri&quot;.containerd.untrusted_workload_runtime]</span><br>        <span class="hljs-attr">base_runtime_spec</span> = <span class="hljs-string">&quot;&quot;</span><br>        <span class="hljs-attr">container_annotations</span> = []<br>        <span class="hljs-attr">pod_annotations</span> = []<br>        <span class="hljs-attr">privileged_without_host_devices</span> = <span class="hljs-literal">false</span><br>        <span class="hljs-attr">runtime_engine</span> = <span class="hljs-string">&quot;&quot;</span><br>        <span class="hljs-attr">runtime_root</span> = <span class="hljs-string">&quot;&quot;</span><br>        <span class="hljs-attr">runtime_type</span> = <span class="hljs-string">&quot;&quot;</span><br><br>        <span class="hljs-section">[plugins.&quot;io.containerd.grpc.v1.cri&quot;.containerd.untrusted_workload_runtime.options]</span><br><br>    <span class="hljs-section">[plugins.&quot;io.containerd.grpc.v1.cri&quot;.image_decryption]</span><br>      <span class="hljs-attr">key_model</span> = <span class="hljs-string">&quot;node&quot;</span><br><br>    <span class="hljs-section">[plugins.&quot;io.containerd.grpc.v1.cri&quot;.registry]</span><br>      <span class="hljs-attr">config_path</span> = <span class="hljs-string">&quot;&quot;</span><br><br>      <span class="hljs-section">[plugins.&quot;io.containerd.grpc.v1.cri&quot;.registry.auths]</span><br><br>      <span class="hljs-section">[plugins.&quot;io.containerd.grpc.v1.cri&quot;.registry.configs]</span><br><br>      <span class="hljs-section">[plugins.&quot;io.containerd.grpc.v1.cri&quot;.registry.headers]</span><br><br>      <span class="hljs-section">[plugins.&quot;io.containerd.grpc.v1.cri&quot;.registry.mirrors]</span><br><br>    <span class="hljs-section">[plugins.&quot;io.containerd.grpc.v1.cri&quot;.x509_key_pair_streaming]</span><br>      <span class="hljs-attr">tls_cert_file</span> = <span class="hljs-string">&quot;&quot;</span><br>      <span class="hljs-attr">tls_key_file</span> = <span class="hljs-string">&quot;&quot;</span><br><br>  <span class="hljs-section">[plugins.&quot;io.containerd.internal.v1.opt&quot;]</span><br>    <span class="hljs-attr">path</span> = <span class="hljs-string">&quot;/opt/containerd&quot;</span><br><br>  <span class="hljs-section">[plugins.&quot;io.containerd.internal.v1.restart&quot;]</span><br>    <span class="hljs-attr">interval</span> = <span class="hljs-string">&quot;10s&quot;</span><br><br>  <span class="hljs-section">[plugins.&quot;io.containerd.metadata.v1.bolt&quot;]</span><br>    <span class="hljs-attr">content_sharing_policy</span> = <span class="hljs-string">&quot;shared&quot;</span><br><br>  <span class="hljs-section">[plugins.&quot;io.containerd.monitor.v1.cgroups&quot;]</span><br>    <span class="hljs-attr">no_prometheus</span> = <span class="hljs-literal">false</span><br><br>  <span class="hljs-section">[plugins.&quot;io.containerd.runtime.v1.linux&quot;]</span><br>    <span class="hljs-attr">no_shim</span> = <span class="hljs-literal">false</span><br>    <span class="hljs-attr">runtime</span> = <span class="hljs-string">&quot;runc&quot;</span><br>    <span class="hljs-attr">runtime_root</span> = <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-attr">shim</span> = <span class="hljs-string">&quot;containerd-shim&quot;</span><br>    <span class="hljs-attr">shim_debug</span> = <span class="hljs-literal">false</span><br><br>  <span class="hljs-section">[plugins.&quot;io.containerd.runtime.v2.task&quot;]</span><br>    <span class="hljs-attr">platforms</span> = [<span class="hljs-string">&quot;linux/amd64&quot;</span>]<br><br>  <span class="hljs-section">[plugins.&quot;io.containerd.service.v1.diff-service&quot;]</span><br>    <span class="hljs-attr">default</span> = [<span class="hljs-string">&quot;walking&quot;</span>]<br><br>  <span class="hljs-section">[plugins.&quot;io.containerd.snapshotter.v1.aufs&quot;]</span><br>    <span class="hljs-attr">root_path</span> = <span class="hljs-string">&quot;&quot;</span><br><br>  <span class="hljs-section">[plugins.&quot;io.containerd.snapshotter.v1.btrfs&quot;]</span><br>    <span class="hljs-attr">root_path</span> = <span class="hljs-string">&quot;&quot;</span><br><br>  <span class="hljs-section">[plugins.&quot;io.containerd.snapshotter.v1.devmapper&quot;]</span><br>    <span class="hljs-attr">async_remove</span> = <span class="hljs-literal">false</span><br>    <span class="hljs-attr">base_image_size</span> = <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-attr">pool_name</span> = <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-attr">root_path</span> = <span class="hljs-string">&quot;&quot;</span><br><br>  <span class="hljs-section">[plugins.&quot;io.containerd.snapshotter.v1.native&quot;]</span><br>    <span class="hljs-attr">root_path</span> = <span class="hljs-string">&quot;&quot;</span><br><br>  <span class="hljs-section">[plugins.&quot;io.containerd.snapshotter.v1.overlayfs&quot;]</span><br>    <span class="hljs-attr">root_path</span> = <span class="hljs-string">&quot;&quot;</span><br><br>  <span class="hljs-section">[plugins.&quot;io.containerd.snapshotter.v1.zfs&quot;]</span><br>    <span class="hljs-attr">root_path</span> = <span class="hljs-string">&quot;&quot;</span><br><br><span class="hljs-section">[proxy_plugins]</span><br><br><span class="hljs-section">[stream_processors]</span><br><br>  <span class="hljs-section">[stream_processors.&quot;io.containerd.ocicrypt.decoder.v1.tar&quot;]</span><br>    <span class="hljs-attr">accepts</span> = [<span class="hljs-string">&quot;application/vnd.oci.image.layer.v1.tar+encrypted&quot;</span>]<br>    <span class="hljs-attr">args</span> = [<span class="hljs-string">&quot;--decryption-keys-path&quot;</span>, <span class="hljs-string">&quot;/etc/containerd/ocicrypt/keys&quot;</span>]<br>    <span class="hljs-attr">env</span> = [<span class="hljs-string">&quot;OCICRYPT_KEYPROVIDER_CONFIG=/etc/containerd/ocicrypt/ocicrypt_keyprovider.conf&quot;</span>]<br>    <span class="hljs-attr">path</span> = <span class="hljs-string">&quot;ctd-decoder&quot;</span><br>    <span class="hljs-attr">returns</span> = <span class="hljs-string">&quot;application/vnd.oci.image.layer.v1.tar&quot;</span><br><br>  <span class="hljs-section">[stream_processors.&quot;io.containerd.ocicrypt.decoder.v1.tar.gzip&quot;]</span><br>    <span class="hljs-attr">accepts</span> = [<span class="hljs-string">&quot;application/vnd.oci.image.layer.v1.tar+gzip+encrypted&quot;</span>]<br>    <span class="hljs-attr">args</span> = [<span class="hljs-string">&quot;--decryption-keys-path&quot;</span>, <span class="hljs-string">&quot;/etc/containerd/ocicrypt/keys&quot;</span>]<br>    <span class="hljs-attr">env</span> = [<span class="hljs-string">&quot;OCICRYPT_KEYPROVIDER_CONFIG=/etc/containerd/ocicrypt/ocicrypt_keyprovider.conf&quot;</span>]<br>    <span class="hljs-attr">path</span> = <span class="hljs-string">&quot;ctd-decoder&quot;</span><br>    <span class="hljs-attr">returns</span> = <span class="hljs-string">&quot;application/vnd.oci.image.layer.v1.tar+gzip&quot;</span><br><br><span class="hljs-section">[timeouts]</span><br>  <span class="hljs-attr">&quot;io.containerd.timeout.shim.cleanup&quot;</span> = <span class="hljs-string">&quot;5s&quot;</span><br>  <span class="hljs-attr">&quot;io.containerd.timeout.shim.load&quot;</span> = <span class="hljs-string">&quot;5s&quot;</span><br>  <span class="hljs-attr">&quot;io.containerd.timeout.shim.shutdown&quot;</span> = <span class="hljs-string">&quot;3s&quot;</span><br>  <span class="hljs-attr">&quot;io.containerd.timeout.task.state&quot;</span> = <span class="hljs-string">&quot;2s&quot;</span><br><br><span class="hljs-section">[ttrpc]</span><br>  <span class="hljs-attr">address</span> = <span class="hljs-string">&quot;&quot;</span><br>  <span class="hljs-attr">gid</span> = <span class="hljs-number">0</span><br>  <span class="hljs-attr">uid</span> = <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>这个配置文件比较复杂，我们可以将重点放在其中的 <code>plugins</code> 配置上面，仔细观察我们可以发现每一个顶级配置块的命名都是 <code>plugins.&quot;io.containerd.xxx.vx.xxx&quot;</code> 这种形式，每一个顶级配置块都表示一个插件，其中 <code>io.containerd.xxx.vx</code> 表示插件的类型，<code>vx</code> 后面的 <code>xxx</code> 表示插件的 ID，我们可以通过 <code>ctr</code> 查看插件列表：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs shell">➜  ~ ctr plugin ls<br>ctr plugin ls<br>TYPE                            ID                       PLATFORMS      STATUS<br>io.containerd.content.v1        content                  -              ok<br>io.containerd.snapshotter.v1    aufs                     linux/amd64    ok<br>io.containerd.snapshotter.v1    btrfs                    linux/amd64    skip<br>io.containerd.snapshotter.v1    devmapper                linux/amd64    error<br>io.containerd.snapshotter.v1    native                   linux/amd64    ok<br>io.containerd.snapshotter.v1    overlayfs                linux/amd64    ok<br>io.containerd.snapshotter.v1    zfs                      linux/amd64    skip<br>io.containerd.metadata.v1       bolt                     -              ok<br>io.containerd.differ.v1         walking                  linux/amd64    ok<br>io.containerd.gc.v1             scheduler                -              ok<br>io.containerd.service.v1        introspection-service    -              ok<br>io.containerd.service.v1        containers-service       -              ok<br>io.containerd.service.v1        content-service          -              ok<br>io.containerd.service.v1        diff-service             -              ok<br>io.containerd.service.v1        images-service           -              ok<br>io.containerd.service.v1        leases-service           -              ok<br>io.containerd.service.v1        namespaces-service       -              ok<br>io.containerd.service.v1        snapshots-service        -              ok<br>io.containerd.runtime.v1        linux                    linux/amd64    ok<br>io.containerd.runtime.v2        task                     linux/amd64    ok<br>io.containerd.monitor.v1        cgroups                  linux/amd64    ok<br>io.containerd.service.v1        tasks-service            -              ok<br>io.containerd.internal.v1       restart                  -              ok<br>io.containerd.grpc.v1           containers               -              ok<br>io.containerd.grpc.v1           content                  -              ok<br>io.containerd.grpc.v1           diff                     -              ok<br>io.containerd.grpc.v1           events                   -              ok<br>io.containerd.grpc.v1           healthcheck              -              ok<br>io.containerd.grpc.v1           images                   -              ok<br>io.containerd.grpc.v1           leases                   -              ok<br>io.containerd.grpc.v1           namespaces               -              ok<br>io.containerd.internal.v1       opt                      -              ok<br>io.containerd.grpc.v1           snapshots                -              ok<br>io.containerd.grpc.v1           tasks                    -              ok<br>io.containerd.grpc.v1           version                  -              ok<br>io.containerd.grpc.v1           cri                      linux/amd64    ok<br></code></pre></td></tr></table></figure><p>顶级配置块下面的子配置块表示该插件的各种配置，比如 cri 插件下面就分为 containerd、cni 和 registry 的配置，而 containerd 下面又可以配置各种 runtime，还可以配置默认的 runtime。比如现在我们要为镜像配置一个加速器，那么就需要在 cri 配置块下面的 <code>registry</code> 配置块下面进行配置 <code>registry.mirrors</code>：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs toml"><span class="hljs-section">[plugins.&quot;io.containerd.grpc.v1.cri&quot;.registry]</span><br>  <span class="hljs-section">[plugins.&quot;io.containerd.grpc.v1.cri&quot;.registry.mirrors]</span><br>    <span class="hljs-section">[plugins.&quot;io.containerd.grpc.v1.cri&quot;.registry.mirrors.&quot;docker.io&quot;]</span><br>      <span class="hljs-attr">endpoint</span> = [<span class="hljs-string">&quot;https://bqr1dr1n.mirror.aliyuncs.com&quot;</span>]<br>    <span class="hljs-section">[plugins.&quot;io.containerd.grpc.v1.cri&quot;.registry.mirrors.&quot;k8s.gcr.io&quot;]</span><br>      <span class="hljs-attr">endpoint</span> = [<span class="hljs-string">&quot;https://registry.aliyuncs.com/k8sxio&quot;</span>]<br></code></pre></td></tr></table></figure><ul><li><code>registry.mirrors.&quot;xxx&quot;</code>: 表示需要配置 mirror 的镜像仓库，例如 <code>registry.mirrors.&quot;docker.io&quot;</code> 表示配置 docker.io 的 mirror。</li><li><code>endpoint</code>: 表示提供 mirror 的镜像加速服务，比如我们可以注册一个阿里云的镜像服务来作为 docker.io 的 mirror。</li></ul><p>另外在默认配置中还有两个关于存储的配置路径：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs toml"><span class="hljs-attr">root</span> = <span class="hljs-string">&quot;/var/lib/containerd&quot;</span><br><span class="hljs-attr">state</span> = <span class="hljs-string">&quot;/run/containerd&quot;</span><br></code></pre></td></tr></table></figure><p>其中 <code>root</code> 是用来保存持久化数据，包括 Snapshots, Content, Metadata 以及各种插件的数据，每一个插件都有自己单独的目录，Containerd 本身不存储任何数据，它的所有功能都来自于已加载的插件。</p><p>而另外的 <code>state</code> 是用来保存运行时的临时数据的，包括 sockets、pid、挂载点、运行时状态以及不需要持久化的插件数据。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>我们知道 Docker CLI 工具提供了需要增强用户体验的功能，containerd 同样也提供一个对应的 CLI 工具：<code>ctr</code>，不过 ctr 的功能没有 docker 完善，但是关于镜像和容器的基本功能都是有的。接下来我们就先简单介绍下 <code>ctr</code> 的使用。</p><p><strong>帮助</strong></p><p>直接输入 <code>ctr</code> 命令即可获得所有相关的操作命令使用方式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs shell">➜  ~ ctr<br>NAME:<br>   ctr -<br>        __<br>  _____/ /______<br> / ___/ __/ ___/<br>/ /__/ /_/ /<br>\___/\__/_/<br><br>containerd CLI<br><br><br>USAGE:<br>   ctr [global options] command [command options] [arguments...]<br><br>VERSION:<br>   v1.5.5<br><br>DESCRIPTION:<br><br>ctr is an unsupported debug and administrative client for interacting<br>with the containerd daemon. Because it is unsupported, the commands,<br>options, and operations are not guaranteed to be backward compatible or<br>stable from release to release of the containerd project.<br><br>COMMANDS:<br>   plugins, plugin            provides information about containerd plugins<br>   version                    print the client and server versions<br>   containers, c, container   manage containers<br>   content                    manage content<br>   events, event              display containerd events<br>   images, image, i           manage images<br>   leases                     manage leases<br>   namespaces, namespace, ns  manage namespaces<br>   pprof                      provide golang pprof outputs for containerd<br>   run                        run a container<br>   snapshots, snapshot        manage snapshots<br>   tasks, t, task             manage tasks<br>   install                    install a new package<br>   oci                        OCI tools<br>   shim                       interact with a shim directly<br>   help, h                    Shows a list of commands or help for one command<br><br>GLOBAL OPTIONS:<br>   --debug                      enable debug output in logs<br>   --address value, -a value    address for containerd&#x27;s GRPC server (default: &quot;/run/containerd/containerd.sock&quot;) [$CONTAINERD_ADDRESS]<br>   --timeout value              total timeout for ctr commands (default: 0s)<br>   --connect-timeout value      timeout for connecting to containerd (default: 0s)<br>   --namespace value, -n value  namespace to use with commands (default: &quot;default&quot;) [$CONTAINERD_NAMESPACE]<br>   --help, -h                   show help<br>   --version, -v                print the version<br></code></pre></td></tr></table></figure><h4 id="镜像操作"><a href="#镜像操作" class="headerlink" title="镜像操作"></a>镜像操作</h4><p><strong>拉取镜像</strong></p><p>拉取镜像可以使用 <code>ctr image pull</code> 来完成，比如拉取 Docker Hub 官方镜像 <code>nginx:alpine</code>，需要注意的是镜像地址需要加上 <code>docker.io</code> Host 地址：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell">➜  ~ ctr image pull docker.io/library/nginx:alpine<br>docker.io/library/nginx:alpine:                                                   resolved       |++++++++++++++++++++++++++++++++++++++|<br>index-sha256:bead42240255ae1485653a956ef41c9e458eb077fcb6dc664cbc3aa9701a05ce:    exists         |++++++++++++++++++++++++++++++++++++++|<br>manifest-sha256:ce6ca11a3fa7e0e6b44813901e3289212fc2f327ee8b1366176666e8fb470f24: done           |++++++++++++++++++++++++++++++++++++++|<br>layer-sha256:9a6ac07b84eb50935293bb185d0a8696d03247f74fd7d43ea6161dc0f293f81f:    done           |++++++++++++++++++++++++++++++++++++++|<br>layer-sha256:e82f830de071ebcda58148003698f32205b7970b01c58a197ac60d6bb79241b0:    done           |++++++++++++++++++++++++++++++++++++++|<br>layer-sha256:d7c9fa7589ae28cd3306b204d5dd9a539612593e35df70f7a1d69ff7548e74cf:    done           |++++++++++++++++++++++++++++++++++++++|<br>layer-sha256:bf2b3ee132db5b4c65432e53aca69da4e609c6cb154e0d0e14b2b02259e9c1e3:    done           |++++++++++++++++++++++++++++++++++++++|<br>config-sha256:7ce0143dee376bfd2937b499a46fb110bda3c629c195b84b1cf6e19be1a9e23b:   done           |++++++++++++++++++++++++++++++++++++++|<br>layer-sha256:3c1eaf69ff492177c34bdbf1735b6f2e5400e417f8f11b98b0da878f4ecad5fb:    done           |++++++++++++++++++++++++++++++++++++++|<br>layer-sha256:29291e31a76a7e560b9b7ad3cada56e8c18d50a96cca8a2573e4f4689d7aca77:    done           |++++++++++++++++++++++++++++++++++++++|<br>elapsed: 11.9s                                                                    total:  8.7 Mi (748.1 KiB/s)<br>unpacking linux/amd64 sha256:bead42240255ae1485653a956ef41c9e458eb077fcb6dc664cbc3aa9701a05ce...<br>done: 410.86624ms<br></code></pre></td></tr></table></figure><p>也可以使用 <code>--platform</code> 选项指定对应平台的镜像。当然对应的也有推送镜像的命令 <code>ctr image push</code>，如果是私有镜像则在推送的时候可以通过 <code>--user</code> 来自定义仓库的用户名和密码。</p><p><strong>列出本地镜像</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">➜  ~ ctr image ls<br>REF                            TYPE                                                      DIGEST                                                                  SIZE    PLATFORMS                                                                                LABELS<br>docker.io/library/nginx:alpine application/vnd.docker.distribution.manifest.list.v2+json sha256:bead42240255ae1485653a956ef41c9e458eb077fcb6dc664cbc3aa9701a05ce 9.5 MiB linux/386,linux/amd64,linux/arm/v6,linux/arm/v7,linux/arm64/v8,linux/ppc64le,linux/s390x -<br>➜  ~ ctr image ls -q<br>docker.io/library/nginx:alpine<br></code></pre></td></tr></table></figure><p>使用 <code>-q（--quiet）</code> 选项可以只打印镜像名称。</p><p><strong>检测本地镜像</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">➜  ~ ctr image check<br>REF                            TYPE                                                      DIGEST                                                                  STATUS         SIZE            UNPACKED<br>docker.io/library/nginx:alpine application/vnd.docker.distribution.manifest.list.v2+json sha256:bead42240255ae1485653a956ef41c9e458eb077fcb6dc664cbc3aa9701a05ce complete (7/7) 9.5 MiB/9.5 MiB true<br></code></pre></td></tr></table></figure><p>主要查看其中的 <code>STATUS</code>，<code>complete</code> 表示镜像是完整可用的状态。</p><p><strong>重新打标签</strong></p><p>同样的我们也可以重新给指定的镜像打一个 Tag：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">➜  ~ ctr image tag docker.io/library/nginx:alpine harbor.k8s.local/course/nginx:alpine<br>harbor.k8s.local/course/nginx:alpine<br>➜  ~ ctr image ls -q<br>docker.io/library/nginx:alpine<br>harbor.k8s.local/course/nginx:alpine<br></code></pre></td></tr></table></figure><p><strong>删除镜像</strong></p><p>不需要使用的镜像也可以使用 <code>ctr image rm</code> 进行删除：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">➜  ~ ctr image rm harbor.k8s.local/course/nginx:alpine<br>harbor.k8s.local/course/nginx:alpine<br>➜  ~ ctr image ls -q<br>docker.io/library/nginx:alpine<br></code></pre></td></tr></table></figure><p>加上 <code>--sync</code> 选项可以同步删除镜像和所有相关的资源。</p><p><strong>将镜像挂载到主机目录</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs shell">➜  ~ ctr image mount docker.io/library/nginx:alpine /mnt<br>sha256:c3554b2d61e3c1cffcaba4b4fa7651c644a3354efaafa2f22cb53542f6c600dc<br>/mnt<br>➜  ~ tree -L 1 /mnt<br>/mnt<br>├── bin<br>├── dev<br>├── docker-entrypoint.d<br>├── docker-entrypoint.sh<br>├── etc<br>├── home<br>├── lib<br>├── media<br>├── mnt<br>├── opt<br>├── proc<br>├── root<br>├── run<br>├── sbin<br>├── srv<br>├── sys<br>├── tmp<br>├── usr<br>└── var<br><br>18 directories, 1 file<br></code></pre></td></tr></table></figure><p><strong>将镜像从主机目录上卸载</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">➜  ~ ctr image unmount /mnt<br>/mnt<br></code></pre></td></tr></table></figure><p><strong>将镜像导出为压缩包</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">➜  ~ ctr image export nginx.tar.gz docker.io/library/nginx:alpine<br></code></pre></td></tr></table></figure><p><strong>从压缩包导入镜像</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">➜  ~ ctr image import nginx.tar.gz<br></code></pre></td></tr></table></figure><h4 id="容器操作"><a href="#容器操作" class="headerlink" title="容器操作"></a>容器操作</h4><p>容器相关操作可以通过 <code>ctr container</code> 获取。</p><p><strong>创建容器</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">➜  ~ ctr container create docker.io/library/nginx:alpine nginx<br></code></pre></td></tr></table></figure><p><strong>列出容器</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">➜  ~ ctr container ls<br>CONTAINER    IMAGE                             RUNTIME<br>nginx        docker.io/library/nginx:alpine    io.containerd.runc.v2<br></code></pre></td></tr></table></figure><p>同样可以加上 <code>-q</code> 选项精简列表内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">➜  ~ ctr container ls -q<br>nginx<br></code></pre></td></tr></table></figure><p><strong>查看容器详细配置</strong></p><p>类似于 <code>docker inspect</code> 功能。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs shell">➜  ~ ctr container info nginx<br>&#123;<br>    &quot;ID&quot;: &quot;nginx&quot;,<br>    &quot;Labels&quot;: &#123;<br>        &quot;io.containerd.image.config.stop-signal&quot;: &quot;SIGQUIT&quot;<br>    &#125;,<br>    &quot;Image&quot;: &quot;docker.io/library/nginx:alpine&quot;,<br>    &quot;Runtime&quot;: &#123;<br>        &quot;Name&quot;: &quot;io.containerd.runc.v2&quot;,<br>        &quot;Options&quot;: &#123;<br>            &quot;type_url&quot;: &quot;containerd.runc.v1.Options&quot;<br>        &#125;<br>    &#125;,<br>    &quot;SnapshotKey&quot;: &quot;nginx&quot;,<br>    &quot;Snapshotter&quot;: &quot;overlayfs&quot;,<br>    &quot;CreatedAt&quot;: &quot;2021-08-12T08:23:13.792871558Z&quot;,<br>    &quot;UpdatedAt&quot;: &quot;2021-08-12T08:23:13.792871558Z&quot;,<br>    &quot;Extensions&quot;: null,<br>    &quot;Spec&quot;: &#123;<br>......<br></code></pre></td></tr></table></figure><p><strong>删除容器</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">➜  ~ ctr container rm nginx<br>➜  ~ ctr container ls<br>CONTAINER    IMAGE    RUNTIME<br></code></pre></td></tr></table></figure><p>除了使用 <code>rm</code> 子命令之外也可以使用 <code>delete</code> 或者 <code>del</code> 删除容器。</p><h4 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h4><p>上面我们通过 <code>container create</code> 命令创建的容器，并没有处于运行状态，只是一个静态的容器。一个 container 对象只是包含了运行一个容器所需的资源及相关配置数据，表示 namespaces、rootfs 和容器的配置都已经初始化成功了，只是用户进程还没有启动。</p><p>一个容器真正运行起来是由 Task 任务实现的，Task 可以为容器设置网卡，还可以配置工具来对容器进行监控等。</p><p>Task 相关操作可以通过 <code>ctr task</code> 获取，如下我们通过 Task 来启动容器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">➜  ~ ctr task start -d nginx<br>/docker-entrypoint.sh: /docker-entrypoint.d/ is not empty, will attempt to perform configuration<br>/docker-entrypoint.sh: Looking for shell scripts in /docker-entrypoint.d/<br></code></pre></td></tr></table></figure><p>启动容器后可以通过 <code>task ls</code> 查看正在运行的容器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">➜  ~ ctr task ls<br>TASK     PID     STATUS<br>nginx    3630    RUNNING<br></code></pre></td></tr></table></figure><p>同样也可以使用 <code>exec</code> 命令进入容器进行操作：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">➜  ~ ctr task exec --exec-id 0 -t nginx sh<br>/ #<br></code></pre></td></tr></table></figure><p>不过这里需要注意必须要指定 <code>--exec-id</code> 参数，这个 id 可以随便写，只要唯一就行。</p><p>暂停容器，和 <code>docker pause</code> 类似的功能：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">➜  ~ ctr task pause nginx<br></code></pre></td></tr></table></figure><p>暂停后容器状态变成了 <code>PAUSED</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">➜  ~ ctr task ls<br>TASK     PID     STATUS<br>nginx    3630    PAUSED<br></code></pre></td></tr></table></figure><p>同样也可以使用 <code>resume</code> 命令来恢复容器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">➜  ~ ctr task resume nginx<br>➜  ~ ctr task ls<br>TASK     PID     STATUS<br>nginx    3630    RUNNING<br></code></pre></td></tr></table></figure><p>不过需要注意 ctr 没有 stop 容器的功能，只能暂停或者杀死容器。杀死容器可以使用 <code>task kill</code> 命令:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">➜  ~ ctr task kill nginx<br>➜  ~ ctr task ls<br>TASK     PID     STATUS<br>nginx    3630    STOPPED<br></code></pre></td></tr></table></figure><p>杀掉容器后可以看到容器的状态变成了 <code>STOPPED</code>。同样也可以通过 <code>task rm</code> 命令删除 Task：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">➜  ~ ctr task rm nginx<br>➜  ~ ctr task ls<br>TASK    PID    STATUS<br></code></pre></td></tr></table></figure><p>除此之外我们还可以获取容器的 cgroup 相关信息，可以使用 <code>task metrics</code> 命令用来获取容器的内存、CPU 和 PID 的限额与使用量。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">重新启动容器</span><br>➜  ~ ctr task metrics nginx<br>ID       TIMESTAMP<br>nginx    2021-08-12 08:50:46.952769941 +0000 UTC<br><br>METRIC                   VALUE<br>memory.usage_in_bytes    8855552<br>memory.limit_in_bytes    9223372036854771712<br>memory.stat.cache        0<br>cpuacct.usage            22467106<br>cpuacct.usage_percpu     [2962708 860891 1163413 1915748 1058868 2888139 6159277 5458062]<br>pids.current             9<br>pids.limit               0<br></code></pre></td></tr></table></figure><p>还可以使用 <code>task ps</code> 命令查看容器中所有进程在宿主机中的 PID：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell">➜  ~ ctr task ps nginx<br>PID     INFO<br>3984    -<br>4029    -<br>4030    -<br>4031    -<br>4032    -<br>4033    -<br>4034    -<br>4035    -<br>4036    -<br>➜  ~ ctr task ls<br>TASK     PID     STATUS<br>nginx    3984    RUNNING<br></code></pre></td></tr></table></figure><p>其中第一个 PID <code>3984</code> 就是我们容器中的 1 号进程。</p><h4 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h4><p>另外 Containerd 中也支持命名空间的概念，比如查看命名空间：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">➜  ~ ctr ns ls<br>NAME    LABELS<br>default<br></code></pre></td></tr></table></figure><p>如果不指定，ctr 默认使用的是 <code>default</code> 空间。同样也可以使用 <code>ns create</code> 命令创建一个命名空间：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">➜  ~ ctr ns create test<br>➜  ~ ctr ns ls<br>NAME    LABELS<br>default<br>test<br></code></pre></td></tr></table></figure><p>使用 <code>remove</code> 或者 <code>rm</code> 可以删除 namespace：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">➜  ~ ctr ns rm test<br>test<br>➜  ~ ctr ns ls<br>NAME    LABELS<br>default<br></code></pre></td></tr></table></figure><p>有了命名空间后就可以在操作资源的时候指定 namespace，比如查看 test 命名空间的镜像，可以在操作命令后面加上 <code>-n test</code> 选项：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">➜  ~ ctr -n test image ls<br>REF TYPE DIGEST SIZE PLATFORMS LABELS<br></code></pre></td></tr></table></figure><p>我们知道 Docker 其实也是默认调用的 containerd，事实上 Docker 使用的 containerd 下面的命名空间默认是 <code>moby</code>，而不是 <code>default</code>，所以假如我们有用 docker 启动容器，那么我们也可以通过 <code>ctr -n moby</code> 来定位下面的容器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">➜  ~ ctr -n moby container ls<br></code></pre></td></tr></table></figure><p>同样 Kubernetes 下使用的 containerd 默认命名空间是 <code>k8s.io</code>，所以我们可以使用 <code>ctr -n k8s.io</code> 来查看 Kubernetes 下面创建的容器。后续我们再介绍如何将 Kubernetes 集群的容器运行时切换到 <code>containerd</code>。</p><p><strong>Docker ctr nerdctl命令直接的区别</strong></p><p><code>crictl</code>是kubernetes cri-tools的一部分，是专门为kubernetes使用containerd而专门制作的，提供了Pod、容器和镜像等资源的管理命令。</p><blockquote><p>需要注意的是：使用其他非 kubernetes创建的容器、镜像，crictl是无法看到和调试的，比如说ctr run在未指定namespace情况下运行起来的容器就无法使用crictl看到。当然ctr可以使用-n k8s.io指定操作的namespace为 k8s.io，从而可以看到&#x2F;操作kubernetes 集群中容器、镜像等资源。可以理解为：crictl 操作的时候指定了containerd 的namespace为k8s.io。</p></blockquote><p><code>nerdctl</code> <strong>ctr</strong>功能简单，而且对已经习惯使用<code>docker cli</code>的人来说，ctr并不友好（比如无法像 docker cli 那样）。这个时候<code>nerdctl</code>就可以替代ctr了。nerdctl是一个与docker cli风格兼容的containerd的cli工具，并且已经被作为子项目加入了 containerd 项目中。从<code>nerdctl 0.8</code>开始，nerdctl直接兼容了<code>docker compose</code>的语法(不包含 swarm)， 这很大程度上提高了直接将 containerd 作为本地开发、测试和单机容器部署使用的体验。</p><p>需要注意的是：安装 nerdctl 之后，要想可以使用 nerdctl 还需要安装 CNI 相关工具和插件。containerd不包含网络功能的实现，想要实现端口映射这样的容器网络能力，需要额外安装 CNI 相关工具和插件。</p><blockquote><p>另外 nerdctl 也可以使用 -n 指定使用的 namespace。</p></blockquote><table><thead><tr><th align="left"></th><th align="left">docker</th><th align="left">crictl</th><th align="left">ctr</th><th align="left">nerdctl</th></tr></thead><tbody><tr><td align="left">查看容器列表</td><td align="left">docker ps</td><td align="left">crictl ps</td><td align="left">ctr c ls（查看非 kubernetes 中的容器）ctr -n k8s.io c ls（查看 kubernetes 集群中的容器）</td><td align="left">nerdctl ps（查看非 kubernetes 中的容器）nerdctl -n k8s.io ps（查看 kubernetes 集群中的容器）</td></tr><tr><td align="left">查看容器详情</td><td align="left">docker inspect</td><td align="left">crictl inspect</td><td align="left">ctr c info</td><td align="left">nerdctl inspect</td></tr><tr><td align="left">查看容器日志</td><td align="left">docker logs</td><td align="left">crictl logs</td><td align="left">无</td><td align="left">nerdctl logs</td></tr><tr><td align="left">容器内执行命令</td><td align="left">docker exec</td><td align="left">crictl exec</td><td align="left">ctr t exec</td><td align="left">nerdctl exec</td></tr><tr><td align="left">挂载容器</td><td align="left">docker attach</td><td align="left">crictl attach</td><td align="left">ctr t attach</td><td align="left">无</td></tr><tr><td align="left">显示容器资源使用情况</td><td align="left">docker stats</td><td align="left">crictl stats</td><td align="left">ctr task metrics</td><td align="left">无</td></tr><tr><td align="left">创建容器</td><td align="left">docker create</td><td align="left">crictl create</td><td align="left">ctr c create</td><td align="left">无</td></tr><tr><td align="left">启动容器</td><td align="left">docker start</td><td align="left">crictl start</td><td align="left">ctr t start</td><td align="left">nerdctl start</td></tr><tr><td align="left">运行容器</td><td align="left">docker run</td><td align="left">crictl run</td><td align="left">ctr run</td><td align="left">nerdctl run</td></tr><tr><td align="left">停止容器</td><td align="left">docker stop</td><td align="left">crictl stop</td><td align="left">ctr t kill</td><td align="left">nerdctl stop</td></tr><tr><td align="left">删除容器</td><td align="left">docker rm</td><td align="left">crictl rm</td><td align="left">ctr c rm</td><td align="left">nerdctl rm</td></tr><tr><td align="left">查看镜像列表</td><td align="left">docker images</td><td align="left">crictl images</td><td align="left">ctr i ls</td><td align="left">nerdctl images</td></tr><tr><td align="left">查看镜像详情</td><td align="left">docker inspect</td><td align="left">crictl inspecti</td><td align="left">无</td><td align="left">nerdctl inspect</td></tr><tr><td align="left">拉取镜像</td><td align="left">docker pull</td><td align="left">crictl pull</td><td align="left">ctr i pull</td><td align="left">nerdctl pull</td></tr><tr><td align="left">推送镜像</td><td align="left">docker push</td><td align="left">无</td><td align="left">ctr i push</td><td align="left">nerdctl push</td></tr><tr><td align="left">删除镜像</td><td align="left">docker rmi</td><td align="left">crictl rmi</td><td align="left">ctr i rm</td><td align="left">nerdctl rmi</td></tr><tr><td align="left">查看Pod列表</td><td align="left">无</td><td align="left">crictl pods</td><td align="left">无</td><td align="left">无</td></tr><tr><td align="left">查看Pod详情</td><td align="left">无</td><td align="left">crictl inspectp</td><td align="left">无</td><td align="left">无</td></tr><tr><td align="left">启动Pod</td><td align="left">无</td><td align="left">crictl runp</td><td align="left">无</td><td align="left">无</td></tr><tr><td align="left">停止Pod</td><td align="left">无</td><td align="left">crictl stopp</td><td align="left">无</td><td align="left">无</td></tr></tbody></table><p>转载自：<a href="https://www.qikqiak.com/post/containerd-usage/">https://www.qikqiak.com/post/containerd-usage/</a></p>]]></content>
    
    
    <categories>
      
      <category>container</category>
      
    </categories>
    
    
    <tags>
      
      <tag>container</tag>
      
      <tag>containerd</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CRI详解</title>
    <link href="/2023/11/30/CRI%E8%AF%A6%E8%A7%A3/"/>
    <url>/2023/11/30/CRI%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p><code>CRI</code>（Container Runtime Interface 容器运行时接口）本质上就是 Kubernetes 定义的一组与容器运行时进行交互的接口，所以只要实现了这套接口的容器运行时都可以对接到 Kubernetes 平台上来。不过 Kubernetes 推出 CRI 这套标准的时候还没有现在的统治地位，所以有一些容器运行时可能不会自身就去实现 CRI 接口，于是就有了 <code>shim（垫片）</code>， 一个 shim 的职责就是作为适配器将各种容器运行时本身的接口适配到 Kubernetes 的 CRI 接口上，其中 <code>dockershim</code> 就是 Kubernetes 对接 Docker 到 CRI 接口上的一个垫片实现。</p><p><img src="https://picdn.youdianzhishi.com/images/20210809172030.png" alt="cri shim"></p><p>Kubelet 通过 gRPC 框架与容器运行时或 shim 进行通信，其中 kubelet 作为客户端，CRI shim（也可能是容器运行时本身）作为服务器。</p><p>CRI定义的 API(<a href="https://github.com/kubernetes/kubernetes/blob/release-1.5/pkg/kubelet/api/v1alpha1/runtime/api.proto">RuntimeService</a>) 主要包括两个 gRPC 服务，<code>ImageService</code> 和 <code>RuntimeService</code>，<code>ImageService</code> 服务主要是拉取镜像、查看和删除镜像等操作，<code>RuntimeService</code> 则是用来管理 Pod 和容器的生命周期，以及与容器交互的调用（exec&#x2F;attach&#x2F;port-forward）等操作，可以通过 kubelet 中的标志 <code>--container-runtime-endpoint</code> 和 <code>--image-service-endpoint</code> 来配置这两个服务的套接字。</p><p><img src="https://picdn.youdianzhishi.com/images/20210809173134.png" alt="kubelet cri"></p><p>不过这里同样也有一个例外，那就是 Docker，由于 Docker 当时的江湖地位很高，Kubernetes 是直接内置了 <code>dockershim</code> 在 kubelet 中的，所以如果你使用的是 Docker 这种容器运行时的话是不需要单独去安装配置适配器之类的，当然这个举动似乎也麻痹了 Docker 公司。</p><p><img src="https://picdn.youdianzhishi.com/images/20210809173555.png" alt="dockershim"></p><p>现在如果我们使用的是 Docker 的话，当我们在 Kubernetes 中创建一个 Pod 的时候，首先就是 kubelet 通过 CRI 接口调用 <code>dockershim</code>，请求创建一个容器，kubelet 可以视作一个简单的 CRI Client, 而 dockershim 就是接收请求的 Server，不过他们都是在 kubelet 内置的。</p><p><code>dockershim</code> 收到请求后, 转化成 Docker Daemon 能识别的请求, 发到 Docker Daemon 上请求创建一个容器，请求到了 Docker Daemon 后续就是 Docker 创建容器的流程了，去调用 <code>containerd</code>，然后创建 <code>containerd-shim</code> 进程，通过该进程去调用 <code>runc</code> 去真正创建容器。</p><p>其实我们仔细观察也不难发现使用 Docker 的话其实是调用链比较长的，真正容器相关的操作其实 containerd 就完全足够了，Docker 太过于复杂笨重了，当然 Docker 深受欢迎的很大一个原因就是提供了很多对用户操作比较友好的功能，但是对于 Kubernetes 来说压根不需要这些功能，因为都是通过接口去操作容器的，所以自然也就可以将容器运行时切换到 containerd 来。</p><p><img src="https://picdn.youdianzhishi.com/images/20210810094948.png" alt="切换到containerd"></p><p>切换到 containerd 可以消除掉中间环节，操作体验也和以前一样，但是由于直接用容器运行时调度容器，所以它们对 Docker 来说是不可见的。 因此，你以前用来检查这些容器的 Docker 工具就不能使用了。</p><p>你不能再使用 <code>docker ps</code> 或 <code>docker inspect</code> 命令来获取容器信息。由于不能列出容器，因此也不能获取日志、停止容器，甚至不能通过 <code>docker exec</code> 在容器中执行命令。</p><p>当然我们仍然可以下载镜像，或者用 <code>docker build</code> 命令构建镜像，但用 Docker 构建、下载的镜像，对于容器运行时和 Kubernetes，均不可见。为了在 Kubernetes 中使用，需要把镜像推送到镜像仓库中去。</p><p>从上图可以看出在 containerd 1.0 中，对 CRI 的适配是通过一个单独的 <code>CRI-Containerd</code> 进程来完成的，这是因为最开始 containerd 还会去适配其他的系统（比如 swarm），所以没有直接实现 CRI，所以这个对接工作就交给 <code>CRI-Containerd</code> 这个 shim 了。</p><p>然后到了 containerd 1.1 版本后就去掉了 <code>CRI-Containerd</code> 这个 shim，直接把适配逻辑作为插件的方式集成到了 containerd 主进程中，现在这样的调用就更加简洁了。</p><p><img src="https://picdn.youdianzhishi.com/images/20210810095546.png" alt="containerd cri"></p><p>与此同时 Kubernetes 社区也做了一个专门用于 Kubernetes 的 CRI 运行时 <a href="https://cri-o.io/">CRI-O</a>，直接兼容 CRI 和 OCI 规范。</p><p><img src="https://picdn.youdianzhishi.com/images/20210810100752.png" alt="cri-o"></p><p>这个方案和 containerd 的方案显然比默认的 dockershim 简洁很多，不过由于大部分用户都比较习惯使用 Docker，所以大家还是更喜欢使用 <code>dockershim</code> 方案。</p><p>但是随着 CRI 方案的发展，以及其他容器运行时对 CRI 的支持越来越完善，Kubernetes 社区在 2020 年 7 月份就开始着手移除 dockershim 方案了：<a href="https://github.com/kubernetes/enhancements/tree/master/keps/sig-node/2221-remove-dockershim%EF%BC%8C%E7%8E%B0%E5%9C%A8%E7%9A%84%E7%A7%BB%E9%99%A4%E8%AE%A1%E5%88%92%E6%98%AF%E5%9C%A8">https://github.com/kubernetes/enhancements/tree/master/keps/sig-node/2221-remove-dockershim，现在的移除计划是在</a> 1.20 版本中将 kubelet 中内置的 dockershim 代码分离，将内置的 dockershim 标记为<code>维护模式</code>，当然这个时候仍然还可以使用 dockershim，目标是在 1.23&#x2F;1.24 版本发布没有 dockershim 的版本（代码还在，但是要默认支持开箱即用的 docker 需要自己构建 kubelet，会在某个宽限期过后从 kubelet 中删除内置的 dockershim 代码）。</p><p>那么这是否就意味这 Kubernetes 不再支持 Docker 了呢？当然不是的，这只是废弃了内置的 <code>dockershim</code> 功能而已，Docker 和其他容器运行时将一视同仁，不会单独对待内置支持，如果我们还想直接使用 Docker 这种容器运行时应该怎么办呢？可以将 dockershim 的功能单独提取出来独立维护一个 <code>cri-dockerd</code> 即可，就类似于 containerd 1.0 版本中提供的 <code>CRI-Containerd</code>，当然还有一种办法就是 Docker 官方社区将 CRI 接口内置到 Dockerd 中去实现。</p><p>但是我们也清楚 Dockerd 也是去直接调用的 Containerd，而 containerd 1.1 版本后就内置实现了 CRI，所以 Docker 也没必要再去单独实现 CRI 了，当 Kubernetes 不再内置支持开箱即用的 Docker 的以后，最好的方式当然也就是直接使用 Containerd 这种容器运行时，而且该容器运行时也已经经过了生产环境实践的，接下来我们就来学习下 Containerd 的使用。</p><p>转载自：<a href="https://www.qikqiak.com/post/containerd-usage/">https://www.qikqiak.com/post/containerd-usage/</a></p>]]></content>
    
    
    <categories>
      
      <category>container</category>
      
    </categories>
    
    
    <tags>
      
      <tag>container</tag>
      
      <tag>kubernetes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker简介</title>
    <link href="/2023/11/30/docker%E6%9E%B6%E6%9E%84/"/>
    <url>/2023/11/30/docker%E6%9E%B6%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h2 id="Docker-Architecutre"><a href="#Docker-Architecutre" class="headerlink" title="Docker Architecutre"></a>Docker Architecutre</h2><p>Docker uses a client-server architecture. The Docker client talks to the Docker daemon, which does the heavy lifting of building, running, and distributing your Docker containers. The Docker client and daemon can run on the same system, or you can connect a Docker client to a remote Docker daemon. The Docker client and daemon communicate using a REST API, over UNIX sockets or a network interface. </p><p><img src="https://docs.docker.com/get-started/images/docker-architecture.webp" alt="Docker Architecture diagram"></p><h3 id="The-Docker-daemon"><a href="#The-Docker-daemon" class="headerlink" title="The Docker daemon"></a><a href="https://docs.docker.com/get-started/overview/#the-docker-daemon">The Docker daemon</a></h3><p>The Docker daemon (<code>dockerd</code>) listens for Docker API requests and manages Docker objects such as images, containers, networks, and volumes. A daemon can also communicate with other daemons to manage Docker services.</p><h3 id="The-Docker-client"><a href="#The-Docker-client" class="headerlink" title="The Docker client"></a><a href="https://docs.docker.com/get-started/overview/#the-docker-client">The Docker client</a></h3><p>The Docker client (<code>docker</code>) is the primary way that many Docker users interact with Docker. When you use commands such as <code>docker run</code>, the client sends these commands to <code>dockerd</code>, which carries them out. The <code>docker</code> command uses the Docker API. The Docker client can communicate with more than one daemon.</p><h3 id="Docker-registries"><a href="#Docker-registries" class="headerlink" title="Docker registries"></a><a href="https://docs.docker.com/get-started/overview/#docker-registries">Docker registries</a></h3><p>A Docker registry stores Docker images. Docker Hub is a public registry that anyone can use, and Docker looks for images on Docker Hub by default. You can even run your own private registry.</p><p>When you use the <code>docker pull</code> or <code>docker run</code> commands, Docker pulls the required images from your configured registry. When you use the <code>docker push</code> command, Docker pushes your image to your configured registry.</p><h3 id="Docker-objects"><a href="#Docker-objects" class="headerlink" title="Docker objects"></a><a href="https://docs.docker.com/get-started/overview/#docker-objects">Docker objects</a></h3><p>When you use Docker, you are creating and using images, containers, networks, volumes, plugins, and other objects. This section is a brief overview of some of those objects.</p><h4 id="Images"><a href="#Images" class="headerlink" title="Images"></a><a href="https://docs.docker.com/get-started/overview/#images">Images</a></h4><p>An image is a read-only template with instructions for creating a Docker container. Often, an image is based on another image, with some additional customization. For example, you may build an image which is based on the <code>ubuntu</code> image, but installs the Apache web server and your application, as well as the configuration details needed to make your application run.</p><p>You might create your own images or you might only use those created by others and published in a registry. To build your own image, you create a Dockerfile with a simple syntax for defining the steps needed to create the image and run it. Each instruction in a Dockerfile creates a layer in the image. When you change the Dockerfile and rebuild the image, only those layers which have changed are rebuilt. This is part of what makes images so lightweight, small, and fast, when compared to other virtualization technologies.</p><h4 id="Containers"><a href="#Containers" class="headerlink" title="Containers"></a><a href="https://docs.docker.com/get-started/overview/#containers">Containers</a></h4><p>A container is a runnable instance of an image. You can create, start, stop, move, or delete a container using the Docker API or CLI. You can connect a container to one or more networks, attach storage to it, or even create a new image based on its current state.</p><p>By default, a container is relatively well isolated from other containers and its host machine. You can control how isolated a container’s network, storage, or other underlying subsystems are from other containers or from the host machine.</p><p>A container is defined by its image as well as any configuration options you provide to it when you create or start it. When a container is removed, any changes to its state that aren’t stored in persistent storage disappear.</p><h5 id="Example-docker-run-command"><a href="#Example-docker-run-command" class="headerlink" title="Example docker run command"></a><a href="https://docs.docker.com/get-started/overview/#example-docker-run-command">Example docker run command</a></h5><p>The following command runs an <code>ubuntu</code> container, attaches interactively to your local command-line session, and runs <code>/bin/bash</code>.</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">$ docker <span class="hljs-keyword">run</span><span class="language-bash"> -i -t ubuntu /bin/bash</span><br></code></pre></td></tr></table></figure><p>When you run this command, the following happens (assuming you are using the default registry configuration):</p><ol><li><p>If you don’t have the <code>ubuntu</code> image locally, Docker pulls it from your configured registry, as though you had run <code>docker pull ubuntu</code> manually.</p></li><li><p>Docker creates a new container, as though you had run a <code>docker container create</code> command manually.</p></li><li><p>Docker allocates a read-write filesystem to the container, as its final layer. This allows a running container to create or modify files and directories in its local filesystem.</p></li><li><p>Docker creates a network interface to connect the container to the default network, since you didn’t specify any networking options. This includes assigning an IP address to the container. By default, containers can connect to external networks using the host machine’s network connection.</p></li><li><p>Docker starts the container and executes <code>/bin/bash</code>. Because the container is running interactively and attached to your terminal (due to the <code>-i</code> and <code>-t</code> flags), you can provide input using your keyboard while Docker logs the output to your terminal.</p></li><li><p>When you run <code>exit</code> to terminate the <code>/bin/bash</code> command, the container stops but isn’t removed. You can start it again or remove it.</p></li></ol><hr><h2 id="Docker完整架构"><a href="#Docker完整架构" class="headerlink" title="Docker完整架构"></a>Docker完整架构</h2><p>从 Docker 1.11 版本开始，Docker 容器运行就不是简单通过 Docker Daemon 来启动了，而是通过集成 containerd、runc 等多个组件来完成的。虽然 Docker Daemon 守护进程模块在不停的重构，但是基本功能和定位没有太大的变化，一直都是 CS 架构，守护进程负责和 Docker Client 端交互，并管理 Docker 镜像和容器。现在的架构中组件 containerd 就会负责集群节点上容器的生命周期管理，并向上为 Docker Daemon 提供 gRPC 接口。</p><p><img src="https://picdn.youdianzhishi.com/images/20210809154608.png" alt="docker 架构"></p><p>当我们要创建一个容器的时候，现在 Docker Daemon 并不能直接帮我们创建了，而是请求 <code>containerd</code> 来创建一个容器，containerd 收到请求后，也并不会直接去操作容器，而是创建一个叫做 <code>containerd-shim</code> 的进程，让这个进程去操作容器，我们指定容器进程是需要一个父进程来做状态收集、维持 stdin 等 fd 打开等工作的，假如这个父进程就是 containerd，那如果 containerd 挂掉的话，整个宿主机上所有的容器都得退出了，而引入 <code>containerd-shim</code> 这个垫片就可以来规避这个问题了。</p><p>然后创建容器需要做一些 namespaces 和 cgroups 的配置，以及挂载 root 文件系统等操作，这些操作其实已经有了标准的规范，那就是 OCI（开放容器标准），<code>runc</code> 就是它的一个参考实现.这个标准其实就是一个文档，主要规定了容器镜像的结构、以及容器需要接收哪些操作指令，比如 create、start、stop、delete 等这些命令。<code>runc</code> 就可以按照这个 OCI 文档来创建一个符合规范的容器，既然是标准肯定就有其他 OCI 实现，比如 Kata、gVisor 这些容器运行时都是符合 OCI 标准的。</p><p>所以真正启动容器是通过 <code>containerd-shim</code> 去调用 <code>runc</code> 来启动容器的，<code>runc</code> 启动完容器后本身会直接退出，<code>containerd-shim</code> 则会成为容器进程的父进程, 负责收集容器进程的状态, 上报给 containerd, 并在容器中 pid 为 1 的进程退出后接管容器中的子进程进行清理, 确保不会出现僵尸进程。</p>]]></content>
    
    
    <categories>
      
      <category>container</category>
      
    </categories>
    
    
    <tags>
      
      <tag>container</tag>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iptables详解</title>
    <link href="/2023/11/30/iptables%E8%AF%A6%E8%A7%A3/"/>
    <url>/2023/11/30/iptables%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p>防火墙，其实说白了讲，就是用于实现Linux下访问控制的功能的，它分为硬件的或者软件的防火墙两种。无论是在哪个网络中，防火墙工作的地方一定是在网络的边缘。而我们的任务就是需要去定义到底防火墙如何工作，这就是防火墙的策略，规则，以达到让它对出入网络的IP、数据进行检测。</p><p>目前市面上比较常见的有3、4层的防火墙，叫网络层的防火墙，还有7层的防火墙，其实是代理层的网关。</p><p>对于TCP&#x2F;IP的七层模型来讲，我们知道第三层是网络层，三层的防火墙会在这层对源地址和目标地址进行检测。但是对于七层的防火墙，不管你源端口或者目标端口，源地址或者目标地址是什么，都将对你所有的东西进行检查。所以，对于设计原理来讲，七层防火墙更加安全，但是这却带来了效率更低。所以市面上通常的防火墙方案，都是两者结合的。而又由于我们都需要从防火墙所控制的这个口来访问，所以防火墙的工作效率就成了用户能够访问数据多少的一个最重要的控制，配置的不好甚至有可能成为流量的瓶颈。</p><p><img src="https://2716750027-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-LlaUBNni4_0TG9UuF4O%2F-LlaUC6_aT-jhYVzesvT%2F-LlaUCpdSjavmSa4XDlu%2F1.png?generation=1565087556310544&alt=media"></p><p>iptables的前身叫ipfirewall （内核1.x时代）,这是一个作者从freeBSD上移植过来的，能够工作在内核当中的，对数据包进行检测的一款简易访问控制工具。但是ipfirewall工作功能极其有限(它需要将所有的规则都放进内核当中，这样规则才能够运行起来，而放进内核，这个做法一般是极其困难的)。当内核发展到2.x系列的时候，软件更名为ipchains，它可以定义多条规则，将他们串起来，共同发挥作用，而现在，它叫做iptables，可以将规则组成一个列表，实现绝对详细的访问控制功能。</p><p>他们都是工作在用户空间中，定义规则的工具，本身并不算是防火墙。它们定义的规则，可以让在内核空间当中的netfilter来读取，并且实现让防火墙工作。而放入内核的地方必须要是特定的位置，必须是tcp&#x2F;ip的协议栈经过的地方。而这个tcp&#x2F;ip协议栈必须经过的地方，可以实现读取规则的地方就叫做 netfilter.(网络过滤器)</p><ul><li><ol><li></li></ol><p>内核空间中：从一个网络接口进来，到另一个网络接口去的</p></li></ul><p>从上面的发展我们知道了作者选择了5个位置，来作为控制的地方，但是你有没有发现，其实前三个位置已经基本上能将路径彻底封锁了，但是为什么已经在进出的口设置了关卡之后还要在内部卡呢？ 由于数据包尚未进行路由决策，还不知道数据要走向哪里，所以在进出口是没办法实现数据过滤的。所以要在内核空间里设置转发的关卡，进入用户空间的关卡，从用户空间出去的关卡。那么，既然他们没什么用，那我们为什么还要放置他们呢？因为我们在做NAT和DNAT的时候，目标地址转换必须在路由之前转换。所以我们必须在外网而后内网的接口处进行设置关卡。</p><p>这五个位置也被称为五个钩子函数（hook functions）,也叫五个规则链。</p><p>这是NetFilter规定的五个规则链，任何一个数据包，只要经过本机，必将经过这五个链中的其中一个链。</p><p><img src="https://2716750027-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-LlaUBNni4_0TG9UuF4O%2F-LlaUC6_aT-jhYVzesvT%2F-LlaUCpfP6PsaTbNSWEH%2F2.png?generation=1565087556441446&alt=media"></p><ul><li><ol><li></li></ol><p>一个数据包进入网卡时，它首先进入PREROUTING链，内核根据数据包目的IP判断是否需要转发出去。</p></li><li><ol start="2"><li></li></ol><p>如果数据包就是进入本机的，它就会沿着图向下移动，到达INPUT链。数据包到了INPUT链后，任何进程都会收到它。本机上运行的程序可以发送数据包，这些数据包会经 过OUTPUT链，然后到达POSTROUTING链输出。</p></li><li><ol start="3"><li></li></ol><p>如果数据包是要转发出去的，且内核允许转发，数据包就会如图所示向右移动，经过 FORWARD链，然后到达POSTROUTING链输出。</p></li></ul><p>规则（rules）其实就是网络管理员预定义的条件，规则一般的定义为“如果数据包头符合这样的条件，就这样处理这个数据包”。规则存储在内核空间的信息包过滤表中，这些规则分别指定了源地址、目的地址、传输协议（如TCP、UDP、ICMP）和服务类型（如HTTP、FTP和SMTP）等。当数据包与规则匹配时，iptables就根据规则所定义的方法来处理这些数据包，如放行（accept）、拒绝（reject）和丢弃（drop）等。配置防火墙的主要工作就是添加、修改和删除这些规则。</p><p>链（chains）是数据包传播的路径，每一条链其实就是众多规则中的一个检查清单，每一条链中可以有一条或数条规则。当一个数据包到达一个链时，iptables就会从链中第一条规则开始检查，看该数据包是否满足规则所定义的条件。如果满足，系统就会根据该条规则所定义的方法处理该数据包；否则iptables将继续检查下一条规则，如果该数据包不符合链中任一条规则，iptables就会根据该链预先定义的默认策略来处理数据包。</p><p>表（tables）提供特定的功能，iptables内置了4个表，即raw表、filter表、nat表和mangle表，分别用于实现包过滤，网络地址转换和包重构的功能。</p><ul><li><p>RAW表：只使用在PREROUTING链和OUTPUT链上,因为优先级最高，从而可以对收到的数据包在连接跟踪前进行处理。一但用户使用了RAW表,在 某个链上,RAW表处理完后,将跳过NAT表和 ip_conntrack处理,即不再做地址转换和数据包的链接跟踪处理了.</p></li><li><p>filter表：主要用于过滤数据包，该表根据系统管理员预定义的一组规则过滤符合条件的数据包。对于防火墙而言，主要利用在filter表中指定的规则来实现对数据包的过滤。Filter表是默认的表，如果没有指定哪个表，iptables 就默认使用filter表来执行所有命令，filter表包含了INPUT链（处理进入的数据包），RORWARD链（处理转发的数据包），OUTPUT链（处理本地生成的数据包）在filter表中只能允许对数据包进行接受，丢弃的操作，而无法对数据包进行更改</p></li><li><p>nat表：主要用于网络地址转换NAT，该表可以实现一对一，一对多，多对多等NAT 工作，iptables就是使用该表实现共享上网的，NAT表包含了PREROUTING链（修改即将到来的数据包），POSTROUTING链（修改即将出去的数据包），OUTPUT链（修改路由之前本地生成的数据包）</p></li><li><p>mangle表：主要用于对指定数据包进行更改，在内核版本2.4.18 后的linux版本中该表包含的链为：INPUT链（处理进入的数据包），RORWARD链（处理转发的数据包），OUTPUT链（处理本地生成的数据包）POSTROUTING链（修改即将出去的数据包），PREROUTING链（修改即将到来的数据包）</p></li></ul><p><strong>Raw——&gt;mangle——&gt;nat——&gt;filter</strong></p><p>从外界到达防火墙的数据包，先被PREROUTING规则链处理（是否修改数据包地址等），之后会进行路由选择（判断该数据包应该发往何处），如果数据包 的目标主机是防火墙本机（比如说Internet用户访问防火墙主机中的web服务器的数据包），那么内核将其传给INPUT链进行处理（决定是否允许通 过等），通过以后再交给系统上层的应用程序（比如Apache服务器）进行响应。</p><p>来自外界的数据包到达防火墙后，首先被PREROUTING规则链处理，之后会进行路由选择，如果数据包的目标地址是其它外部地址（比如局域网用户通过网 关访问QQ站点的数据包），则内核将其传递给FORWARD链进行处理（是否转发或拦截），然后再交给POSTROUTING规则链（是否修改数据包的地 址等）进行处理。</p><p>防火墙本机向外部地址发送的数据包（比如在防火墙主机中测试公网DNS服务器时），首先被OUTPUT规则链处理，之后进行路由选择，然后传递给POSTROUTING规则链（是否修改数据包的地址等）进行处理。</p><p>iptables的命令格式较为复杂，一般的格式如下：</p><p>iptables [-t 表] -命令 匹配 操作</p><p>表选项用于指定命令应用于哪个iptables内置表。</p><p>命令选项用于指定iptables的执行方式，包括插入规则，删除规则和添加规则，如下表所示</p><p>-L –list &lt;链名&gt; 查看iptables规则列表</p><p>-A –append &lt;链名&gt; 在规则列表的最后增加1条规则</p><p>-I –insert &lt;链名&gt; 在指定的位置插入1条规则</p><p>-D –delete &lt;链名&gt; 从规则列表中删除1条规则</p><p>-R –replace &lt;链名&gt; 替换规则列表中的某条规则</p><p>-Z –zero &lt;链名&gt; 将表中数据包计数器和流量计数器归零</p><p>-X –delete-chain &lt;链名&gt; 删除自定义链</p><p>-v –verbose &lt;链名&gt; 与-L他命令一起使用显示更多更详细的信息</p><p>匹配选项指定数据包与规则匹配所具有的特征，包括源地址，目的地址，传输协议和端口号，如下表所示</p><p>-i –in-interface 网络接口名&gt; 指定数据包从哪个网络接口进入，</p><p>-o –out-interface 网络接口名&gt; 指定数据包从哪个网络接口输出</p><p>-p —proto 协议类型 指定数据包匹配的协议，如TCP、UDP和ICMP等</p><p>-s –source 源地址或子网&gt; 指定数据包匹配的源地址</p><p>--sport 源端口号&gt; 指定数据包匹配的源端口号</p><p>--dport 目的端口号&gt; 指定数据包匹配的目的端口号</p><p>-m –match 匹配的模块 指定数据包规则所使用的过滤模块</p><p>前面我们说过iptables处理动作除了 ACCEPT、REJECT、DROP、REDIRECT 、MASQUERADE 以外，还多出 LOG、ULOG、DNAT、RETURN、TOS、SNAT、MIRROR、QUEUE、TTL、MARK等。我们只说明其中最常用的动作：</p><ul><li>REJECT 拦阻该数据包，并返回数据包通知对方，可以返回的数据包有几个选择：ICMP port-unreachable、ICMP echo-reply 或是tcp-reset（这个数据包包会要求对方关闭联机），进行完此处理动作后，将不再比对其它规则，直接中断过滤程序。范例如下：</li></ul><p>iptables -A INPUT -p TCP –dport 22 -j REJECT –reject-with ICMP echo-reply</p><ul><li><p>DROP 丢弃数据包不予处理，进行完此处理动作后，将不再比对其它规则，直接中断过滤程序。</p></li><li><p>REDIRECT 将封包重新导向到另一个端口（PNAT），进行完此处理动作后，将会继续比对其它规则。这个功能可以用来实作透明代理 或用来保护web 服务器。例如：</p></li></ul><p>iptables -t nat -A PREROUTING -p tcp –dport 80 -j REDIRECT–to-ports 8081</p><ul><li>MASQUERADE 改写封包来源IP为防火墙的IP，可以指定port 对应的范围，进行完此处理动作后，直接跳往下一个规则链（mangle:postrouting）。这个功能与 SNAT 略有不同，当进行IP 伪装时，不需指定要伪装成哪个 IP，IP 会从网卡直接读取，当使用拨接连线时，IP 通常是由 ISP 公司的 DHCP服务器指派的，这个时候 MASQUERADE 特别有用。范例如下：</li></ul><p>iptables -t nat -A POSTROUTING -p TCP -j MASQUERADE –to-ports 21000-31000</p><ul><li>LOG 将数据包相关信息纪录在 &#x2F;var&#x2F;log 中，详细位置请查阅 &#x2F;etc&#x2F;syslog.conf 配置文件，进行完此处理动作后，将会继续比对其它规则。例如：</li></ul><p>iptables -A INPUT -p tcp -j LOG –log-prefix “input packet”</p><ul><li>SNAT 改写封包来源 IP 为某特定 IP 或 IP 范围，可以指定 port 对应的范围，进行完此处理动作后，将直接跳往下一个规则炼（mangle:postrouting）。范例如下：</li></ul><p>iptables -t nat -A POSTROUTING -p tcp-o eth0 -j SNAT –to-source 192.168.10.15-192.168.10.160:2100-3200</p><ul><li>DNAT 改写数据包包目的地 IP 为某特定 IP 或 IP 范围，可以指定 port 对应的范围，进行完此处理动作后，将会直接跳往下一个规则链（filter:input 或 filter:forward）。范例如下：</li></ul><p>iptables -t nat -A PREROUTING -p tcp -d 15.45.23.67 –dport 80 -j DNAT –to-destination 192.168.10.1-192.168.10.10:80-100</p><ul><li><p>MIRROR 镜像数据包，也就是将来源 IP与目的地IP对调后，将数据包返回，进行完此处理动作后，将会中断过滤程序。</p></li><li><p>QUEUE 中断过滤程序，将封包放入队列，交给其它程序处理。透过自行开发的处理程序，可以进行其它应用，例如：计算联机费用等。</p></li><li><p>RETURN 结束在目前规则链中的过滤程序，返回主规则链继续过滤，如果把自订规则炼看成是一个子程序，那么这个动作，就相当于提早结束子程序并返回到主程序中。</p></li><li><p>MARK 将封包标上某个代号，以便提供作为后续过滤的条件判断依据，进行完此处理动作后，将会继续比对其它规则。范例如下：</p></li></ul><p>iptables -t mangle -A PREROUTING -p tcp –dport 22 -j MARK –set-mark 22</p><p>iptables -L -n -v –line-numbers</p><p>iptables -L INPUT -n –line-numbers</p><p>iptables -L OUTPUT -n –line-numbers</p><p>iptables -L OUTPUT -n –line-numbers | less</p><p>iptables -L OUTPUT -n –line-numbers | grep 202.54.1.1</p><p>iptables -I INPUT 2 -s 202.54.1.2 -j DROP</p><p>iptables-restore &lt; &#x2F;root&#x2F;my.active.firewall.rules</p><p>iptables -A INPUT -i eth1 -s 192.168.0.0&#x2F;24 -j DROP</p><p>iptables -A INPUT -i eth1 -s 10.0.0.0&#x2F;8 -j DROP</p><p>iptables -A INPUT -s 1.2.3.4 -j DROP</p><p>iptables -A INPUT -s 192.168.0.0&#x2F;24 -j DROP</p><p>iptables -A INPUT -p tcp -s 1.2.3.4 –dport 80 -j DROP</p><p>iptables -A INPUT -i eth1 -p tcp -s 192.168.1.0&#x2F;24 –dport 80 -j DROP</p><p>iptables -A OUTPUT -d 192.168.1.0&#x2F;24 -j DROP</p><p>iptables -A OUTPUT -o eth1 -d 192.168.1.0&#x2F;24 -j DROP</p><p>iptables -A INPUT -i eth1 -s 10.0.0.0&#x2F;8 -j LOG –log-prefix “IP_SPOOF A: “</p><p>iptables -A INPUT -i eth1 -s 10.0.0.0&#x2F;8 -j DROP</p><p>iptables -A INPUT -m mac –mac-source 00:0F:EA:91:04:08 -j DROP</p><p>只接收MAC地址为00:0F:EA:91:04:07的TCP流量</p><p>iptables -A INPUT -p tcp –destination-port 22 -m mac –mac-source 00:0F:EA:91:04:07 -j ACCEPT</p><p>iptables -A INPUT -p icmp –icmp-type echo-request -j DROP</p><p>iptables -A INPUT -i eth1 -p icmp –icmp-type echo-request -j DROP</p><p>iptables -A INPUT -m state –state NEW -m tcp -p tcp –dport 7000:7010 -j ACCEPT</p><p>iptables -A INPUT -p tcp –destination-port 80 -m iprange –src-range 192.168.1.100-192.168.1.200 -j ACCEPT</p><p>如果想要删除一条规则，那么可以直接使用序号，例如 INPUT 的第 4 条可以直接这么删除</p>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
      <category>network</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>network</tag>
      
      <tag>iptables</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>容器网络模型</title>
    <link href="/2023/11/29/%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/"/>
    <url>/2023/11/29/%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="构建容器网络模型"><a href="#构建容器网络模型" class="headerlink" title="构建容器网络模型"></a>构建容器网络模型</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>在上一节中，通过 Linux 的网络虚拟化技术构建了一个网络，连接了容器的网络Namespace 和宿主机网络，其中做了命名空间创建、设备创建、地址分配、挂载设备和地址转换配置等操作，本节会将这些操作抽象出网络的模型以便于用代码实现上面一系列流程。</p><h2 id="2-模型"><a href="#2-模型" class="headerlink" title="2. 模型"></a>2. 模型</h2><p>首先，需要抽象出容器网络的两个对象：网络和网络端点。</p><h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><p>网络是容器的一个集合，在这个网络上的容器可以通过这个网络互相通信，就像挂载到同一个 Linux Bridge 设备上的网络设备一样， 可以直接通过 Bridge 设备实现网络互连;连接到同一个网络中的容器也可以通过这个网络和网络中别的容器互连。网络中会包括这个网络相关的配置，比如网络的容器地址段、网络操作所调用的网络驱动等信息。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Network <span class="hljs-keyword">struct</span> &#123;<br>Name    <span class="hljs-type">string</span>     <span class="hljs-comment">// 网络名</span><br>IPRange *net.IPNet <span class="hljs-comment">// 地址段</span><br>Driver  <span class="hljs-type">string</span>     <span class="hljs-comment">// 网络驱动名</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="网络端点"><a href="#网络端点" class="headerlink" title="网络端点"></a>网络端点</h3><p>网络端点是用于连接容器与网络的，保证容器内部与网络的通信。像上一节中用到的 Veth 设备，一端挂载到容器内部，另一端挂载到 Bridge 上，就能使得容器和网络的通信。</p><p>网络端点中会包括连接到网络的一些信息，比如地址、Veth 设备、端口映射、连接的容器和网络等信息。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Endpoint <span class="hljs-keyword">struct</span> &#123;<br>ID          <span class="hljs-type">string</span>           <span class="hljs-string">`json:&quot;id&quot;`</span><br>Device      netlink.Veth     <span class="hljs-string">`json:&quot;dev&quot;`</span><br>IPAddress   net.IP           <span class="hljs-string">`json:&quot;ip&quot;`</span><br>MacAddress  net.HardwareAddr <span class="hljs-string">`json:&quot;mac&quot;`</span><br>Network     *Network<br>PortMapping []<span class="hljs-type">string</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="网络驱动"><a href="#网络驱动" class="headerlink" title="网络驱动"></a>网络驱动</h3><p>网络驱动(Network Driver) 是一个网络功能中的组件，不同的驱动对网络的创建、连接、销毁的策略不同，通过在创建网络时指定不同的网络驱动来定义使用哪个驱动做网络的配置。</p><p>它的接口定义如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Driver <span class="hljs-keyword">interface</span> &#123;<br>Name() <span class="hljs-type">string</span><br>Create(subnet <span class="hljs-type">string</span>, name <span class="hljs-type">string</span>) (*Network, <span class="hljs-type">error</span>)<br>Delete(network Network) <span class="hljs-type">error</span><br>Connect(network *Network, endpoint *Endpoint) <span class="hljs-type">error</span><br>Disconnect(network Network, endpoint *Endpoint) <span class="hljs-type">error</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="IPAM"><a href="#IPAM" class="headerlink" title="IPAM"></a>IPAM</h3><p>IPAM(IP Address Management) 也是网络功能中的一个组件，用于网络 IP 地址的分配和释放，包括容器的IP地址和网络网关的IP地址，它的主要功能如下。</p><ul><li>IPAM.Allocate(subnet *net.IPNet) 从指定的 subnet 网段中分配 IP 地址</li><li>IPAM.Release(subnet net.IPNet, ipaddr net.IP) 从指定的 subnet 网段中释放掉指定的 IP 地址。</li></ul><h2 id="3-调用关系"><a href="#3-调用关系" class="headerlink" title="3. 调用关系"></a>3. 调用关系</h2><h3 id="创建网络"><a href="#创建网络" class="headerlink" title="创建网络"></a>创建网络</h3><p>通过<code>mydocker network create</code>命令创建一个容器网络：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mydocker network create --subset 192.168.0.0/24 --deive bridge testbr<br></code></pre></td></tr></table></figure><p>通过 Bridge 网络驱动创建一个网络，网段是 192.168.0.0&#x2F;24。</p><p>具体流程如下图所示：</p><!-- ![](/source/_posts/容器网络模型/网络创建流程.png) --><p><img src="https://github.com/lixd/daily-notes/raw/master/Golang/mydocker/assets/%E7%BD%91%E7%BB%9C%E5%88%9B%E5%BB%BA%E6%B5%81%E7%A8%8B.png"></p><p>在调用命令创建网络时，先通过 IPAM 获取网络的网关 IP,然后再调用网络驱动去设置网络的信息，比如 Bridge 的驱动将会创建 Linux Bridge 网络设备和相应的<br>iptables规则，最终将网络的信息返回给调用者。</p><p>上图中的 IPAM 和 Network Driver 是两个组件，IPAM 负责通过传入的IP网段去分配一个可用的 IP 地址给容器和网络的网关，比如网络的网段是 192.168.0.0&#x2F;16， 那么通过 IPAM 获取这个网段的容器地址就是在这个网段中的一个 IP 地址，然后用于分配给容器的连接端点，保证网络中的容器 IP 不会冲突。</p><p>而 Network Driver 是用于网络的管理的，例如在创建网络时完成网络初始化动作及在容器启动时完成网络端点配置。像 Bridge 的驱动对应的动作就是创建 Linux Bridge 和挂载 Veth 设备。</p><h3 id="创建容器并连接网络"><a href="#创建容器并连接网络" class="headerlink" title="创建容器并连接网络"></a>创建容器并连接网络</h3><p>通过创建容器时指定<code>-net</code> 参数，指定容器启动时连接的网络。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mydocker run -it -p 80:80 --net testbridgenet xxxx<br></code></pre></td></tr></table></figure><p>这样创建出的容器便可以通过 testbridgenet 这个网络与网络中的其他容器进行通信了。</p><p>具体流程图如下：<br><img src="https://github.com/lixd/daily-notes/raw/master/Golang/mydocker/assets/%E5%AE%B9%E5%99%A8%E5%8A%A0%E5%85%A5%E7%BD%91%E7%BB%9C%E6%B5%81%E7%A8%8B.png"><br>在调用创建容器时指定网络，首先会调用IPAM,通过网络中定义的网段找到未分配的 IP 分配给容器，然后创建容器的网络端点，并调用这个网络的网络驱动连接网络与网络端点，最终完成网络端点的连接和配置。比如在 Bridge 驱动中就会将Veth 设备挂载到 Linux Bridge 网桥上。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Connect</span><span class="hljs-params">(networkName <span class="hljs-type">string</span>, info *container.Info)</span></span> <span class="hljs-type">error</span> &#123;<br><span class="hljs-comment">// 从networks字典中取到容器连接的网络的信息，networks字典中保存了当前己经创建的网络</span><br>network, ok := networks[networkName]<br><span class="hljs-keyword">if</span> !ok &#123;<br><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;no Such Network: %s&quot;</span>, networkName)<br>&#125;<br><br><span class="hljs-comment">// 分配容器IP地址</span><br>ip, err := ipAllocator.Allocate(network.IpRange)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><br><span class="hljs-comment">// 创建网络端点</span><br>ep := &amp;Endpoint&#123;<br>ID:          fmt.Sprintf(<span class="hljs-string">&quot;%s-%s&quot;</span>, cinfo.Id, networkName),<br>IPAddress:   ip,<br>Network:     network,<br>PortMapping: info.PortMapping,<br>&#125;<br><span class="hljs-comment">// 调用网络驱动挂载和配置网络端点</span><br><span class="hljs-keyword">if</span> err = drivers[network.Driver].Connect(network, ep); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><span class="hljs-comment">// 到容器的namespace配置容器网络设备IP地址</span><br><span class="hljs-keyword">if</span> err = configEndpointIpAddressAndRoute(ep, info); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><br><span class="hljs-keyword">return</span> configPortMapping(ep, info)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="展示网络列表"><a href="#展示网络列表" class="headerlink" title="展示网络列表"></a>展示网络列表</h3><p>通过 <code>mydocker network list</code>命令显示当前创建了哪些网络。</p><p>首先从网络配置的目录中加载所有的网络配置信息到 networks 字典中，如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Init</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span> &#123;<br><span class="hljs-comment">// 加载网络驱动</span><br><span class="hljs-keyword">var</span> bridgeDriver = BridgeNetworkDriver&#123;&#125;<br>drivers[bridgeDriver.Name()] = &amp;bridgeDriver<br><span class="hljs-comment">// 文件不存在则创建</span><br><span class="hljs-keyword">if</span> _, err := os.Stat(defaultNetworkPath); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">if</span> !os.IsNotExist(err) &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><span class="hljs-keyword">if</span> err = os.MkdirAll(defaultNetworkPath, constant.Perm0644); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br>&#125;<br><span class="hljs-comment">// 检查网络配置目录中的所有文件,并执行第二个参数中的函数指针去处理目录下的每一个文件</span><br>err := filepath.Walk(defaultNetworkPath, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(nwPath <span class="hljs-type">string</span>, info os.FileInfo, err <span class="hljs-type">error</span>)</span></span> <span class="hljs-type">error</span> &#123;<br><span class="hljs-comment">// 如果是目录则跳过</span><br><span class="hljs-keyword">if</span> info.IsDir() &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><span class="hljs-comment">// if strings.HasSuffix(nwPath, &quot;/&quot;) &#123;</span><br><span class="hljs-comment">// return nil</span><br><span class="hljs-comment">// &#125;</span><br><span class="hljs-comment">//  加载文件名作为网络名</span><br>_, nwName := path.Split(nwPath)<br>nw := &amp;Network&#123;<br>Name: nwName,<br>&#125;<br><span class="hljs-comment">// 调用前面介绍的 Network.load 方法加载网络的配置信息</span><br><span class="hljs-keyword">if</span> err = nw.load(nwPath); err != <span class="hljs-literal">nil</span> &#123;<br>logrus.Errorf(<span class="hljs-string">&quot;error load network: %s&quot;</span>, err)<br>&#125;<br><span class="hljs-comment">// 将网络的配置信息加入到 networks 字典中</span><br>networks[nwName] = nw<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;)<br><span class="hljs-keyword">return</span> err<br>&#125;<br></code></pre></td></tr></table></figure><p>上面己经把网络配置目录中的所有网络配置加载到了 networks 典中， 然后通过遍历这个字典来展示创建的网络，如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ListNetwork</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 通过tabwriter库把信息打印到屏幕上</span><br>w := tabwriter.NewWriter(os.Stdout, <span class="hljs-number">12</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-number">0</span>)<br>fmt.Fprint(w, <span class="hljs-string">&quot;NAME\tIpRange\tDriver\n&quot;</span>)<br><span class="hljs-keyword">for</span> _, nw := <span class="hljs-keyword">range</span> networks &#123;<br>fmt.Fprintf(w, <span class="hljs-string">&quot;%s\t%s\t%s\n&quot;</span>,<br>nw.Name,<br>nw.IPRange.String(),<br>nw.Driver,<br>)<br>&#125;<br><span class="hljs-keyword">if</span> err := w.Flush(); err != <span class="hljs-literal">nil</span> &#123;<br>logrus.Errorf(<span class="hljs-string">&quot;Flush error %v&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="删除网络"><a href="#删除网络" class="headerlink" title="删除网络"></a>删除网络</h3><p>通过使用命令 <code>mydocker network remove</code>命令删除己经创建的网络。</p><p>具体流程如下图：</p><p><img src="https://github.com/lixd/daily-notes/blob/master/Golang/mydocker/assets/%E7%BD%91%E7%BB%9C%E5%88%A0%E9%99%A4%E6%B5%81%E7%A8%8B.png"></p><ul><li>1）先调用 IPAM 去释放网络所占用的网关 IP</li><li>2）然后调用网络驱动去删除该网络创建的一些设备与配置</li><li>3）最终从网络配置目录中删除网络对应的配置文</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">DeleteNetwork</span><span class="hljs-params">(networkName <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">error</span> &#123;<br><span class="hljs-comment">// 网络不存在直接返回一个error</span><br>nw, ok := networks[networkName]<br><span class="hljs-keyword">if</span> !ok &#123;<br><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;no Such Network: %s&quot;</span>, networkName)<br>&#125;<br><span class="hljs-comment">// 调用IPAM的实例ipAllocator释放网络网关的IP</span><br><span class="hljs-keyword">if</span> err := ipAllocator.Release(nw.IpRange, &amp;nw.IpRange.IP); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> errors.Wrap(err, <span class="hljs-string">&quot;remove Network gateway ip failed&quot;</span>)<br>&#125;<br><span class="hljs-comment">// 调用网络驱动删除网络创建的设备与配置 后面会以 Bridge 驱动删除网络为例子介绍如何实现网络驱动删除网络</span><br><span class="hljs-keyword">if</span> err := drivers[nw.Driver].Delete(*nw); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> errors.Wrap(err, <span class="hljs-string">&quot;remove Network DriverError failed&quot;</span>)<br>&#125;<br><span class="hljs-comment">// 最后从网络的配直目录中删除该网络对应的配置文件</span><br><span class="hljs-keyword">return</span> nw.remove(defaultNetworkPath)<br>&#125;<br><br></code></pre></td></tr></table></figure><p>其中 network remove 会从网络配置目录中删除网络的配置文件。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(nw *Network)</span></span> remove(dumpPath <span class="hljs-type">string</span>) <span class="hljs-type">error</span> &#123;<br><span class="hljs-comment">// 检查网络对应的配置文件状态，如果文件己经不存在就直接返回</span><br>fullPath := path.Join(dumpPath, nw.Name)<br><span class="hljs-keyword">if</span> _, err := os.Stat(fullPath); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">if</span> !os.IsNotExist(err) &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><span class="hljs-comment">// 否则删除这个网络对应的配置文件</span><br><span class="hljs-keyword">return</span> os.Remove(fullPath)<br>&#125;<br></code></pre></td></tr></table></figure><p>转载自：<a href="https://github.com/lixd/mydocker">https://github.com/lixd/mydocker</a></p>]]></content>
    
    
    <categories>
      
      <category>container</category>
      
    </categories>
    
    
    <tags>
      
      <tag>container</tag>
      
      <tag>virtual network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux虚拟网络设备</title>
    <link href="/2023/11/29/linux%E8%99%9A%E6%8B%9F%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/"/>
    <url>/2023/11/29/linux%E8%99%9A%E6%8B%9F%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/</url>
    
    <content type="html"><![CDATA[<h2 id="Linux-虚拟网络设备"><a href="#Linux-虚拟网络设备" class="headerlink" title="Linux 虚拟网络设备"></a>Linux 虚拟网络设备</h2><h3 id="Linux-Veth"><a href="#Linux-Veth" class="headerlink" title="Linux Veth"></a>Linux Veth</h3><h4 id="veth-pair"><a href="#veth-pair" class="headerlink" title="veth-pair"></a>veth-pair</h4><p>顾名思义，veth-pair 就是一对的虚拟设备接口，和 tap&#x2F;tun 设备不同的是，它都是成对出现的。一端连着协议栈，一端彼此相连着。</p><p>一般用于跨 namespace 通信。</p><blockquote><p>Linux 中默认不同 net namespace 设备无法通信。</p></blockquote><h4 id="网络命名空间"><a href="#网络命名空间" class="headerlink" title="网络命名空间"></a>网络命名空间</h4><p>为了支持网络协议栈的多个实例，Linux在网络栈中引入了网络命名空间。这些独立的协议栈被隔离到不同的命名空间中。</p><h4 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h4><p>本次演示中，先创建一个网络命名空间，然后创建一个 veth 设备对，将设备对分别切换到不同的命名空间中，实现不同命名空间的互相通信。</p><p>准备一个 net namespace</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 1创建 namespace</span><br>$ ip netns add netns1<br><span class="hljs-comment"># 查询</span><br>$ ip netns list<br>netns1 (<span class="hljs-built_in">id</span>: 0)<br></code></pre></td></tr></table></figure><p>创建两个Veth设备对</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># ip link add &lt;veth name&gt; type veth peer name &lt;peer name&gt;</span><br>$ ip <span class="hljs-built_in">link</span> add veth0 <span class="hljs-built_in">type</span> veth peer name veth1<br><span class="hljs-comment"># 查询</span><br>$ ip <span class="hljs-built_in">link</span> show<br></code></pre></td></tr></table></figure><p>此时两个 veth 都在默认 net namespace 中，为了测试，先将其中一个切换到 netns1</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> veth1 netns netns1<br><span class="hljs-comment"># 此时再看就只能看到一个了</span><br>$ ip <span class="hljs-built_in">link</span> show<br><span class="hljs-comment"># 去 netns 中查询</span><br>$ ip netns <span class="hljs-built_in">exec</span> netns1 ip <span class="hljs-built_in">link</span> show<br></code></pre></td></tr></table></figure><p>至此，两个不同的命名空间各自有一个Veth，不过还不能通信，因为我们还没给它们分配IP</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ ip netns <span class="hljs-built_in">exec</span> netns1 ip addr add 10.1.1.1/24 dev veth1<br>$ ip addr add 10.1.1.2/24 dev veth0<br></code></pre></td></tr></table></figure><p>再启动它们</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ ip netns <span class="hljs-built_in">exec</span> netns1 ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> dev veth1 up<br>$ ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> dev veth0 up<br></code></pre></td></tr></table></figure><p>现在两个网络命名空间可以互相通信了</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ ping 10.1.1.1<br></code></pre></td></tr></table></figure><p>至此，Veth设备对的基本原理和用法演示结束。</p><blockquote><p>Docker 内部，Veth设备对也是连通容器与宿主机的主要网络设备。</p></blockquote><h3 id="Linux-Bridge"><a href="#Linux-Bridge" class="headerlink" title="Linux Bridge"></a>Linux Bridge</h3><p>Bridge 虚拟设备是用来桥接的网络设备，它相当于现实世界中的交换机，可以连接不同的网络设备，当请求到达 Bridge 设备时，可以通过报文中的 Mac 地址进行广播或转发。</p><p>例如，我们可以创建一个 Bridge 设备来连接 Namespace 中的网络设备和宿主机上的网络。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">创建veth设备并将一端移动到指定Namespace中</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo ip netns add ns1</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo ip <span class="hljs-built_in">link</span> add veth0 <span class="hljs-built_in">type</span> veth peer name veth1</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> veth1 netns ns1</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">先安装bridge-utils</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo apt-get install bridge-utils</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">创建网桥,</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo brctl addbr br0</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">挂载网络设备</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo brctl addif br0 eth0</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo brctl addif br0 veth0</span><br></code></pre></td></tr></table></figure><p><a href="https://zhuanlan.zhihu.com/p/339070912">linux bridge实践</a></p><h2 id="3-Linux-路由表"><a href="#3-Linux-路由表" class="headerlink" title="3. Linux 路由表"></a>3. Linux 路由表</h2><p>路由表是 Linux 内核的一个模块，通过定义路由表来决定在某个网络Namespace 中包的流向，从而定义请求会到哪个网络设备上。</p><p>继续以上面的例子演示</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">启动宿主机上的虚拟网络设备，</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> veth0 up</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> br0 up</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">给ns1中的虚拟网络设备设置IP并启动它</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo ip netns <span class="hljs-built_in">exec</span> ns1 ip addr add 172.18.0.2/24 dev veth1</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo ip netns <span class="hljs-built_in">exec</span> ns1 ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> dev veth1 up</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">分别设置ns1网络空间的路由和宿主机上的路由</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">default代表0.0.0.0/0,即在Net Namespace中的所有流量都经过veth1的网络设备流出</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo apt-get install net-tools</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo ip netns <span class="hljs-built_in">exec</span> ns1  route add default dev veth1</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">在宿主机上将172.18.0.0/24网段的请求路由到br0网桥</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo route add -net 172.18.0.0/24 dev br0</span><br></code></pre></td></tr></table></figure><p>通过设置路由，对IP地址的请求就能正确被路由到对应的网络设备上，从而实现通信，如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">查看宿主机的IP地址</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo ip addr show eth0</span><br>6: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq master br0 state UP group default qlen 1000<br>    link/ether 00:15:5d:ff:cd:9a brd ff:ff:ff:ff:ff:ff<br>    inet 172.20.160.67/20 brd 172.20.175.255 scope global eth0<br>       valid_lft forever preferred_lft forever<br>    inet6 fe80::215:5dff:feff:cd9a/64 scope link<br>       valid_lft forever preferred_lft forever<br><span class="hljs-meta prompt_">#</span><span class="language-bash">从Namespace中访问宿主机的地址</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo ip netns <span class="hljs-built_in">exec</span> ns1 ping -c 1 172.20.160.67</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">从宿主机访问Namespace中的网络地址</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">ping -c 1 172.18.0.2</span><br></code></pre></td></tr></table></figure><p>到此就实现了通过网桥连接不同Namespace网络了。</p><h2 id="4-Linux-iptables"><a href="#4-Linux-iptables" class="headerlink" title="4. Linux iptables"></a>4. Linux iptables</h2><p>iptables 是对 Linux 内核的 netfilter 模块进行操作和展示的工具，用来管理包的流动和转送。iptables 定义了一套链式处理的结构，在网络包传输的各个阶段可以使用不同的策略对包进行加工、传送或丢弃。</p><p>在容器虚拟化的技术中，经常会用到两种策略 MASQUERADE 和 DNAT，用于容器和宿主机外部的网络通信。</p><h3 id="MASQUERADE"><a href="#MASQUERADE" class="headerlink" title="MASQUERADE"></a>MASQUERADE</h3><p>iptables 中的 MASQUERADE 策略可以将请求包中的源地址转换成一个网络设备的地址。</p><p>比如上述例子中的那个 Namespace 中网络设备的地址是 172.18.0.2, 这个地址虽然在宿主机上可以路由到 br0 网桥，但是到达宿主机外部之后，是不知道如何路由到这个 IP 地址的，所以如果要请求外部地址的话，需要先通过MASQUERADE 策略将这个 IP 转换成宿主机出口网卡的 IP。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">打开IP转发</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo sysctl -w net.ipv4.conf.all.forwarding=1</span><br>net.ipv4.conf.all.forwarding = 1<br><span class="hljs-meta prompt_">#</span><span class="language-bash">对Namespace中发出的包添加网络地址转换</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo iptables -t nat -A POSTROUTING -s 172.18.0.0/24 -o eth0 -j MASQUERADE</span><br></code></pre></td></tr></table></figure><p>在 Namespace 中请求宿主机外部地址时，将 Namespace 中的源地址转换成宿主机的地址作为源地址，就可以在 Namespace 中访问宿主机外的网络了。</p><h3 id="DNAT"><a href="#DNAT" class="headerlink" title="DNAT"></a>DNAT</h3><p>iptables 中的 DNAT 策略也是做网络地址的转换，不过它是要更换目标地址，经常用于将内部网络地址的端口映射到外部去。</p><p>比如，上面那个例子中的 Namespace 如果需要提供服务给宿主机之外的应用去请求要怎么办呢?</p><p>外部应用没办法直接路由到 172.18.0.2 这个地址，这时候就可以用到 DNAT 策略。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">将宿主机上80端口的请求转发到Namespace里的IP上</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo iptables -t nat -A PREROUTING -p tcp -m tcp --dport 80 -j DNAT --to-destination 172.18.0.2:80</span><br></code></pre></td></tr></table></figure><p>这样就可以把宿主机上 80 端口的 TCP 请求转发到 Namespace 中的地址172.18.0.2:80,从而实现外部的应用调用。</p><h2 id="5-Go语言网络库"><a href="#5-Go语言网络库" class="headerlink" title="5. Go语言网络库"></a>5. Go语言网络库</h2><p>容器网络用到的技术就是上面提到的几个点，不过用 Go 语言该怎么配置呢？</p><p>Go 中需要用到的几个网络库介绍。</p><h3 id="net-库"><a href="#net-库" class="headerlink" title="net 库"></a>net 库</h3><p>net 库是 Go 语言内置的库，提供了跨平台支持的网络地址处理，以及各种常见协议的IO支持，比如TCP、UDP、DNS、Unix Socket等。</p><h3 id="netlink库"><a href="#netlink库" class="headerlink" title="netlink库"></a>netlink库</h3><p><a href="https://github.com/vishvananda/netlink">netlink库</a> 是Go 语言的操作网络接口、路由表等配置的库 ，使用它的调用相当于我们通过 IP 命令去管理网络接口。</p><h3 id="netns库"><a href="#netns库" class="headerlink" title="netns库"></a>netns库</h3><p><a href="https://github.com/vishvananda/netns">netns库</a> 就是 Go 语言版的<code>ip netns exec</code> 命令实现。通过这个库可以让 netlink 库中配置网络接口的代码在某个容器的 Net amespace 中执行。</p><h3 id="单节点容器相互访问"><a href="#单节点容器相互访问" class="headerlink" title="单节点容器相互访问"></a>单节点容器相互访问</h3><p><img src="https://pic2.zhimg.com/v2-b3b33ed53fdfd86fff8ace576528f671_b.jpg"></p><p><img src="https://pic2.zhimg.com/80/v2-b3b33ed53fdfd86fff8ace576528f671_1440w.webp"></p><p>veth pair的一端在network namespace中，另一端接在了linux bridge上，所以图中的veth00&#x2F;veth01就变为了从设备（linux bridge），即他们就变为了网线，没有了处理数据包的能力，只能转发数据包。</p><p>以192.268.3.101（container1） → 192.268.3.106（container2）为例：</p><p>1、 container1发送APR请求得到container2的mac地址</p><p>2、 container1的这个请求出现在了docker0网桥</p><p>3、 docker0网桥将ARP广播转发到其他接在docker0上的设备</p><p>4、 container2收到这个ARP请求，响应给container1</p><p>5、 container1拿到mac地址封装ICMP请求</p><p>6、 同样这个请求也会经由docker0出现在宿主机上</p><p>7、 docker0查到container2属于自己就转发给了container2</p><h3 id="容器访问外部网络"><a href="#容器访问外部网络" class="headerlink" title="容器访问外部网络"></a>容器访问外部网络</h3><p><img src="https://pic3.zhimg.com/v2-f7891b35584bd9a960fb042e1a651206_b.jpg"></p><p><img src="https://pic3.zhimg.com/80/v2-f7891b35584bd9a960fb042e1a651206_1440w.webp"></p><p>以图中的container2要访问百度为例：</p><p>1、 container2 ping 220.181.38.148</p><p>2、 数据包同样会到达docker0网桥，即到达了宿主机</p><p>3、宿主机发现目的目的网段要交给eth0处理</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">~# route -n<br>Kernel IP routing table<br>Destination     Gateway         Genmask         Flags Metric Ref    Use Iface<br>0.0.0.0         172.28.143.253  0.0.0.0         UG    100    0        0 eth0<br>172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 docker0<br></code></pre></td></tr></table></figure><p>4、 由于源ip是内网ip还要进行一个NAT，通过eth0发到外网</p><p>转载自: <a href="https://github.com/lixd/daily-notes/blob/master/Golang/mydocker/06-1-%E7%BD%91%E7%BB%9C%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF.md">https://github.com/lixd/daily-notes/blob/master/Golang/mydocker/06-1-%E7%BD%91%E7%BB%9C%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF.md</a></p>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
      <category>network</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux mount用法</title>
    <link href="/2023/11/28/systemcall-mount%E5%88%86%E7%B1%BB/"/>
    <url>/2023/11/28/systemcall-mount%E5%88%86%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="mount-–bind"><a href="#mount-–bind" class="headerlink" title="mount –bind"></a>mount –bind</h2><p>我们可以通过mount –bind命令来将两个目录连接起来，mount –bind命令是将前一个目录挂载到后一个目录上，所有对后一个目录的访问其实都是对前一个目录的访问，如下所示：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-comment">## test1 test2为两个不同的目录</span><br>linux-<span class="hljs-title class_">UMLhEm</span><span class="hljs-symbol">:/home/test/linux</span> <span class="hljs-comment"># ls test1</span><br><span class="hljs-number">11</span>.test  <span class="hljs-number">1</span>.test<br>linux-<span class="hljs-title class_">UMLhEm</span><span class="hljs-symbol">:/home/test/linux</span> <span class="hljs-comment"># ls test2</span><br><span class="hljs-number">22</span>.test  <span class="hljs-number">2</span>.test<br>linux-<span class="hljs-title class_">UMLhEm</span><span class="hljs-symbol">:/home/test/linux</span> <span class="hljs-comment"># ls -lid test1</span><br><span class="hljs-number">1441802</span> drwx------ <span class="hljs-number">2</span> root root <span class="hljs-number">4096</span> <span class="hljs-title class_">Feb</span> <span class="hljs-number">13</span> 09<span class="hljs-symbol">:</span><span class="hljs-number">50</span> test1<br>linux-<span class="hljs-title class_">UMLhEm</span><span class="hljs-symbol">:/home/test/linux</span> <span class="hljs-comment"># ls -lid test2</span><br><span class="hljs-number">1441803</span> drwx------ <span class="hljs-number">2</span> root root <span class="hljs-number">4096</span> <span class="hljs-title class_">Feb</span> <span class="hljs-number">13</span> 09<span class="hljs-symbol">:</span><span class="hljs-number">51</span> test2<br><br><span class="hljs-comment">## 执行mount --bind 将test1挂载到test2上，inode号都变为test1的inode</span><br>linux-<span class="hljs-title class_">UMLhEm</span><span class="hljs-symbol">:/home/test/linux</span> <span class="hljs-comment"># mount --bind test1 test2</span><br>linux-<span class="hljs-title class_">UMLhEm</span><span class="hljs-symbol">:/home/test/linux</span> <span class="hljs-comment"># ls -lid test1</span><br><span class="hljs-number">1441802</span> drwx------ <span class="hljs-number">2</span> root root <span class="hljs-number">4096</span> <span class="hljs-title class_">Feb</span> <span class="hljs-number">13</span> 09<span class="hljs-symbol">:</span><span class="hljs-number">50</span> test1<br>linux-<span class="hljs-title class_">UMLhEm</span><span class="hljs-symbol">:/home/test/linux</span> <span class="hljs-comment"># ls -lid test2</span><br><span class="hljs-number">1441802</span> drwx------ <span class="hljs-number">2</span> root root <span class="hljs-number">4096</span> <span class="hljs-title class_">Feb</span> <span class="hljs-number">13</span> 09<span class="hljs-symbol">:</span><span class="hljs-number">50</span> test2<br>linux-<span class="hljs-title class_">UMLhEm</span><span class="hljs-symbol">:/home/test/linux</span> <span class="hljs-comment"># ls test2</span><br><span class="hljs-number">11</span>.test  <span class="hljs-number">1</span>.test<br><br><span class="hljs-comment">## 对test2的访问或修改实际上是改动test1目录</span><br>linux-<span class="hljs-title class_">UMLhEm</span><span class="hljs-symbol">:/home/test/linux</span> <span class="hljs-comment"># cd test2</span><br>linux-<span class="hljs-title class_">UMLhEm</span><span class="hljs-symbol">:/home/test/linux/test2</span> <span class="hljs-comment"># touch 3.test</span><br>linux-<span class="hljs-title class_">UMLhEm</span><span class="hljs-symbol">:/home/test/linux/test2</span> <span class="hljs-comment"># ls</span><br><span class="hljs-number">11</span>.test  <span class="hljs-number">1</span>.test  <span class="hljs-number">3</span>.test<br>linux-<span class="hljs-title class_">UMLhEm</span><span class="hljs-symbol">:/home/test/linux/test2</span> <span class="hljs-comment"># cd ..</span><br>linux-<span class="hljs-title class_">UMLhEm</span><span class="hljs-symbol">:/home/test/linux</span> <span class="hljs-comment"># ls test1</span><br><span class="hljs-number">11</span>.test  <span class="hljs-number">1</span>.test  <span class="hljs-number">3</span>.test<br><br><span class="hljs-comment">## 解挂载后，test1目录保持修改，test2保持不变</span><br>linux-<span class="hljs-title class_">UMLhEm</span><span class="hljs-symbol">:/home/test/linux</span> <span class="hljs-comment"># umount test2</span><br>linux-<span class="hljs-title class_">UMLhEm</span><span class="hljs-symbol">:/home/test/linux</span> <span class="hljs-comment"># ls test1</span><br><span class="hljs-number">11</span>.test  <span class="hljs-number">1</span>.test  <span class="hljs-number">3</span>.test<br>linux-<span class="hljs-title class_">UMLhEm</span><span class="hljs-symbol">:/home/test/linux</span> <span class="hljs-comment"># ls test2</span><br><span class="hljs-number">22</span>.test  <span class="hljs-number">2</span>.test<br><br><span class="hljs-comment">## 将test2挂载到test1上</span><br>linux-<span class="hljs-title class_">UMLhEm</span><span class="hljs-symbol">:/home/test/linux</span> <span class="hljs-comment"># ls -lid test2</span><br><span class="hljs-number">1441803</span> drwx------ <span class="hljs-number">2</span> root root <span class="hljs-number">4096</span> <span class="hljs-title class_">Feb</span> <span class="hljs-number">13</span> 09<span class="hljs-symbol">:</span><span class="hljs-number">51</span> test2<br>linux-<span class="hljs-title class_">UMLhEm</span><span class="hljs-symbol">:/home/test/linux</span> <span class="hljs-comment"># mount --bind test2 test1</span><br>linux-<span class="hljs-title class_">UMLhEm</span><span class="hljs-symbol">:/home/test/linux</span> <span class="hljs-comment"># ls -lid test1</span><br><span class="hljs-number">1441803</span> drwx------ <span class="hljs-number">2</span> root root <span class="hljs-number">4096</span> <span class="hljs-title class_">Feb</span> <span class="hljs-number">13</span> 09<span class="hljs-symbol">:</span><span class="hljs-number">51</span> test1<br>linux-<span class="hljs-title class_">UMLhEm</span><span class="hljs-symbol">:/home/test/linux</span> <span class="hljs-comment"># ls -lid test2</span><br><span class="hljs-number">1441803</span> drwx------ <span class="hljs-number">2</span> root root <span class="hljs-number">4096</span> <span class="hljs-title class_">Feb</span> <span class="hljs-number">13</span> 09<span class="hljs-symbol">:</span><span class="hljs-number">51</span> test2<br>linux-<span class="hljs-title class_">UMLhEm</span><span class="hljs-symbol">:/home/test/linux</span> <span class="hljs-comment"># ls test1</span><br><span class="hljs-number">22</span>.test  <span class="hljs-number">2</span>.test<br></code></pre></td></tr></table></figure><p>以mount –bind test1 test2为例，当mount –bind命令执行后，Linux将会把被挂载目录的目录项（也就是该目录文件的block，记录了下级目录的信息）屏蔽，即test2的下级路径被隐藏起来了（注意，只是隐藏不是删除，数据都没有改变，只是访问不到了）。同时，内核将挂载目录（test1）的目录项记录在内存里的一个s_root对象里，在mount命令执行时，VFS会创建一个vfsmount对象，这个对象里包含了整个文件系统所有的mount信息，其中也会包括本次mount中的信息，这个对象是一个HASH值对应表（HASH值通过对路径字符串的计算得来），表里就有 &#x2F;test1 到 &#x2F;test2 两个目录的HASH值对应关系。</p><p>命令执行完后，当访问 &#x2F;test2下的文件时，系统会告知 &#x2F;test2 的目录项被屏蔽掉了，自动转到内存里找VFS，通过vfsmount了解到 &#x2F;test2 和 &#x2F;test1 的对应关系，从而读取到 &#x2F;test1 的inode，这样在 &#x2F;test2 下读到的全是 &#x2F;test1 目录下的文件。</p><blockquote><ul><li>.mount –bind连接的两个目录的inode号码并不一样，只是被挂载目录的block被屏蔽掉，inode被重定向到挂载目录的inode（被挂载目录的inode和block依然没变）。</li><li>.两个目录的对应关系存在于内存里，一旦重启挂载关系就不存在了。</li></ul></blockquote><p>在固件开发过程中常常遇到这样的情况：为测试某个新功能，必需修改某个系统文件。而这个文件在只读文件系统上（总不能为一个小小的测试就重刷固件吧），或者是虽然文件可写，但是自己对这个改动没有把握，不愿意直接修改。这时候mount –bind就是你的好帮手。 <br>假设我们要改的文件是&#x2F;etc&#x2F;hosts，可按下面的步骤操作： <br>1. 把新的hosts文件放在&#x2F;tmp下。当然也可放在硬盘或U盘上。 <br>2. mount –bind &#x2F;tmp&#x2F;hosts &#x2F;etc&#x2F;hosts       此时的&#x2F;etc目录是可写的，所做修改不会应用到原来的&#x2F;etc目录，可以放心测试。测试完成了执行 umount &#x2F;etc&#x2F;hosts 断开绑定。</p><p>通过执行下面的命令可以创建一个挂载点：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">mount <span class="hljs-comment">--bind foo foo</span><br></code></pre></td></tr></table></figure><p>在挂载后可以通过mount命令查看所有的挂载点.这样就可以使用一些mount的属性，最简单的例子，例如：</p><blockquote><p>sudo mount,ro –bind test_dir test_dir</p></blockquote><p>可以让test_dir成为一个是read only的目录。无论改目录中的文件夹或者文件的权限是什么，这个文件夹都是只读的。</p><p>如果要递归的挂载一个目录可以使用如下命令.<br>mount –rbind olddir newdir<br>递归的挂载是指如果挂载的olddir内有挂载点，会把这个挂载点也一起挂载到newdir下。</p><h2 id="flags"><a href="#flags" class="headerlink" title="flags"></a>flags</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * These are the fs-independent mount-flags: up to 32 flags are supported </span><br><span class="hljs-comment"> */</span>  <br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_RDONLY        1         <span class="hljs-comment">/* 对应-o ro/rw */</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_NOSUID        2         <span class="hljs-comment">/* 对应-o suid/nosuid */</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_NODEV         4         <span class="hljs-comment">/* 对应-o dev/nodev */</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_NOEXEC        8         <span class="hljs-comment">/* 对应-o exec/noexec */</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_SYNCHRONOUS  16         <span class="hljs-comment">/* 对应-o sync/async */</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_REMOUNT      32         <span class="hljs-comment">/* 对应-o remount，告诉mount这是一次remount操作 */</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_MANDLOCK     64         <span class="hljs-comment">/* 对应-o mand/nomand */</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_DIRSYNC      128        <span class="hljs-comment">/* 对应-o dirsync */</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_NOATIME      1024       <span class="hljs-comment">/* 对应-o atime/noatime */</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_NODIRATIME   2048       <span class="hljs-comment">/* 对应-o diratime/nodiratime */</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_BIND         4096       <span class="hljs-comment">/* 对应-B/--bind选项，告诉mount这是一次bind操作 */</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_MOVE         8192       <span class="hljs-comment">/* 对应-M/--move，告诉mount这是一次move操作 */</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_REC          16384      <span class="hljs-comment">/* rec是recursive的意思，这个flag一般不单独出现，都是伴随这其它flag，表示递归的进行操作 */</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_VERBOSE      32768      <span class="hljs-comment">/* 对应-v/--verbose */</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_SILENT       32768      <span class="hljs-comment">/* 对应-o silent/loud */</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_POSIXACL     (1&lt;&lt;16)    <span class="hljs-comment">/* 让VFS不应用umask，如NFS */</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_UNBINDABLE   (1&lt;&lt;17)    <span class="hljs-comment">/* 对应--make-unbindable */</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_PRIVATE      (1&lt;&lt;18)    <span class="hljs-comment">/* 对应--make-private */</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_SLAVE        (1&lt;&lt;19)    <span class="hljs-comment">/* 对应--make-slave */</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_SHARED       (1&lt;&lt;20)    <span class="hljs-comment">/* 对应--make-shared */</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_RELATIME     (1&lt;&lt;21)    <span class="hljs-comment">/* 对应-o relatime/norelatime */</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_KERNMOUNT    (1&lt;&lt;22)    <span class="hljs-comment">/* 这个一般不在应用层使用，一般内核挂载的文件系统如sysfs使用，表示使用kern_mount()进行挂载 */</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_I_VERSION    (1&lt;&lt;23)    <span class="hljs-comment">/* 对应-o iversion/noiversion */</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_STRICTATIME  (1&lt;&lt;24)    <span class="hljs-comment">/* 对应-o strictatime/nostrictatime */</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_LAZYTIME     (1&lt;&lt;25)    <span class="hljs-comment">/* 对应 -o lazytime/nolazytime*/</span></span><br><br><span class="hljs-comment">/* 下面这几个flags都是内核内部使用的，不由mount系统调用传递 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_SUBMOUNT     (1&lt;&lt;26)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_NOREMOTELOCK (1&lt;&lt;27)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_NOSEC        (1&lt;&lt;28)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_BORN         (1&lt;&lt;29)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_ACTIVE       (1&lt;&lt;30)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_NOUSER       (1&lt;&lt;31)</span><br><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * Superblock flags that can be altered by MS_REMOUNT </span><br><span class="hljs-comment"> */</span>  <br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_RMT_MASK     (MS_RDONLY|MS_SYNCHRONOUS|MS_MANDLOCK|MS_I_VERSION|\                   </span><br>                         MS_LAZYTIME)  <span class="hljs-comment">// 可以在remount时改变的flags  </span><br>  <br><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * Old magic mount flag and mask </span><br><span class="hljs-comment"> */</span>  <br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_MGC_VAL 0xC0ED0000      <span class="hljs-comment">/* magic number */</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_MGC_MSK 0xffff0000      <span class="hljs-comment">/* flags mask */</span></span><br></code></pre></td></tr></table></figure><p>除了上面这些flags对应的mount选项，剩下的基本就是data来传递。</p><h2 id="mount-umount函数详解"><a href="#mount-umount函数详解" class="headerlink" title="mount&#x2F;umount函数详解"></a>mount&#x2F;umount函数详解</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp">功能描述：<br>mount挂上文件系统，umount执行相反的操作。<br>  <br>用法：  <br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mount.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">mount</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *source, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *target,</span></span><br><span class="hljs-params"><span class="hljs-function">   <span class="hljs-type">const</span> <span class="hljs-type">char</span> *filesystemtype, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> mountflags, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *data)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">umount</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *target)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">umount2</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *target, <span class="hljs-type">int</span> flags)</span></span>;<br></code></pre></td></tr></table></figure><p>参数</p><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig"><span class="hljs-string">source</span>：将要挂上的文件系统，通常是一个设备名。<br><span class="hljs-string">target</span>：文件系统所要挂在的目标目录。<br><span class="hljs-string">filesystemtype</span>：文件系统的类型，可以是<span class="hljs-string">&quot;ext2&quot;</span>，<span class="hljs-string">&quot;msdos&quot;</span>，<span class="hljs-string">&quot;proc&quot;</span>，<span class="hljs-string">&quot;nfs&quot;</span>，<span class="hljs-string">&quot;iso9660&quot;</span> 。。。<br><span class="hljs-string">mountflags</span>：指定文件系统的读写访问标志，可能值有以下<br><br><span class="hljs-string">MS_BIND</span>：执行<span class="hljs-string">bind</span>挂载，使文件或者子目录树在文件系统内的另一个点上可视。<br><span class="hljs-string">MS_DIRSYNC</span>：同步目录的更新。<br><span class="hljs-string">MS_MANDLOCK</span>：允许在文件上执行强制锁。<br><span class="hljs-string">MS_MOVE</span>：移动子目录树。<br><span class="hljs-string">MS_NOATIME</span>：不要更新文件上的访问时间。<br><span class="hljs-string">MS_NODEV</span>：不允许访问设备文件。<br><span class="hljs-string">MS_NODIRATIME</span>：不允许更新目录上的访问时间。<br><span class="hljs-string">MS_NOEXEC</span>：不允许在挂上的文件系统上执行程序。<br><span class="hljs-string">MS_NOSUID</span>：执行程序时，不遵照<span class="hljs-built_in">set-user-ID</span> 和 <span class="hljs-built_in">set-group-ID位。</span><br><span class="hljs-string">MS_RDONLY</span>：指定文件系统为只读。<br><span class="hljs-string">MS_REMOUNT</span>：重新加载文件系统。这允许你改变现存文件系统的<span class="hljs-string">mountflag</span>和数据，而无需使用先卸载，再挂上文件系统的方式。<br><span class="hljs-string">MS_SYNCHRONOUS</span>：同步文件的更新。<br><span class="hljs-string">MNT_FORCE</span>：强制卸载，即使文件系统处于忙状态。<br><span class="hljs-string">MNT_EXPIRE</span>：将挂载点标志为过时<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
      <category>filesystem</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>mount</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
