<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Kubernetes Leader Election机制</title>
    <link href="/2023/12/02/Kubernetes-Leader-Election%E6%9C%BA%E5%88%B6/"/>
    <url>/2023/12/02/Kubernetes-Leader-Election%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>分布式应用通常会创建多个service的副本以提高service的可靠性和可伸缩性，但通常有必要指定一个副本负责所有副本之间的协调，kubernetes的SIG已经提供了这方面的能力，主要是通过configmap&#x2F;lease&#x2F;endpoint的资源实现选Leader的功能。通常在<code>Leader Election</code>的选举过程中，会有一组确定的candidates（候选人）都竞相宣称自己是Leader，其中会有一个candidates选举成功。一旦选举获胜，Leader就会按照固定的间隔不断的发送“心跳”以维持其领导人的地位(在稳定的环境中，实例一旦成为了leader，通常情况是不会释放锁的，会保持一直运行的状态，这样有利于业务的稳定和Controller快速的对资源的状态变化做成相应的操作)。其他竞选失败的candidates会周期性地进行新的尝试，以确保当当前的Leader因为某种原因而失败，新的Leader能够被迅速的确定。</p><p>为了执行Kubernetes内部的Leader Election，需要用到Kubernetes API对象的两个属性：</p><ul><li>ResourceVersions - Every API object has a unique ResourceVersion, and you can use these versions to perform compare-and-swap on Kubernetes objects</li><li>Annotations - Every API object can be annotated with arbitrary key&#x2F;value pairs to be used by clients.</li></ul><h2 id="启动选举"><a href="#启动选举" class="headerlink" title="启动选举"></a>启动选举</h2><p>Kubernetes提供了<a href="https://github.com/kubernetes-retired/kube-batch/blob/1ebe60e4af4f164cab0818bc1530e541ed7aa1a5/vendor/k8s.io/client-go/tools/leaderelection/resourcelock/interface.go">Endpoints、ConfigMap 和 Lease</a>三种资源锁，Leader Election 选主的实现方式就是基于这三种资源锁。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-keyword">const</span> (<br>EndpointsResourceLock             = <span class="hljs-string">&quot;endpoints&quot;</span><br>ConfigMapsResourceLock            = <span class="hljs-string">&quot;configmaps&quot;</span><br>LeasesResourceLock                = <span class="hljs-string">&quot;leases&quot;</span><br>)<br></code></pre></td></tr></table></figure><p>开始选举时需要通过那么在开始选举先需要<code>resourcelock.New</code>先通过方法 resourcelock.New 获取资源锁的对象。以kube-batch为例：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs golang">rl, err := resourcelock.New(resourcelock.ConfigMapsResourceLock,<br>opt.LockObjectNamespace,<br><span class="hljs-string">&quot;kube-batch&quot;</span>,<br>leaderElectionClient.CoreV1(),<br>leaderElectionClient.CoordinationV1(),<br>resourcelock.ResourceLockConfig&#123;<br>Identity:      id,<br>EventRecorder: eventRecorder,<br>&#125;)<br></code></pre></td></tr></table></figure><p>也可以通过<code>resourcelock.NewFromKubeconfig</code>的方法创建资源锁，该方法对 resourcelock.New 进行了封装。以control manager为例：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs golang">rl, err := resourcelock.NewFromKubeconfig(resourceLock,  <br>   c.ComponentConfig.Generic.LeaderElection.ResourceNamespace,  <br>   leaseName,  <br>   resourcelock.ResourceLockConfig&#123;  <br>      Identity:      lockIdentity,  <br>      EventRecorder: c.EventRecorder,  <br>   &#125;,  <br>   c.Kubeconfig,  <br>   c.ComponentConfig.Generic.LeaderElection.RenewDeadline.Duration)<br></code></pre></td></tr></table></figure><p>创建好资源锁后，通过<code>leaderelection.RunOrDie</code>启动选举：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs golang">leaderelection.RunOrDie(context.TODO(), leaderelection.LeaderElectionConfig&#123;<br>Lock:          rl,<br>LeaseDuration: leaseDuration,<br>RenewDeadline: renewDeadline,<br>RetryPeriod:   retryPeriod,<br>Callbacks: leaderelection.LeaderCallbacks&#123;<br>OnStartedLeading: run,<br>OnStoppedLeading: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>glog.Fatalf(<span class="hljs-string">&quot;leaderelection lost&quot;</span>)<br>&#125;,<br>&#125;,<br>&#125;)<br></code></pre></td></tr></table></figure><p>其中LeaseDuration为租约时长，非leader的candidate等待LeaseDuration后会强制重新选举；RenewDeadline为leader刷新资源锁超时时间；RetryPeriod为调用资源锁间隔。Callbacks的定义如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-keyword">type</span> LeaderCallbacks <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-comment">// OnStartedLeading is called when a LeaderElector client starts leading</span><br>OnStartedLeading <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(context.Context)</span></span><br><span class="hljs-comment">// OnStoppedLeading is called when a LeaderElector client stops leading</span><br>OnStoppedLeading <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span><br><span class="hljs-comment">// OnNewLeader is called when the client observes a leader that is</span><br><span class="hljs-comment">// not the previously observed leader. This includes the first observed</span><br><span class="hljs-comment">// leader when the client starts.</span><br>OnNewLeader <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(identity <span class="hljs-type">string</span>)</span></span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="选举主流程"><a href="#选举主流程" class="headerlink" title="选举主流程"></a>选举主流程</h2><p>启动选举后，RunOrDie 方法会调用 le.Run(ctx) 方法开始真正的选举流程，le.Run的接口实现为：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(le *LeaderElector)</span></span> Run(ctx context.Context) &#123;<br>  ......  <br>  <span class="hljs-comment">// 竞选获取锁，如果没有获取到，就一直等待</span><br>  <span class="hljs-keyword">if</span> !le.acquire(ctx) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-comment">// ctx signalled done</span><br>  &#125;<br>  ctx, cancel := context.WithCancel(ctx)<br>  <span class="hljs-keyword">defer</span> cancel()<br>  <span class="hljs-comment">// 获取到锁后，需要调用回调函数中的OnStartedLeading，运行controller的代码</span><br>  <span class="hljs-keyword">go</span> le.config.Callbacks.OnStartedLeading(ctx)<br>  <br>  <span class="hljs-comment">// 获取到锁后，需要不断地进行renew操作</span><br>  le.renew(ctx)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="竞选"><a href="#竞选" class="headerlink" title="竞选"></a>竞选</h3><p><code>le.acquire</code>竞选获取锁，如果没有获取到(即没有成为Leader)，则会一直等待。其实现为：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(le *LeaderElector)</span></span> acquire(ctx context.Context) <span class="hljs-type">bool</span> &#123;<br>ctx, cancel := context.WithCancel(ctx)<br><span class="hljs-keyword">defer</span> cancel()<br>succeeded := <span class="hljs-literal">false</span><br><span class="hljs-comment">// wait.JitterUntil间隔 RetryPeriod 执行一次</span><br>wait.JitterUntil(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 竞选</span><br>succeeded = le.tryAcquireOrRenew(ctx)<br><span class="hljs-comment">// leader 变化回调</span><br>le.maybeReportTransition()<br><span class="hljs-comment">// 竞选失败返回</span><br><span class="hljs-keyword">if</span> !succeeded &#123;<br>klog.V(<span class="hljs-number">4</span>).Infof(<span class="hljs-string">&quot;failed to acquire lease %v&quot;</span>, desc)<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-comment">// 成功则退出竞选函数</span><br>le.config.Lock.RecordEvent(<span class="hljs-string">&quot;became leader&quot;</span>)<br>le.metrics.leaderOn(le.config.Name)<br>klog.Infof(<span class="hljs-string">&quot;successfully acquired lease %v&quot;</span>, desc)<br>cancel()<br>&#125;, le.config.RetryPeriod, JitterFactor, <span class="hljs-literal">true</span>, ctx.Done())<br><span class="hljs-keyword">return</span> succeeded<br>&#125;<br></code></pre></td></tr></table></figure><p><code>wait.JitterUntil</code>间隔<code>RetryPeriod</code>执行一次, 若获取锁成功，则会调用ctx的cancel方法中止 wait.JitterUntil 循环。返回<code>succeeded</code>。<br>所以 acquire 函数只会有两种情况会返回：</p><ul><li>当选 leader；</li><li>ctx 被取消（外部要求中止选举流程）</li></ul><h3 id="抢锁"><a href="#抢锁" class="headerlink" title="抢锁"></a>抢锁</h3><p>candidate抢锁关键的实现在于tryAcquireOrRenew，而tryAcquireOrRenew就是依赖锁的状态转移机制完成核心逻辑。其实现为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs gonlang">func (le *LeaderElector) tryAcquireOrRenew(ctx context.Context) bool &#123;<br>  now := metav1.Now()<br>  leaderElectionRecord := rl.LeaderElectionRecord&#123;<br>    HolderIdentity:       le.config.Lock.Identity(),<br>    LeaseDurationSeconds: int(le.config.LeaseDuration / time.Second),<br>    RenewTime:            now,<br>    AcquireTime:          now,<br>  &#125;<br>​<br>  // 1. obtain or create the ElectionRecord<br>  // 检查锁有没有<br>  oldLeaderElectionRecord, oldLeaderElectionRawRecord, err := le.config.Lock.Get(ctx)<br>  if err != nil &#123;<br>    // 没有锁的资源，就创建一个<br>    if !errors.IsNotFound(err) &#123;<br>      klog.Errorf(&quot;error retrieving resource lock %v: %v&quot;, le.config.Lock.Describe(), err)<br>      return false<br>    &#125;<br>    if err = le.config.Lock.Create(ctx, leaderElectionRecord); err != nil &#123;<br>      klog.Errorf(&quot;error initially creating leader election record: %v&quot;, err)<br>      return false<br>    &#125;<br>    //对外宣称自己成为了leader<br>    le.setObservedRecord(&amp;leaderElectionRecord)<br>​<br>    return true<br>  &#125;<br>​<br>  // 2. Record obtained, check the Identity &amp; Time<br>  if !bytes.Equal(le.observedRawRecord, oldLeaderElectionRawRecord) &#123;<br>    // 这个机制很重要，会如果leader会不断正常renew这个锁，oldLeaderElectionRawRecord会一直发生变化，发生变化会更新le.observedTime<br>    le.setObservedRecord(oldLeaderElectionRecord)<br>    le.observedRawRecord = oldLeaderElectionRawRecord<br>  &#125;<br>  <br>  // 如果还没超时并且此实例不是leader（leader是其他实例），那么就直接退出<br>  if len(oldLeaderElectionRecord.HolderIdentity) &gt; 0 &amp;&amp;<br>    le.observedTime.Add(le.config.LeaseDuration).After(now.Time) &amp;&amp;<br>    !le.IsLeader() &#123;<br>    klog.V(4).Infof(&quot;lock is held by %v and has not yet expired&quot;, oldLeaderElectionRecord.HolderIdentity)<br>    return false<br>  &#125;<br>​<br>  // 3. We&#x27;re going to try to update. The leaderElectionRecord is set to it&#x27;s default<br>  // here. Let&#x27;s correct it before updating.<br>  // 如果是leader，就更新时间RenewTime，保证其他实例（非主）可以观察到：主还活着<br>  if le.IsLeader() &#123;<br>    leaderElectionRecord.AcquireTime = oldLeaderElectionRecord.AcquireTime<br>    leaderElectionRecord.LeaderTransitions = oldLeaderElectionRecord.LeaderTransitions<br>  &#125; else &#123;<br>  // 不是leader，那么锁就发生了转移<br>    leaderElectionRecord.LeaderTransitions = oldLeaderElectionRecord.LeaderTransitions + 1<br>  &#125;<br>  <br>  // 更新锁<br>  // update the lock itself<br>  if err = le.config.Lock.Update(ctx, leaderElectionRecord); err != nil &#123;<br>    klog.Errorf(&quot;Failed to update lock: %v&quot;, err)<br>    return false<br>  &#125;<br>​<br>  le.setObservedRecord(&amp;leaderElectionRecord)<br>  return true<br>&#125;<br></code></pre></td></tr></table></figure><p><code>tryAcquireOrRenew</code>的流程</p><ul><li>获取ElectionRecord对象。<ul><li>若ElectionRecord对象不存在，则创建新的ElectionRecord对象，创建成功后宣称成为Leader。</li><li>若ElectionRecord对象存在，则将获取的oldLeaderElectionRecord更新到该le的observedRecord缓存中。<ul><li>若observedRecord不是该le创建且未过期，获取锁失败，退出。</li><li>否则则调用<code> le.config.Lock.Update(leaderElectionRecord)</code>使用该le的信息尝试更新 ElectionRecord对象，更新成功后宣称成为Leader。</li></ul></li></ul></li></ul><h4 id="选举原理"><a href="#选举原理" class="headerlink" title="选举原理"></a>选举原理</h4><p><code>tryAcquireOrRenew</code>的代码的核心逻辑主要为更新<code>le.observedTime</code>,更新的时机为：</p><ul><li>锁（ElectionRecord对象）不存在，创建锁成功时更新；</li><li>获取到锁记录和缓存的不同，说明上次尝试获取锁到现在的间隔内 leader 变化了，更新缓存；</li><li>leader 超期没续期且当前节点抢锁成功，更新缓存。</li></ul><p>如果锁对象不存在或者leader在任期时间内未更新锁对象，则该le会执行抢锁的逻辑，尝试成为新的leader。<br>。</p><h2 id="Leader续期"><a href="#Leader续期" class="headerlink" title="Leader续期"></a>Leader续期</h2><p>在获取到锁成为 leader 后，会进入 le.renew(ctx) 方法进行定期续期操作。其实现如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(le *LeaderElector)</span></span> renew(ctx context.Context) &#123;<br>ctx, cancel := context.WithCancel(ctx)<br><span class="hljs-keyword">defer</span> cancel()<br><span class="hljs-comment">// 定期续期，每 RetryPeriod 执行一次续期</span><br>wait.Until(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>timeoutCtx, timeoutCancel := context.WithTimeout(ctx, le.config.RenewDeadline)<br><span class="hljs-keyword">defer</span> timeoutCancel()<br><span class="hljs-comment">// 执行续期，直到成功或超时</span><br>err := wait.PollImmediateUntil(le.config.RetryPeriod, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> (<span class="hljs-type">bool</span>, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">return</span> le.tryAcquireOrRenew(timeoutCtx), <span class="hljs-literal">nil</span><br>&#125;, timeoutCtx.Done())<br><br>le.maybeReportTransition()<br>desc := le.config.Lock.Describe()<br><span class="hljs-comment">// 若renew成功，则Until会不断循环</span><br><span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &#123;<br>klog.V(<span class="hljs-number">5</span>).Infof(<span class="hljs-string">&quot;successfully renewed lease %v&quot;</span>, desc)<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-comment">// 若renew失败，引发超时错误，说明续期失败，退出续期流程</span><br>le.config.Lock.RecordEvent(<span class="hljs-string">&quot;stopped leading&quot;</span>)<br>le.metrics.leaderOff(le.config.Name)<br>klog.Infof(<span class="hljs-string">&quot;failed to renew lease %v: %v&quot;</span>, desc, err)<br>cancel()<br>&#125;, le.config.RetryPeriod, ctx.Done())<br><br><span class="hljs-comment">// if we hold the lease, give it up</span><br><span class="hljs-keyword">if</span> le.config.ReleaseOnCancel &#123;<br>le.release()<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>renew 方法如果在任期内续期失败则会退出续期循环，主流程结束，其它candidate会尝试成为新的leader。旧的leader若想重新参与竞选，则需要再次调用<code>leaderelection.RunOrDie</code>, Kubernetes的组件一般直接退出，通过重启Pod实现重新参与选举。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Kubelet详解</title>
    <link href="/2023/11/30/Kubelet%E8%AF%A6%E8%A7%A3/"/>
    <url>/2023/11/30/Kubelet%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h2 id="kubelet简介"><a href="#kubelet简介" class="headerlink" title="kubelet简介"></a>kubelet简介</h2><p><img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/06/15/20210613091144.png" alt="Kubernetes 的架构图"></p><p>kubelet 的功能介绍：</p><ul><li>kubelet 是每个 Node 节点上都运行的主要“节点代理”。使用如下的一个向 apiserver 注册 Node 节点：主机的 <code>hostname</code>；覆盖 <code>host</code> 的参数；或者云提供商指定的逻辑。</li><li>kubelet 基于 <code>PodSpec</code> 工作。<code>PodSpec</code> 是用 <code>YAML</code> 或者 <code>JSON</code> 对象来描述 Pod。Kubelet 接受通过各种机制（主要是 apiserver）提供的一组 <code>PodSpec</code>，并确保里面描述的容器良好运行。</li></ul><h2 id="kubelet-架构"><a href="#kubelet-架构" class="headerlink" title="kubelet 架构"></a>kubelet 架构</h2><p><img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/06/15/20210614215508.png" alt="2021-06-14-21-55-08"></p><h3 id="重要组件"><a href="#重要组件" class="headerlink" title="重要组件"></a>重要组件</h3><p>kubelet 的架构由 N 多的组件组成，下面简单介绍下比较重要的几个：</p><h4 id="PLEG"><a href="#PLEG" class="headerlink" title="[PLEG]"></a>[PLEG]</h4><p>即 <strong>Pod Lifecycle Event Generator</strong>，字面意思 Pod 生命周期事件（<code>ContainerStarted</code>、<code>ContainerDied</code>、<code>ContainerRemoved</code>、<code>ContainerChanged</code>）生成器。</p><p>其维护着 Pod 缓存；定期通过 <code>ContainerRuntime</code> 获取 Pod 的信息，与缓存中的信息比较，生成如上的事件；将事件写入其维护的通道（channel）中。</p><h4 id="PodWorkers"><a href="#PodWorkers" class="headerlink" title="[PodWorkers]"></a>[PodWorkers]</h4><p>处理事件中 Pod 的同步。核心方法 <code>managePodLoop()</code> 间接调用 <code>kubelet.syncPod()</code> 完成 Pod 的同步：</p><ul><li>如果 Pod 正在被创建，记录其延迟</li><li>生成 Pod 的 API Status，即 <code>v1.PodStatus</code>：从运行时的 status 转换成 api status</li><li>记录 Pod 从 <code>pending</code> 到 <code>running</code> 的耗时</li><li>在 <code>StatusManager</code> 中更新 pod 的状态</li><li>杀掉不应该运行的 Pod</li><li>如果网络插件未就绪，只启动使用了主机网络（host network）的 Pod</li><li>如果 static pod 不存在，为其创建镜像（Mirror）Pod</li><li>为 Pod 创建文件系统目录：Pod 目录、卷目录、插件目录</li><li>使用 <code>VolumeManager</code> 为 Pod 挂载卷</li><li>获取 image pull secrets</li><li>调用容器运行时（container runtime）的 <code>#SyncPod()</code> 方法</li></ul><h4 id="PodManager"><a href="#PodManager" class="headerlink" title="PodManager"></a><a href="https://atbug.com/kubelet-source-code-analysis/#podmanager">PodManager</a></h4><p>存储 Pod 的期望状态，kubelet 服务的不同渠道的 Pod</p><h4 id="StatsProvider"><a href="#StatsProvider" class="headerlink" title="StatsProvider"></a><a href="https://atbug.com/kubelet-source-code-analysis/#statsprovider">StatsProvider</a></h4><p>提供节点和容器的统计信息，有 <code>cAdvisor</code> 和 <code>CRI</code> 两种实现。</p><h4 id="ContainerRuntime"><a href="#ContainerRuntime" class="headerlink" title="ContainerRuntime"></a><a href="https://atbug.com/kubelet-source-code-analysis/#containerruntime">ContainerRuntime</a></h4><p>顾名思义，容器运行时。与遵循 CRI 规范的高级容器运行时进行交互。</p><h4 id="Deps-PodConfig"><a href="#Deps-PodConfig" class="headerlink" title="Deps.PodConfig"></a><a href="https://atbug.com/kubelet-source-code-analysis/#depspodconfig">Deps.PodConfig</a></h4><p>PodConfig 是一个配置多路复用器，它将许多 Pod 配置源合并成一个单一的一致结构，然后按顺序向监听器传递增量变更通知。</p><p>配置源有：文件、apiserver、HTTP</p><h4 id="SyncLoop"><a href="#SyncLoop" class="headerlink" title="SyncLoop"></a><a href="https://atbug.com/kubelet-source-code-analysis/#syncloop">SyncLoop</a></h4><p>接收来自 <code>PodConfig</code> 的 Pod 变更通知、定时任务、<code>PLEG</code> 的事件，以及 <code>ProbeManager</code> 的事件，将 Pod 同步到<strong>期望状态</strong>。</p><h4 id="PodAdmitHandlers"><a href="#PodAdmitHandlers" class="headerlink" title="PodAdmitHandlers"></a><a href="https://atbug.com/kubelet-source-code-analysis/#podadmithandlers">PodAdmitHandlers</a></h4><p>Pod admission 过程中调用的一系列处理器，比如 eviction handler（节点内存有压力时，不会驱逐 QoS 设置为 <code>BestEffort</code> 的 Pod）、shutdown admit handler（当节点关闭时，不处理 pod 的同步操作）等。</p><h4 id="OOMWatcher"><a href="#OOMWatcher" class="headerlink" title="OOMWatcher"></a><a href="https://atbug.com/kubelet-source-code-analysis/#oomwatcher">OOMWatcher</a></h4><p>从系统日志中获取容器的 OOM 日志，将其封装成事件并记录。</p><h4 id="VolumeManger"><a href="#VolumeManger" class="headerlink" title="VolumeManger"></a><a href="https://atbug.com/kubelet-source-code-analysis/#volumemanger">VolumeManger</a></h4><p>VolumeManager 运行一组异步循环，根据在此节点上调度的 pod 确定需要附加&#x2F;挂载&#x2F;卸载&#x2F;分离哪些卷并执行操作。</p><h4 id="CertificateManager"><a href="#CertificateManager" class="headerlink" title="CertificateManager"></a><a href="https://atbug.com/kubelet-source-code-analysis/#certificatemanager">CertificateManager</a></h4><p>处理证书轮换。</p><h4 id="ProbeManager"><a href="#ProbeManager" class="headerlink" title="ProbeManager"></a><a href="https://atbug.com/kubelet-source-code-analysis/#probemanager">ProbeManager</a></h4><p>实际上包含了三种 Probe，提供 probe 结果缓存和通道。</p><ul><li>LivenessManager</li><li>ReadinessManager</li><li>StartupManager</li></ul><h4 id="EvictionManager"><a href="#EvictionManager" class="headerlink" title="EvictionManager"></a><a href="https://atbug.com/kubelet-source-code-analysis/#evictionmanager">EvictionManager</a></h4><p>监控 Node 节点的资源占用情况，根据驱逐规则驱逐 Pod 释放资源，缓解节点的压力。</p><h4 id="PluginManager"><a href="#PluginManager" class="headerlink" title="PluginManager"></a><a href="https://atbug.com/kubelet-source-code-analysis/#pluginmanager">PluginManager</a></h4><p>PluginManager 运行一组异步循环，根据此节点确定哪些插件需要注册&#x2F;取消注册并执行。如 CSI 驱动和设备管理器插件（Device Plugin）。</p><h5 id="CSI"><a href="#CSI" class="headerlink" title="CSI"></a><a href="https://atbug.com/kubelet-source-code-analysis/#csi">CSI</a></h5><p>Container Storage Interface，由存储厂商实现的存储驱动。</p><h5 id="设备管理器插件（Device-Plugin）"><a href="#设备管理器插件（Device-Plugin）" class="headerlink" title="设备管理器插件（Device Plugin）"></a><a href="https://atbug.com/kubelet-source-code-analysis/#%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86%E5%99%A8%E6%8F%92%E4%BB%B6device-plugin">设备管理器插件（Device Plugin）</a></h5><p>Kubernetes 提供了一个 设备插件框架，你可以用它来将系统硬件资源发布到 Kubelet。</p><p>供应商可以实现设备插件，由你手动部署或作为 DaemonSet 来部署，而不必定制 Kubernetes 本身的代码。目标设备包括 GPU、高性能 NIC、FPGA、 InfiniBand 适配器以及其他类似的、可能需要特定于供应商的初始化和设置的计算资源。</p><h2 id="kubelet-的启动流程"><a href="#kubelet-的启动流程" class="headerlink" title="kubelet 的启动流程"></a><a href="https://atbug.com/kubelet-source-code-analysis/#kubelet-%E7%9A%84%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B">kubelet 的启动流程</a></h2><p>要分析 kubelet 的启动流程，可以从 kubelet 运行方式着手。找一个 Node 节点，很容易就能找到 kubelet 的进程。由于其是以 <code>systemd</code> 的方式启动，也可以通过 <code>systemctl</code> 查看其状态。</p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a><a href="https://atbug.com/kubelet-source-code-analysis/#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90">源码分析</a></h3><p>从 <code>git@github.com:kubernetes/kubernetes.git</code> 仓库获取代码，使用最新的 <code>release-1.21</code> 分支。</p><ul><li><code>cmd/kubelet/kubelet.go:35</code> 的 <code>main</code> 方法为程序入口。<ul><li>调用 <code>NewKubeletCommand</code> 方法，创建 command</li><li>执行 command<ul><li><code>cmd/kubelet/app/server.go:434</code> 的 <code>Run</code> 方法。<ul><li>调用 <code>RunKubelet</code> 方法。<ul><li>调用 <code>createAndInitKubelet</code> 方法，创建并初始化 kubelet<ul><li><code>pkg/kubelet/kubelet.go</code> 的 <code>NewMainKubelet</code> 方法，创建 kubelet的 各种组件。共十几个组件，见 <a href="https://atbug.com/kubelet-source-code-analysis/#kubelet-%E6%9E%B6%E6%9E%84">kubelet 的构架</a>。</li><li>调用 <code>BirtyCry</code> 方法：放出 <code>Starting</code> 事件</li><li>调用 <code>StartGarbageCollection</code> 方法，开启 <code>ContainerGC</code> 和 <code>ImageGC</code></li></ul></li><li>调用 <code>startKubelet</code> 方法（大量使用 goroutine 和通道）<ul><li>goroutine：<code>kubelet.Run()</code><ul><li>初始化模块<ul><li>metrics 相关</li><li>创建文件系统目录目录</li><li>创建容器日志目录</li><li>启动 <code>ImageGCManager</code></li><li>启动 <code>ServerCertificateManager</code></li><li>启动 <code>OOMWatcher</code></li><li>启动 <code>ResourceAnalyzer</code></li></ul></li><li>goroutine：<code>VolumeManager.Run()</code> 开始处理 Pod Volume 的卸载和挂载</li><li>goroutine：状态更新 <code>fastStatusUpdateOnce()</code> （更新 Pod CIDR -&gt; 更新 <code>ContainerRuntime</code> 状态 -&gt; 更新 Node 节点状态）</li><li>goroutine： <code>NodeLeaseController.Run()</code> 更新节点租约</li><li>goroutine：<code>podKiller.PerformPodKillingWork</code> 杀掉未被正确处理的 pod</li><li><code>StatusManager.Start()</code> 开始向 apiserver 更新 Pod 状态</li><li><code>RuntimeClassManager.Start()</code></li><li><code>PLEG.Start()</code>：持续从 <code>ContainerRuntime</code> 获取 Pod&#x2F;容器的状态，并与 kubelet 本地 cache 中的比较，生成对应的 <code>Event</code></li><li><code>syncLoop()</code> 重点，**<em>持续监控并处理来自文件、apiserver、http 的变更</em>**。包括 Pod 的增加、更新、优雅删除、非优雅删除、调和。</li></ul></li></ul></li></ul></li><li>启动 server，暴露 <code>/healthz</code> 端点</li><li>通知 <code>systemd</code> <code>kuberlet</code> 服务已经启动</li></ul></li></ul></li></ul></li></ul><h2 id="kubelet-的工作原理"><a href="#kubelet-的工作原理" class="headerlink" title="kubelet 的工作原理"></a><a href="https://atbug.com/kubelet-source-code-analysis/#kubelet-%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86">kubelet 的工作原理</a></h2><p><img src="https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/06/15/20210615000611.png"></p><ol><li>静态文件、apiserver 以及 HTTP 请求的 Pod 配置变更，被发送到 <code>kubelet.syncLoop</code></li><li>PLEG 会定期通过容器运行时获取节点上 Pod 的状态，与其缓存中的 Pod 信息进行比较，封装成事件，进入 PLEG 的通道</li><li>定期检查工作队列中的 Pod</li><li>ProbeManager 的通道中的 Pod</li><li>以上 1~4，都会进入 <code>syncLoopIteration</code>，并从对应的通道中获取到对应 Pod，将 Pod 的信息保存到 <code>PodManager</code>；然后分发给 <code>PodWorker</code>，[完成一些列的同步工作]</li></ol><p>转载自：<a href="https://atbug.com/kubelet-source-code-analysis/#syncloop">https://atbug.com/kubelet-source-code-analysis/#syncloop</a></p>]]></content>
    
    
    <categories>
      
      <category>kubernetes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>kubernetes</tag>
      
      <tag>kubelet</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Containerd详解</title>
    <link href="/2023/11/30/Containerd%E8%AF%A6%E8%A7%A3/"/>
    <url>/2023/11/30/Containerd%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p>containerd 是一个工业级标准的容器运行时，它强调<strong>简单性</strong>、<strong>健壮性</strong>和<strong>可移植性</strong>，containerd 可以负责干下面这些事情：</p><ul><li>管理容器的生命周期（从创建容器到销毁容器）</li><li>拉取&#x2F;推送容器镜像</li><li>存储管理（管理镜像及容器数据的存储）</li><li>调用 runc 运行容器（与 runc 等容器运行时交互）</li><li>管理容器网络接口及网络</li></ul><h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><p>containerd 可用作 Linux 和 Windows 的守护程序，它管理其主机系统完整的容器生命周期，从镜像传输和存储到容器执行和监测，再到底层存储到网络附件等等。</p><p><img src="https://picdn.youdianzhishi.com/images/20210810134700.png" alt="containerd 架构"></p><p>上图是 containerd 官方提供的架构图，可以看出 containerd 采用的也是 C&#x2F;S 架构，服务端通过 unix domain socket 暴露低层的 gRPC API 接口出去，客户端通过这些 API 管理节点上的容器，每个 containerd 只负责一台机器，Pull 镜像，对容器的操作（启动、停止等），网络，存储都是由 containerd 完成。具体运行容器由 runc 负责，实际上只要是符合 OCI 规范的容器都可以支持。</p><p>为了解耦，containerd 将系统划分成了不同的组件，每个组件都由一个或多个模块协作完成（Core 部分），每一种类型的模块都以插件的形式集成到 Containerd 中，而且插件之间是相互依赖的，例如，上图中的每一个长虚线的方框都表示一种类型的插件，包括 Service Plugin、Metadata Plugin、GC Plugin、Runtime Plugin 等，其中 Service Plugin 又会依赖 Metadata Plugin、GC Plugin 和 Runtime Plugin。每一个小方框都表示一个细分的插件，例如 Metadata Plugin 依赖 Containers Plugin、Content Plugin 等。比如:</p><ul><li><code>Content Plugin</code>: 提供对镜像中可寻址内容的访问，所有不可变的内容都被存储在这里。</li><li><code>Snapshot Plugin</code>: 用来管理容器镜像的文件系统快照，镜像中的每一层都会被解压成文件系统快照，类似于 Docker 中的 graphdriver。</li></ul><p>总体来看 containerd 可以分为三个大块：Storage、Metadata 和 Runtime。</p><p><img src="https://picdn.youdianzhishi.com/images/20210810145929.png" alt="containerd 架构2"></p><h2 id="contained安装与使用"><a href="#contained安装与使用" class="headerlink" title="contained安装与使用"></a>contained安装与使用</h2><p>这里我使用的系统是 <code>Linux Mint 20.2</code>，首先需要安装 <code>seccomp</code> 依赖：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">➜  ~ apt-get update<br>➜  ~ apt-get install libseccomp2 -y<br></code></pre></td></tr></table></figure><p>由于 containerd 需要调用 runc，所以我们也需要先安装 runc，不过 containerd 提供了一个包含相关依赖的压缩包 <code>cri-containerd-cni-$&#123;VERSION&#125;.$&#123;OS&#125;-$&#123;ARCH&#125;.tar.gz</code>，可以直接使用这个包来进行安装。首先从 <a href="https://github.com/containerd/containerd/releases">release 页面</a>下载最新版本的压缩包，当前为 1.5.5 版本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">➜  ~ wget https://github.com/containerd/containerd/releases/download/v1.5.5/cri-containerd-cni-1.5.5-linux-amd64.tar.gz<br><span class="hljs-meta prompt_"># </span><span class="language-bash">如果有限制，也可以替换成下面的 URL 加速下载</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">wget https://download.fastgit.org/containerd/containerd/releases/download/v1.5.5/cri-containerd-cni-1.5.5-linux-amd64.tar.gz</span><br></code></pre></td></tr></table></figure><p>可以通过 tar 的 <code>-t</code> 选项直接看到压缩包中包含哪些文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs shell">➜  ~ tar -tf cri-containerd-cni-1.4.3-linux-amd64.tar.gz<br>etc/<br>etc/cni/<br>etc/cni/net.d/<br>etc/cni/net.d/10-containerd-net.conflist<br>etc/crictl.yaml<br>etc/systemd/<br>etc/systemd/system/<br>etc/systemd/system/containerd.service<br>usr/<br>usr/local/<br>usr/local/bin/<br>usr/local/bin/containerd-shim-runc-v2<br>usr/local/bin/ctr<br>usr/local/bin/containerd-shim<br>usr/local/bin/containerd-shim-runc-v1<br>usr/local/bin/crictl<br>usr/local/bin/critest<br>usr/local/bin/containerd<br>usr/local/sbin/<br>usr/local/sbin/runc<br>opt/<br>opt/cni/<br>opt/cni/bin/<br>opt/cni/bin/vlan<br>opt/cni/bin/host-local<br>opt/cni/bin/flannel<br>opt/cni/bin/bridge<br>opt/cni/bin/host-device<br>opt/cni/bin/tuning<br>opt/cni/bin/firewall<br>opt/cni/bin/bandwidth<br>opt/cni/bin/ipvlan<br>opt/cni/bin/sbr<br>opt/cni/bin/dhcp<br>opt/cni/bin/portmap<br>opt/cni/bin/ptp<br>opt/cni/bin/static<br>opt/cni/bin/macvlan<br>opt/cni/bin/loopback<br>opt/containerd/<br>opt/containerd/cluster/<br>opt/containerd/cluster/version<br>opt/containerd/cluster/gce/<br>opt/containerd/cluster/gce/cni.template<br>opt/containerd/cluster/gce/configure.sh<br>opt/containerd/cluster/gce/cloud-init/<br>opt/containerd/cluster/gce/cloud-init/master.yaml<br>opt/containerd/cluster/gce/cloud-init/node.yaml<br>opt/containerd/cluster/gce/env<br></code></pre></td></tr></table></figure><p>直接将压缩包解压到系统的各个目录中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">➜  ~ tar -C / -xzf cri-containerd-cni-1.5.5-linux-amd64.tar.gz<br></code></pre></td></tr></table></figure><p>当然要记得将 <code>/usr/local/bin</code> 和 <code>/usr/local/sbin</code> 追加到 <code>~/.bashrc</code> 文件的 <code>PATH</code> 环境变量中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">export PATH=$PATH:/usr/local/bin:/usr/local/sbin<br></code></pre></td></tr></table></figure><p>然后执行下面的命令使其立即生效：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">➜  ~ source ~/.bashrc<br></code></pre></td></tr></table></figure><p>containerd 的默认配置文件为 <code>/etc/containerd/config.toml</code>，我们可以通过如下所示的命令生成一个默认的配置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">➜  ~ mkdir /etc/containerd<br>➜  ~ containerd config default &gt; /etc/containerd/config.toml<br></code></pre></td></tr></table></figure><p>由于上面我们下在的 containerd 压缩包中包含一个 <code>etc/systemd/system/containerd.service</code> 的文件，这样我们就可以通过 systemd 来配置 containerd 作为守护进程运行了，内容如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs shell">➜  ~ cat /etc/systemd/system/containerd.service<br>[Unit]<br>Description=containerd container runtime<br>Documentation=https://containerd.io<br>After=network.target local-fs.target<br><br>[Service]<br>ExecStartPre=-/sbin/modprobe overlay<br>ExecStart=/usr/local/bin/containerd<br><br>Type=notify<br>Delegate=yes<br>KillMode=process<br>Restart=always<br>RestartSec=5<br><span class="hljs-meta prompt_"># </span><span class="language-bash">Having non-zero Limit*s causes performance problems due to accounting overhead</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-keyword">in</span> the kernel. We recommend using cgroups to <span class="hljs-keyword">do</span> container-local accounting.</span><br>LimitNPROC=infinity<br>LimitCORE=infinity<br>LimitNOFILE=1048576<br><span class="hljs-meta prompt_"># </span><span class="language-bash">Comment TasksMax <span class="hljs-keyword">if</span> your systemd version does not supports it.</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Only systemd 226 and above support this version.</span><br>TasksMax=infinity<br>OOMScoreAdjust=-999<br><br>[Install]<br>WantedBy=multi-user.target<br></code></pre></td></tr></table></figure><p>这里有两个重要的参数：</p><ul><li><p><code>Delegate</code>: 这个选项允许 containerd 以及运行时自己管理自己创建容器的 cgroups。如果不设置这个选项，systemd 就会将进程移到自己的 cgroups 中，从而导致 containerd 无法正确获取容器的资源使用情况。</p></li><li><p><code>KillMode</code>: 这个选项用来处理 containerd 进程被杀死的方式。默认情况下，systemd 会在进程的 cgroup 中查找并杀死 containerd 的所有子进程。KillMode 字段可以设置的值如下。</p><ul><li><code>control-group</code>（默认值）：当前控制组里面的所有子进程，都会被杀掉</li><li><code>process</code>：只杀主进程</li><li><code>mixed</code>：主进程将收到 SIGTERM 信号，子进程收到 SIGKILL 信号</li><li><code>none</code>：没有进程会被杀掉，只是执行服务的 stop 命令</li></ul></li></ul><p>我们需要将 KillMode 的值设置为 process，这样可以确保升级或重启 containerd 时不杀死现有的容器。</p><p>现在我们就可以启动 containerd 了，直接执行下面的命令即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">➜  ~ systemctl enable containerd --now<br></code></pre></td></tr></table></figure><p>启动完成后就可以使用 containerd 的本地 CLI 工具 <code>ctr</code> 了，比如查看版本：</p><p><img src="https://picdn.youdianzhishi.com/images/20210810164519.png" alt="ctr version"></p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>我们首先来查看下上面默认生成的配置文件 <code>/etc/containerd/config.toml</code>：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br></pre></td><td class="code"><pre><code class="hljs toml"><span class="hljs-attr">disabled_plugins</span> = []<br><span class="hljs-attr">imports</span> = []<br><span class="hljs-attr">oom_score</span> = <span class="hljs-number">0</span><br><span class="hljs-attr">plugin_dir</span> = <span class="hljs-string">&quot;&quot;</span><br><span class="hljs-attr">required_plugins</span> = []<br><span class="hljs-attr">root</span> = <span class="hljs-string">&quot;/var/lib/containerd&quot;</span><br><span class="hljs-attr">state</span> = <span class="hljs-string">&quot;/run/containerd&quot;</span><br><span class="hljs-attr">version</span> = <span class="hljs-number">2</span><br><br><span class="hljs-section">[cgroup]</span><br>  <span class="hljs-attr">path</span> = <span class="hljs-string">&quot;&quot;</span><br><br><span class="hljs-section">[debug]</span><br>  <span class="hljs-attr">address</span> = <span class="hljs-string">&quot;&quot;</span><br>  <span class="hljs-attr">format</span> = <span class="hljs-string">&quot;&quot;</span><br>  <span class="hljs-attr">gid</span> = <span class="hljs-number">0</span><br>  <span class="hljs-attr">level</span> = <span class="hljs-string">&quot;&quot;</span><br>  <span class="hljs-attr">uid</span> = <span class="hljs-number">0</span><br><br><span class="hljs-section">[grpc]</span><br>  <span class="hljs-attr">address</span> = <span class="hljs-string">&quot;/run/containerd/containerd.sock&quot;</span><br>  <span class="hljs-attr">gid</span> = <span class="hljs-number">0</span><br>  <span class="hljs-attr">max_recv_message_size</span> = <span class="hljs-number">16777216</span><br>  <span class="hljs-attr">max_send_message_size</span> = <span class="hljs-number">16777216</span><br>  <span class="hljs-attr">tcp_address</span> = <span class="hljs-string">&quot;&quot;</span><br>  <span class="hljs-attr">tcp_tls_cert</span> = <span class="hljs-string">&quot;&quot;</span><br>  <span class="hljs-attr">tcp_tls_key</span> = <span class="hljs-string">&quot;&quot;</span><br>  <span class="hljs-attr">uid</span> = <span class="hljs-number">0</span><br><br><span class="hljs-section">[metrics]</span><br>  <span class="hljs-attr">address</span> = <span class="hljs-string">&quot;&quot;</span><br>  <span class="hljs-attr">grpc_histogram</span> = <span class="hljs-literal">false</span><br><br><span class="hljs-section">[plugins]</span><br><br>  <span class="hljs-section">[plugins.&quot;io.containerd.gc.v1.scheduler&quot;]</span><br>    <span class="hljs-attr">deletion_threshold</span> = <span class="hljs-number">0</span><br>    <span class="hljs-attr">mutation_threshold</span> = <span class="hljs-number">100</span><br>    <span class="hljs-attr">pause_threshold</span> = <span class="hljs-number">0.02</span><br>    <span class="hljs-attr">schedule_delay</span> = <span class="hljs-string">&quot;0s&quot;</span><br>    <span class="hljs-attr">startup_delay</span> = <span class="hljs-string">&quot;100ms&quot;</span><br><br>  <span class="hljs-section">[plugins.&quot;io.containerd.grpc.v1.cri&quot;]</span><br>    <span class="hljs-attr">disable_apparmor</span> = <span class="hljs-literal">false</span><br>    <span class="hljs-attr">disable_cgroup</span> = <span class="hljs-literal">false</span><br>    <span class="hljs-attr">disable_hugetlb_controller</span> = <span class="hljs-literal">true</span><br>    <span class="hljs-attr">disable_proc_mount</span> = <span class="hljs-literal">false</span><br>    <span class="hljs-attr">disable_tcp_service</span> = <span class="hljs-literal">true</span><br>    <span class="hljs-attr">enable_selinux</span> = <span class="hljs-literal">false</span><br>    <span class="hljs-attr">enable_tls_streaming</span> = <span class="hljs-literal">false</span><br>    <span class="hljs-attr">ignore_image_defined_volumes</span> = <span class="hljs-literal">false</span><br>    <span class="hljs-attr">max_concurrent_downloads</span> = <span class="hljs-number">3</span><br>    <span class="hljs-attr">max_container_log_line_size</span> = <span class="hljs-number">16384</span><br>    <span class="hljs-attr">netns_mounts_under_state_dir</span> = <span class="hljs-literal">false</span><br>    <span class="hljs-attr">restrict_oom_score_adj</span> = <span class="hljs-literal">false</span><br>    <span class="hljs-attr">sandbox_image</span> = <span class="hljs-string">&quot;k8s.gcr.io/pause:3.5&quot;</span><br>    <span class="hljs-attr">selinux_category_range</span> = <span class="hljs-number">1024</span><br>    <span class="hljs-attr">stats_collect_period</span> = <span class="hljs-number">10</span><br>    <span class="hljs-attr">stream_idle_timeout</span> = <span class="hljs-string">&quot;4h0m0s&quot;</span><br>    <span class="hljs-attr">stream_server_address</span> = <span class="hljs-string">&quot;127.0.0.1&quot;</span><br>    <span class="hljs-attr">stream_server_port</span> = <span class="hljs-string">&quot;0&quot;</span><br>    <span class="hljs-attr">systemd_cgroup</span> = <span class="hljs-literal">false</span><br>    <span class="hljs-attr">tolerate_missing_hugetlb_controller</span> = <span class="hljs-literal">true</span><br>    <span class="hljs-attr">unset_seccomp_profile</span> = <span class="hljs-string">&quot;&quot;</span><br><br>    <span class="hljs-section">[plugins.&quot;io.containerd.grpc.v1.cri&quot;.cni]</span><br>      <span class="hljs-attr">bin_dir</span> = <span class="hljs-string">&quot;/opt/cni/bin&quot;</span><br>      <span class="hljs-attr">conf_dir</span> = <span class="hljs-string">&quot;/etc/cni/net.d&quot;</span><br>      <span class="hljs-attr">conf_template</span> = <span class="hljs-string">&quot;&quot;</span><br>      <span class="hljs-attr">max_conf_num</span> = <span class="hljs-number">1</span><br><br>    <span class="hljs-section">[plugins.&quot;io.containerd.grpc.v1.cri&quot;.containerd]</span><br>      <span class="hljs-attr">default_runtime_name</span> = <span class="hljs-string">&quot;runc&quot;</span><br>      <span class="hljs-attr">disable_snapshot_annotations</span> = <span class="hljs-literal">true</span><br>      <span class="hljs-attr">discard_unpacked_layers</span> = <span class="hljs-literal">false</span><br>      <span class="hljs-attr">no_pivot</span> = <span class="hljs-literal">false</span><br>      <span class="hljs-attr">snapshotter</span> = <span class="hljs-string">&quot;overlayfs&quot;</span><br><br>      <span class="hljs-section">[plugins.&quot;io.containerd.grpc.v1.cri&quot;.containerd.default_runtime]</span><br>        <span class="hljs-attr">base_runtime_spec</span> = <span class="hljs-string">&quot;&quot;</span><br>        <span class="hljs-attr">container_annotations</span> = []<br>        <span class="hljs-attr">pod_annotations</span> = []<br>        <span class="hljs-attr">privileged_without_host_devices</span> = <span class="hljs-literal">false</span><br>        <span class="hljs-attr">runtime_engine</span> = <span class="hljs-string">&quot;&quot;</span><br>        <span class="hljs-attr">runtime_root</span> = <span class="hljs-string">&quot;&quot;</span><br>        <span class="hljs-attr">runtime_type</span> = <span class="hljs-string">&quot;&quot;</span><br><br>        <span class="hljs-section">[plugins.&quot;io.containerd.grpc.v1.cri&quot;.containerd.default_runtime.options]</span><br><br>      <span class="hljs-section">[plugins.&quot;io.containerd.grpc.v1.cri&quot;.containerd.runtimes]</span><br><br>        <span class="hljs-section">[plugins.&quot;io.containerd.grpc.v1.cri&quot;.containerd.runtimes.runc]</span><br>          <span class="hljs-attr">base_runtime_spec</span> = <span class="hljs-string">&quot;&quot;</span><br>          <span class="hljs-attr">container_annotations</span> = []<br>          <span class="hljs-attr">pod_annotations</span> = []<br>          <span class="hljs-attr">privileged_without_host_devices</span> = <span class="hljs-literal">false</span><br>          <span class="hljs-attr">runtime_engine</span> = <span class="hljs-string">&quot;&quot;</span><br>          <span class="hljs-attr">runtime_root</span> = <span class="hljs-string">&quot;&quot;</span><br>          <span class="hljs-attr">runtime_type</span> = <span class="hljs-string">&quot;io.containerd.runc.v2&quot;</span><br><br>          <span class="hljs-section">[plugins.&quot;io.containerd.grpc.v1.cri&quot;.containerd.runtimes.runc.options]</span><br>            <span class="hljs-attr">BinaryName</span> = <span class="hljs-string">&quot;&quot;</span><br>            <span class="hljs-attr">CriuImagePath</span> = <span class="hljs-string">&quot;&quot;</span><br>            <span class="hljs-attr">CriuPath</span> = <span class="hljs-string">&quot;&quot;</span><br>            <span class="hljs-attr">CriuWorkPath</span> = <span class="hljs-string">&quot;&quot;</span><br>            <span class="hljs-attr">IoGid</span> = <span class="hljs-number">0</span><br>            <span class="hljs-attr">IoUid</span> = <span class="hljs-number">0</span><br>            <span class="hljs-attr">NoNewKeyring</span> = <span class="hljs-literal">false</span><br>            <span class="hljs-attr">NoPivotRoot</span> = <span class="hljs-literal">false</span><br>            <span class="hljs-attr">Root</span> = <span class="hljs-string">&quot;&quot;</span><br>            <span class="hljs-attr">ShimCgroup</span> = <span class="hljs-string">&quot;&quot;</span><br>            <span class="hljs-attr">SystemdCgroup</span> = <span class="hljs-literal">false</span><br><br>      <span class="hljs-section">[plugins.&quot;io.containerd.grpc.v1.cri&quot;.containerd.untrusted_workload_runtime]</span><br>        <span class="hljs-attr">base_runtime_spec</span> = <span class="hljs-string">&quot;&quot;</span><br>        <span class="hljs-attr">container_annotations</span> = []<br>        <span class="hljs-attr">pod_annotations</span> = []<br>        <span class="hljs-attr">privileged_without_host_devices</span> = <span class="hljs-literal">false</span><br>        <span class="hljs-attr">runtime_engine</span> = <span class="hljs-string">&quot;&quot;</span><br>        <span class="hljs-attr">runtime_root</span> = <span class="hljs-string">&quot;&quot;</span><br>        <span class="hljs-attr">runtime_type</span> = <span class="hljs-string">&quot;&quot;</span><br><br>        <span class="hljs-section">[plugins.&quot;io.containerd.grpc.v1.cri&quot;.containerd.untrusted_workload_runtime.options]</span><br><br>    <span class="hljs-section">[plugins.&quot;io.containerd.grpc.v1.cri&quot;.image_decryption]</span><br>      <span class="hljs-attr">key_model</span> = <span class="hljs-string">&quot;node&quot;</span><br><br>    <span class="hljs-section">[plugins.&quot;io.containerd.grpc.v1.cri&quot;.registry]</span><br>      <span class="hljs-attr">config_path</span> = <span class="hljs-string">&quot;&quot;</span><br><br>      <span class="hljs-section">[plugins.&quot;io.containerd.grpc.v1.cri&quot;.registry.auths]</span><br><br>      <span class="hljs-section">[plugins.&quot;io.containerd.grpc.v1.cri&quot;.registry.configs]</span><br><br>      <span class="hljs-section">[plugins.&quot;io.containerd.grpc.v1.cri&quot;.registry.headers]</span><br><br>      <span class="hljs-section">[plugins.&quot;io.containerd.grpc.v1.cri&quot;.registry.mirrors]</span><br><br>    <span class="hljs-section">[plugins.&quot;io.containerd.grpc.v1.cri&quot;.x509_key_pair_streaming]</span><br>      <span class="hljs-attr">tls_cert_file</span> = <span class="hljs-string">&quot;&quot;</span><br>      <span class="hljs-attr">tls_key_file</span> = <span class="hljs-string">&quot;&quot;</span><br><br>  <span class="hljs-section">[plugins.&quot;io.containerd.internal.v1.opt&quot;]</span><br>    <span class="hljs-attr">path</span> = <span class="hljs-string">&quot;/opt/containerd&quot;</span><br><br>  <span class="hljs-section">[plugins.&quot;io.containerd.internal.v1.restart&quot;]</span><br>    <span class="hljs-attr">interval</span> = <span class="hljs-string">&quot;10s&quot;</span><br><br>  <span class="hljs-section">[plugins.&quot;io.containerd.metadata.v1.bolt&quot;]</span><br>    <span class="hljs-attr">content_sharing_policy</span> = <span class="hljs-string">&quot;shared&quot;</span><br><br>  <span class="hljs-section">[plugins.&quot;io.containerd.monitor.v1.cgroups&quot;]</span><br>    <span class="hljs-attr">no_prometheus</span> = <span class="hljs-literal">false</span><br><br>  <span class="hljs-section">[plugins.&quot;io.containerd.runtime.v1.linux&quot;]</span><br>    <span class="hljs-attr">no_shim</span> = <span class="hljs-literal">false</span><br>    <span class="hljs-attr">runtime</span> = <span class="hljs-string">&quot;runc&quot;</span><br>    <span class="hljs-attr">runtime_root</span> = <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-attr">shim</span> = <span class="hljs-string">&quot;containerd-shim&quot;</span><br>    <span class="hljs-attr">shim_debug</span> = <span class="hljs-literal">false</span><br><br>  <span class="hljs-section">[plugins.&quot;io.containerd.runtime.v2.task&quot;]</span><br>    <span class="hljs-attr">platforms</span> = [<span class="hljs-string">&quot;linux/amd64&quot;</span>]<br><br>  <span class="hljs-section">[plugins.&quot;io.containerd.service.v1.diff-service&quot;]</span><br>    <span class="hljs-attr">default</span> = [<span class="hljs-string">&quot;walking&quot;</span>]<br><br>  <span class="hljs-section">[plugins.&quot;io.containerd.snapshotter.v1.aufs&quot;]</span><br>    <span class="hljs-attr">root_path</span> = <span class="hljs-string">&quot;&quot;</span><br><br>  <span class="hljs-section">[plugins.&quot;io.containerd.snapshotter.v1.btrfs&quot;]</span><br>    <span class="hljs-attr">root_path</span> = <span class="hljs-string">&quot;&quot;</span><br><br>  <span class="hljs-section">[plugins.&quot;io.containerd.snapshotter.v1.devmapper&quot;]</span><br>    <span class="hljs-attr">async_remove</span> = <span class="hljs-literal">false</span><br>    <span class="hljs-attr">base_image_size</span> = <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-attr">pool_name</span> = <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-attr">root_path</span> = <span class="hljs-string">&quot;&quot;</span><br><br>  <span class="hljs-section">[plugins.&quot;io.containerd.snapshotter.v1.native&quot;]</span><br>    <span class="hljs-attr">root_path</span> = <span class="hljs-string">&quot;&quot;</span><br><br>  <span class="hljs-section">[plugins.&quot;io.containerd.snapshotter.v1.overlayfs&quot;]</span><br>    <span class="hljs-attr">root_path</span> = <span class="hljs-string">&quot;&quot;</span><br><br>  <span class="hljs-section">[plugins.&quot;io.containerd.snapshotter.v1.zfs&quot;]</span><br>    <span class="hljs-attr">root_path</span> = <span class="hljs-string">&quot;&quot;</span><br><br><span class="hljs-section">[proxy_plugins]</span><br><br><span class="hljs-section">[stream_processors]</span><br><br>  <span class="hljs-section">[stream_processors.&quot;io.containerd.ocicrypt.decoder.v1.tar&quot;]</span><br>    <span class="hljs-attr">accepts</span> = [<span class="hljs-string">&quot;application/vnd.oci.image.layer.v1.tar+encrypted&quot;</span>]<br>    <span class="hljs-attr">args</span> = [<span class="hljs-string">&quot;--decryption-keys-path&quot;</span>, <span class="hljs-string">&quot;/etc/containerd/ocicrypt/keys&quot;</span>]<br>    <span class="hljs-attr">env</span> = [<span class="hljs-string">&quot;OCICRYPT_KEYPROVIDER_CONFIG=/etc/containerd/ocicrypt/ocicrypt_keyprovider.conf&quot;</span>]<br>    <span class="hljs-attr">path</span> = <span class="hljs-string">&quot;ctd-decoder&quot;</span><br>    <span class="hljs-attr">returns</span> = <span class="hljs-string">&quot;application/vnd.oci.image.layer.v1.tar&quot;</span><br><br>  <span class="hljs-section">[stream_processors.&quot;io.containerd.ocicrypt.decoder.v1.tar.gzip&quot;]</span><br>    <span class="hljs-attr">accepts</span> = [<span class="hljs-string">&quot;application/vnd.oci.image.layer.v1.tar+gzip+encrypted&quot;</span>]<br>    <span class="hljs-attr">args</span> = [<span class="hljs-string">&quot;--decryption-keys-path&quot;</span>, <span class="hljs-string">&quot;/etc/containerd/ocicrypt/keys&quot;</span>]<br>    <span class="hljs-attr">env</span> = [<span class="hljs-string">&quot;OCICRYPT_KEYPROVIDER_CONFIG=/etc/containerd/ocicrypt/ocicrypt_keyprovider.conf&quot;</span>]<br>    <span class="hljs-attr">path</span> = <span class="hljs-string">&quot;ctd-decoder&quot;</span><br>    <span class="hljs-attr">returns</span> = <span class="hljs-string">&quot;application/vnd.oci.image.layer.v1.tar+gzip&quot;</span><br><br><span class="hljs-section">[timeouts]</span><br>  <span class="hljs-attr">&quot;io.containerd.timeout.shim.cleanup&quot;</span> = <span class="hljs-string">&quot;5s&quot;</span><br>  <span class="hljs-attr">&quot;io.containerd.timeout.shim.load&quot;</span> = <span class="hljs-string">&quot;5s&quot;</span><br>  <span class="hljs-attr">&quot;io.containerd.timeout.shim.shutdown&quot;</span> = <span class="hljs-string">&quot;3s&quot;</span><br>  <span class="hljs-attr">&quot;io.containerd.timeout.task.state&quot;</span> = <span class="hljs-string">&quot;2s&quot;</span><br><br><span class="hljs-section">[ttrpc]</span><br>  <span class="hljs-attr">address</span> = <span class="hljs-string">&quot;&quot;</span><br>  <span class="hljs-attr">gid</span> = <span class="hljs-number">0</span><br>  <span class="hljs-attr">uid</span> = <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>这个配置文件比较复杂，我们可以将重点放在其中的 <code>plugins</code> 配置上面，仔细观察我们可以发现每一个顶级配置块的命名都是 <code>plugins.&quot;io.containerd.xxx.vx.xxx&quot;</code> 这种形式，每一个顶级配置块都表示一个插件，其中 <code>io.containerd.xxx.vx</code> 表示插件的类型，<code>vx</code> 后面的 <code>xxx</code> 表示插件的 ID，我们可以通过 <code>ctr</code> 查看插件列表：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs shell">➜  ~ ctr plugin ls<br>ctr plugin ls<br>TYPE                            ID                       PLATFORMS      STATUS<br>io.containerd.content.v1        content                  -              ok<br>io.containerd.snapshotter.v1    aufs                     linux/amd64    ok<br>io.containerd.snapshotter.v1    btrfs                    linux/amd64    skip<br>io.containerd.snapshotter.v1    devmapper                linux/amd64    error<br>io.containerd.snapshotter.v1    native                   linux/amd64    ok<br>io.containerd.snapshotter.v1    overlayfs                linux/amd64    ok<br>io.containerd.snapshotter.v1    zfs                      linux/amd64    skip<br>io.containerd.metadata.v1       bolt                     -              ok<br>io.containerd.differ.v1         walking                  linux/amd64    ok<br>io.containerd.gc.v1             scheduler                -              ok<br>io.containerd.service.v1        introspection-service    -              ok<br>io.containerd.service.v1        containers-service       -              ok<br>io.containerd.service.v1        content-service          -              ok<br>io.containerd.service.v1        diff-service             -              ok<br>io.containerd.service.v1        images-service           -              ok<br>io.containerd.service.v1        leases-service           -              ok<br>io.containerd.service.v1        namespaces-service       -              ok<br>io.containerd.service.v1        snapshots-service        -              ok<br>io.containerd.runtime.v1        linux                    linux/amd64    ok<br>io.containerd.runtime.v2        task                     linux/amd64    ok<br>io.containerd.monitor.v1        cgroups                  linux/amd64    ok<br>io.containerd.service.v1        tasks-service            -              ok<br>io.containerd.internal.v1       restart                  -              ok<br>io.containerd.grpc.v1           containers               -              ok<br>io.containerd.grpc.v1           content                  -              ok<br>io.containerd.grpc.v1           diff                     -              ok<br>io.containerd.grpc.v1           events                   -              ok<br>io.containerd.grpc.v1           healthcheck              -              ok<br>io.containerd.grpc.v1           images                   -              ok<br>io.containerd.grpc.v1           leases                   -              ok<br>io.containerd.grpc.v1           namespaces               -              ok<br>io.containerd.internal.v1       opt                      -              ok<br>io.containerd.grpc.v1           snapshots                -              ok<br>io.containerd.grpc.v1           tasks                    -              ok<br>io.containerd.grpc.v1           version                  -              ok<br>io.containerd.grpc.v1           cri                      linux/amd64    ok<br></code></pre></td></tr></table></figure><p>顶级配置块下面的子配置块表示该插件的各种配置，比如 cri 插件下面就分为 containerd、cni 和 registry 的配置，而 containerd 下面又可以配置各种 runtime，还可以配置默认的 runtime。比如现在我们要为镜像配置一个加速器，那么就需要在 cri 配置块下面的 <code>registry</code> 配置块下面进行配置 <code>registry.mirrors</code>：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs toml"><span class="hljs-section">[plugins.&quot;io.containerd.grpc.v1.cri&quot;.registry]</span><br>  <span class="hljs-section">[plugins.&quot;io.containerd.grpc.v1.cri&quot;.registry.mirrors]</span><br>    <span class="hljs-section">[plugins.&quot;io.containerd.grpc.v1.cri&quot;.registry.mirrors.&quot;docker.io&quot;]</span><br>      <span class="hljs-attr">endpoint</span> = [<span class="hljs-string">&quot;https://bqr1dr1n.mirror.aliyuncs.com&quot;</span>]<br>    <span class="hljs-section">[plugins.&quot;io.containerd.grpc.v1.cri&quot;.registry.mirrors.&quot;k8s.gcr.io&quot;]</span><br>      <span class="hljs-attr">endpoint</span> = [<span class="hljs-string">&quot;https://registry.aliyuncs.com/k8sxio&quot;</span>]<br></code></pre></td></tr></table></figure><ul><li><code>registry.mirrors.&quot;xxx&quot;</code>: 表示需要配置 mirror 的镜像仓库，例如 <code>registry.mirrors.&quot;docker.io&quot;</code> 表示配置 docker.io 的 mirror。</li><li><code>endpoint</code>: 表示提供 mirror 的镜像加速服务，比如我们可以注册一个阿里云的镜像服务来作为 docker.io 的 mirror。</li></ul><p>另外在默认配置中还有两个关于存储的配置路径：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs toml"><span class="hljs-attr">root</span> = <span class="hljs-string">&quot;/var/lib/containerd&quot;</span><br><span class="hljs-attr">state</span> = <span class="hljs-string">&quot;/run/containerd&quot;</span><br></code></pre></td></tr></table></figure><p>其中 <code>root</code> 是用来保存持久化数据，包括 Snapshots, Content, Metadata 以及各种插件的数据，每一个插件都有自己单独的目录，Containerd 本身不存储任何数据，它的所有功能都来自于已加载的插件。</p><p>而另外的 <code>state</code> 是用来保存运行时的临时数据的，包括 sockets、pid、挂载点、运行时状态以及不需要持久化的插件数据。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>我们知道 Docker CLI 工具提供了需要增强用户体验的功能，containerd 同样也提供一个对应的 CLI 工具：<code>ctr</code>，不过 ctr 的功能没有 docker 完善，但是关于镜像和容器的基本功能都是有的。接下来我们就先简单介绍下 <code>ctr</code> 的使用。</p><p><strong>帮助</strong></p><p>直接输入 <code>ctr</code> 命令即可获得所有相关的操作命令使用方式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs shell">➜  ~ ctr<br>NAME:<br>   ctr -<br>        __<br>  _____/ /______<br> / ___/ __/ ___/<br>/ /__/ /_/ /<br>\___/\__/_/<br><br>containerd CLI<br><br><br>USAGE:<br>   ctr [global options] command [command options] [arguments...]<br><br>VERSION:<br>   v1.5.5<br><br>DESCRIPTION:<br><br>ctr is an unsupported debug and administrative client for interacting<br>with the containerd daemon. Because it is unsupported, the commands,<br>options, and operations are not guaranteed to be backward compatible or<br>stable from release to release of the containerd project.<br><br>COMMANDS:<br>   plugins, plugin            provides information about containerd plugins<br>   version                    print the client and server versions<br>   containers, c, container   manage containers<br>   content                    manage content<br>   events, event              display containerd events<br>   images, image, i           manage images<br>   leases                     manage leases<br>   namespaces, namespace, ns  manage namespaces<br>   pprof                      provide golang pprof outputs for containerd<br>   run                        run a container<br>   snapshots, snapshot        manage snapshots<br>   tasks, t, task             manage tasks<br>   install                    install a new package<br>   oci                        OCI tools<br>   shim                       interact with a shim directly<br>   help, h                    Shows a list of commands or help for one command<br><br>GLOBAL OPTIONS:<br>   --debug                      enable debug output in logs<br>   --address value, -a value    address for containerd&#x27;s GRPC server (default: &quot;/run/containerd/containerd.sock&quot;) [$CONTAINERD_ADDRESS]<br>   --timeout value              total timeout for ctr commands (default: 0s)<br>   --connect-timeout value      timeout for connecting to containerd (default: 0s)<br>   --namespace value, -n value  namespace to use with commands (default: &quot;default&quot;) [$CONTAINERD_NAMESPACE]<br>   --help, -h                   show help<br>   --version, -v                print the version<br></code></pre></td></tr></table></figure><h4 id="镜像操作"><a href="#镜像操作" class="headerlink" title="镜像操作"></a>镜像操作</h4><p><strong>拉取镜像</strong></p><p>拉取镜像可以使用 <code>ctr image pull</code> 来完成，比如拉取 Docker Hub 官方镜像 <code>nginx:alpine</code>，需要注意的是镜像地址需要加上 <code>docker.io</code> Host 地址：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell">➜  ~ ctr image pull docker.io/library/nginx:alpine<br>docker.io/library/nginx:alpine:                                                   resolved       |++++++++++++++++++++++++++++++++++++++|<br>index-sha256:bead42240255ae1485653a956ef41c9e458eb077fcb6dc664cbc3aa9701a05ce:    exists         |++++++++++++++++++++++++++++++++++++++|<br>manifest-sha256:ce6ca11a3fa7e0e6b44813901e3289212fc2f327ee8b1366176666e8fb470f24: done           |++++++++++++++++++++++++++++++++++++++|<br>layer-sha256:9a6ac07b84eb50935293bb185d0a8696d03247f74fd7d43ea6161dc0f293f81f:    done           |++++++++++++++++++++++++++++++++++++++|<br>layer-sha256:e82f830de071ebcda58148003698f32205b7970b01c58a197ac60d6bb79241b0:    done           |++++++++++++++++++++++++++++++++++++++|<br>layer-sha256:d7c9fa7589ae28cd3306b204d5dd9a539612593e35df70f7a1d69ff7548e74cf:    done           |++++++++++++++++++++++++++++++++++++++|<br>layer-sha256:bf2b3ee132db5b4c65432e53aca69da4e609c6cb154e0d0e14b2b02259e9c1e3:    done           |++++++++++++++++++++++++++++++++++++++|<br>config-sha256:7ce0143dee376bfd2937b499a46fb110bda3c629c195b84b1cf6e19be1a9e23b:   done           |++++++++++++++++++++++++++++++++++++++|<br>layer-sha256:3c1eaf69ff492177c34bdbf1735b6f2e5400e417f8f11b98b0da878f4ecad5fb:    done           |++++++++++++++++++++++++++++++++++++++|<br>layer-sha256:29291e31a76a7e560b9b7ad3cada56e8c18d50a96cca8a2573e4f4689d7aca77:    done           |++++++++++++++++++++++++++++++++++++++|<br>elapsed: 11.9s                                                                    total:  8.7 Mi (748.1 KiB/s)<br>unpacking linux/amd64 sha256:bead42240255ae1485653a956ef41c9e458eb077fcb6dc664cbc3aa9701a05ce...<br>done: 410.86624ms<br></code></pre></td></tr></table></figure><p>也可以使用 <code>--platform</code> 选项指定对应平台的镜像。当然对应的也有推送镜像的命令 <code>ctr image push</code>，如果是私有镜像则在推送的时候可以通过 <code>--user</code> 来自定义仓库的用户名和密码。</p><p><strong>列出本地镜像</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">➜  ~ ctr image ls<br>REF                            TYPE                                                      DIGEST                                                                  SIZE    PLATFORMS                                                                                LABELS<br>docker.io/library/nginx:alpine application/vnd.docker.distribution.manifest.list.v2+json sha256:bead42240255ae1485653a956ef41c9e458eb077fcb6dc664cbc3aa9701a05ce 9.5 MiB linux/386,linux/amd64,linux/arm/v6,linux/arm/v7,linux/arm64/v8,linux/ppc64le,linux/s390x -<br>➜  ~ ctr image ls -q<br>docker.io/library/nginx:alpine<br></code></pre></td></tr></table></figure><p>使用 <code>-q（--quiet）</code> 选项可以只打印镜像名称。</p><p><strong>检测本地镜像</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">➜  ~ ctr image check<br>REF                            TYPE                                                      DIGEST                                                                  STATUS         SIZE            UNPACKED<br>docker.io/library/nginx:alpine application/vnd.docker.distribution.manifest.list.v2+json sha256:bead42240255ae1485653a956ef41c9e458eb077fcb6dc664cbc3aa9701a05ce complete (7/7) 9.5 MiB/9.5 MiB true<br></code></pre></td></tr></table></figure><p>主要查看其中的 <code>STATUS</code>，<code>complete</code> 表示镜像是完整可用的状态。</p><p><strong>重新打标签</strong></p><p>同样的我们也可以重新给指定的镜像打一个 Tag：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">➜  ~ ctr image tag docker.io/library/nginx:alpine harbor.k8s.local/course/nginx:alpine<br>harbor.k8s.local/course/nginx:alpine<br>➜  ~ ctr image ls -q<br>docker.io/library/nginx:alpine<br>harbor.k8s.local/course/nginx:alpine<br></code></pre></td></tr></table></figure><p><strong>删除镜像</strong></p><p>不需要使用的镜像也可以使用 <code>ctr image rm</code> 进行删除：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">➜  ~ ctr image rm harbor.k8s.local/course/nginx:alpine<br>harbor.k8s.local/course/nginx:alpine<br>➜  ~ ctr image ls -q<br>docker.io/library/nginx:alpine<br></code></pre></td></tr></table></figure><p>加上 <code>--sync</code> 选项可以同步删除镜像和所有相关的资源。</p><p><strong>将镜像挂载到主机目录</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs shell">➜  ~ ctr image mount docker.io/library/nginx:alpine /mnt<br>sha256:c3554b2d61e3c1cffcaba4b4fa7651c644a3354efaafa2f22cb53542f6c600dc<br>/mnt<br>➜  ~ tree -L 1 /mnt<br>/mnt<br>├── bin<br>├── dev<br>├── docker-entrypoint.d<br>├── docker-entrypoint.sh<br>├── etc<br>├── home<br>├── lib<br>├── media<br>├── mnt<br>├── opt<br>├── proc<br>├── root<br>├── run<br>├── sbin<br>├── srv<br>├── sys<br>├── tmp<br>├── usr<br>└── var<br><br>18 directories, 1 file<br></code></pre></td></tr></table></figure><p><strong>将镜像从主机目录上卸载</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">➜  ~ ctr image unmount /mnt<br>/mnt<br></code></pre></td></tr></table></figure><p><strong>将镜像导出为压缩包</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">➜  ~ ctr image export nginx.tar.gz docker.io/library/nginx:alpine<br></code></pre></td></tr></table></figure><p><strong>从压缩包导入镜像</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">➜  ~ ctr image import nginx.tar.gz<br></code></pre></td></tr></table></figure><h4 id="容器操作"><a href="#容器操作" class="headerlink" title="容器操作"></a>容器操作</h4><p>容器相关操作可以通过 <code>ctr container</code> 获取。</p><p><strong>创建容器</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">➜  ~ ctr container create docker.io/library/nginx:alpine nginx<br></code></pre></td></tr></table></figure><p><strong>列出容器</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">➜  ~ ctr container ls<br>CONTAINER    IMAGE                             RUNTIME<br>nginx        docker.io/library/nginx:alpine    io.containerd.runc.v2<br></code></pre></td></tr></table></figure><p>同样可以加上 <code>-q</code> 选项精简列表内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">➜  ~ ctr container ls -q<br>nginx<br></code></pre></td></tr></table></figure><p><strong>查看容器详细配置</strong></p><p>类似于 <code>docker inspect</code> 功能。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs shell">➜  ~ ctr container info nginx<br>&#123;<br>    &quot;ID&quot;: &quot;nginx&quot;,<br>    &quot;Labels&quot;: &#123;<br>        &quot;io.containerd.image.config.stop-signal&quot;: &quot;SIGQUIT&quot;<br>    &#125;,<br>    &quot;Image&quot;: &quot;docker.io/library/nginx:alpine&quot;,<br>    &quot;Runtime&quot;: &#123;<br>        &quot;Name&quot;: &quot;io.containerd.runc.v2&quot;,<br>        &quot;Options&quot;: &#123;<br>            &quot;type_url&quot;: &quot;containerd.runc.v1.Options&quot;<br>        &#125;<br>    &#125;,<br>    &quot;SnapshotKey&quot;: &quot;nginx&quot;,<br>    &quot;Snapshotter&quot;: &quot;overlayfs&quot;,<br>    &quot;CreatedAt&quot;: &quot;2021-08-12T08:23:13.792871558Z&quot;,<br>    &quot;UpdatedAt&quot;: &quot;2021-08-12T08:23:13.792871558Z&quot;,<br>    &quot;Extensions&quot;: null,<br>    &quot;Spec&quot;: &#123;<br>......<br></code></pre></td></tr></table></figure><p><strong>删除容器</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">➜  ~ ctr container rm nginx<br>➜  ~ ctr container ls<br>CONTAINER    IMAGE    RUNTIME<br></code></pre></td></tr></table></figure><p>除了使用 <code>rm</code> 子命令之外也可以使用 <code>delete</code> 或者 <code>del</code> 删除容器。</p><h4 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h4><p>上面我们通过 <code>container create</code> 命令创建的容器，并没有处于运行状态，只是一个静态的容器。一个 container 对象只是包含了运行一个容器所需的资源及相关配置数据，表示 namespaces、rootfs 和容器的配置都已经初始化成功了，只是用户进程还没有启动。</p><p>一个容器真正运行起来是由 Task 任务实现的，Task 可以为容器设置网卡，还可以配置工具来对容器进行监控等。</p><p>Task 相关操作可以通过 <code>ctr task</code> 获取，如下我们通过 Task 来启动容器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">➜  ~ ctr task start -d nginx<br>/docker-entrypoint.sh: /docker-entrypoint.d/ is not empty, will attempt to perform configuration<br>/docker-entrypoint.sh: Looking for shell scripts in /docker-entrypoint.d/<br></code></pre></td></tr></table></figure><p>启动容器后可以通过 <code>task ls</code> 查看正在运行的容器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">➜  ~ ctr task ls<br>TASK     PID     STATUS<br>nginx    3630    RUNNING<br></code></pre></td></tr></table></figure><p>同样也可以使用 <code>exec</code> 命令进入容器进行操作：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">➜  ~ ctr task exec --exec-id 0 -t nginx sh<br>/ #<br></code></pre></td></tr></table></figure><p>不过这里需要注意必须要指定 <code>--exec-id</code> 参数，这个 id 可以随便写，只要唯一就行。</p><p>暂停容器，和 <code>docker pause</code> 类似的功能：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">➜  ~ ctr task pause nginx<br></code></pre></td></tr></table></figure><p>暂停后容器状态变成了 <code>PAUSED</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">➜  ~ ctr task ls<br>TASK     PID     STATUS<br>nginx    3630    PAUSED<br></code></pre></td></tr></table></figure><p>同样也可以使用 <code>resume</code> 命令来恢复容器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">➜  ~ ctr task resume nginx<br>➜  ~ ctr task ls<br>TASK     PID     STATUS<br>nginx    3630    RUNNING<br></code></pre></td></tr></table></figure><p>不过需要注意 ctr 没有 stop 容器的功能，只能暂停或者杀死容器。杀死容器可以使用 <code>task kill</code> 命令:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">➜  ~ ctr task kill nginx<br>➜  ~ ctr task ls<br>TASK     PID     STATUS<br>nginx    3630    STOPPED<br></code></pre></td></tr></table></figure><p>杀掉容器后可以看到容器的状态变成了 <code>STOPPED</code>。同样也可以通过 <code>task rm</code> 命令删除 Task：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">➜  ~ ctr task rm nginx<br>➜  ~ ctr task ls<br>TASK    PID    STATUS<br></code></pre></td></tr></table></figure><p>除此之外我们还可以获取容器的 cgroup 相关信息，可以使用 <code>task metrics</code> 命令用来获取容器的内存、CPU 和 PID 的限额与使用量。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">重新启动容器</span><br>➜  ~ ctr task metrics nginx<br>ID       TIMESTAMP<br>nginx    2021-08-12 08:50:46.952769941 +0000 UTC<br><br>METRIC                   VALUE<br>memory.usage_in_bytes    8855552<br>memory.limit_in_bytes    9223372036854771712<br>memory.stat.cache        0<br>cpuacct.usage            22467106<br>cpuacct.usage_percpu     [2962708 860891 1163413 1915748 1058868 2888139 6159277 5458062]<br>pids.current             9<br>pids.limit               0<br></code></pre></td></tr></table></figure><p>还可以使用 <code>task ps</code> 命令查看容器中所有进程在宿主机中的 PID：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell">➜  ~ ctr task ps nginx<br>PID     INFO<br>3984    -<br>4029    -<br>4030    -<br>4031    -<br>4032    -<br>4033    -<br>4034    -<br>4035    -<br>4036    -<br>➜  ~ ctr task ls<br>TASK     PID     STATUS<br>nginx    3984    RUNNING<br></code></pre></td></tr></table></figure><p>其中第一个 PID <code>3984</code> 就是我们容器中的 1 号进程。</p><h4 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h4><p>另外 Containerd 中也支持命名空间的概念，比如查看命名空间：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">➜  ~ ctr ns ls<br>NAME    LABELS<br>default<br></code></pre></td></tr></table></figure><p>如果不指定，ctr 默认使用的是 <code>default</code> 空间。同样也可以使用 <code>ns create</code> 命令创建一个命名空间：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">➜  ~ ctr ns create test<br>➜  ~ ctr ns ls<br>NAME    LABELS<br>default<br>test<br></code></pre></td></tr></table></figure><p>使用 <code>remove</code> 或者 <code>rm</code> 可以删除 namespace：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">➜  ~ ctr ns rm test<br>test<br>➜  ~ ctr ns ls<br>NAME    LABELS<br>default<br></code></pre></td></tr></table></figure><p>有了命名空间后就可以在操作资源的时候指定 namespace，比如查看 test 命名空间的镜像，可以在操作命令后面加上 <code>-n test</code> 选项：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">➜  ~ ctr -n test image ls<br>REF TYPE DIGEST SIZE PLATFORMS LABELS<br></code></pre></td></tr></table></figure><p>我们知道 Docker 其实也是默认调用的 containerd，事实上 Docker 使用的 containerd 下面的命名空间默认是 <code>moby</code>，而不是 <code>default</code>，所以假如我们有用 docker 启动容器，那么我们也可以通过 <code>ctr -n moby</code> 来定位下面的容器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">➜  ~ ctr -n moby container ls<br></code></pre></td></tr></table></figure><p>同样 Kubernetes 下使用的 containerd 默认命名空间是 <code>k8s.io</code>，所以我们可以使用 <code>ctr -n k8s.io</code> 来查看 Kubernetes 下面创建的容器。后续我们再介绍如何将 Kubernetes 集群的容器运行时切换到 <code>containerd</code>。</p><p><strong>Docker ctr nerdctl命令直接的区别</strong></p><p><code>crictl</code>是kubernetes cri-tools的一部分，是专门为kubernetes使用containerd而专门制作的，提供了Pod、容器和镜像等资源的管理命令。</p><blockquote><p>需要注意的是：使用其他非 kubernetes创建的容器、镜像，crictl是无法看到和调试的，比如说ctr run在未指定namespace情况下运行起来的容器就无法使用crictl看到。当然ctr可以使用-n k8s.io指定操作的namespace为 k8s.io，从而可以看到&#x2F;操作kubernetes 集群中容器、镜像等资源。可以理解为：crictl 操作的时候指定了containerd 的namespace为k8s.io。</p></blockquote><p><code>nerdctl</code> <strong>ctr</strong>功能简单，而且对已经习惯使用<code>docker cli</code>的人来说，ctr并不友好（比如无法像 docker cli 那样）。这个时候<code>nerdctl</code>就可以替代ctr了。nerdctl是一个与docker cli风格兼容的containerd的cli工具，并且已经被作为子项目加入了 containerd 项目中。从<code>nerdctl 0.8</code>开始，nerdctl直接兼容了<code>docker compose</code>的语法(不包含 swarm)， 这很大程度上提高了直接将 containerd 作为本地开发、测试和单机容器部署使用的体验。</p><p>需要注意的是：安装 nerdctl 之后，要想可以使用 nerdctl 还需要安装 CNI 相关工具和插件。containerd不包含网络功能的实现，想要实现端口映射这样的容器网络能力，需要额外安装 CNI 相关工具和插件。</p><blockquote><p>另外 nerdctl 也可以使用 -n 指定使用的 namespace。</p></blockquote><table><thead><tr><th align="left"></th><th align="left">docker</th><th align="left">crictl</th><th align="left">ctr</th><th align="left">nerdctl</th></tr></thead><tbody><tr><td align="left">查看容器列表</td><td align="left">docker ps</td><td align="left">crictl ps</td><td align="left">ctr c ls（查看非 kubernetes 中的容器）ctr -n k8s.io c ls（查看 kubernetes 集群中的容器）</td><td align="left">nerdctl ps（查看非 kubernetes 中的容器）nerdctl -n k8s.io ps（查看 kubernetes 集群中的容器）</td></tr><tr><td align="left">查看容器详情</td><td align="left">docker inspect</td><td align="left">crictl inspect</td><td align="left">ctr c info</td><td align="left">nerdctl inspect</td></tr><tr><td align="left">查看容器日志</td><td align="left">docker logs</td><td align="left">crictl logs</td><td align="left">无</td><td align="left">nerdctl logs</td></tr><tr><td align="left">容器内执行命令</td><td align="left">docker exec</td><td align="left">crictl exec</td><td align="left">ctr t exec</td><td align="left">nerdctl exec</td></tr><tr><td align="left">挂载容器</td><td align="left">docker attach</td><td align="left">crictl attach</td><td align="left">ctr t attach</td><td align="left">无</td></tr><tr><td align="left">显示容器资源使用情况</td><td align="left">docker stats</td><td align="left">crictl stats</td><td align="left">ctr task metrics</td><td align="left">无</td></tr><tr><td align="left">创建容器</td><td align="left">docker create</td><td align="left">crictl create</td><td align="left">ctr c create</td><td align="left">无</td></tr><tr><td align="left">启动容器</td><td align="left">docker start</td><td align="left">crictl start</td><td align="left">ctr t start</td><td align="left">nerdctl start</td></tr><tr><td align="left">运行容器</td><td align="left">docker run</td><td align="left">crictl run</td><td align="left">ctr run</td><td align="left">nerdctl run</td></tr><tr><td align="left">停止容器</td><td align="left">docker stop</td><td align="left">crictl stop</td><td align="left">ctr t kill</td><td align="left">nerdctl stop</td></tr><tr><td align="left">删除容器</td><td align="left">docker rm</td><td align="left">crictl rm</td><td align="left">ctr c rm</td><td align="left">nerdctl rm</td></tr><tr><td align="left">查看镜像列表</td><td align="left">docker images</td><td align="left">crictl images</td><td align="left">ctr i ls</td><td align="left">nerdctl images</td></tr><tr><td align="left">查看镜像详情</td><td align="left">docker inspect</td><td align="left">crictl inspecti</td><td align="left">无</td><td align="left">nerdctl inspect</td></tr><tr><td align="left">拉取镜像</td><td align="left">docker pull</td><td align="left">crictl pull</td><td align="left">ctr i pull</td><td align="left">nerdctl pull</td></tr><tr><td align="left">推送镜像</td><td align="left">docker push</td><td align="left">无</td><td align="left">ctr i push</td><td align="left">nerdctl push</td></tr><tr><td align="left">删除镜像</td><td align="left">docker rmi</td><td align="left">crictl rmi</td><td align="left">ctr i rm</td><td align="left">nerdctl rmi</td></tr><tr><td align="left">查看Pod列表</td><td align="left">无</td><td align="left">crictl pods</td><td align="left">无</td><td align="left">无</td></tr><tr><td align="left">查看Pod详情</td><td align="left">无</td><td align="left">crictl inspectp</td><td align="left">无</td><td align="left">无</td></tr><tr><td align="left">启动Pod</td><td align="left">无</td><td align="left">crictl runp</td><td align="left">无</td><td align="left">无</td></tr><tr><td align="left">停止Pod</td><td align="left">无</td><td align="left">crictl stopp</td><td align="left">无</td><td align="left">无</td></tr></tbody></table><p>转载自：<a href="https://www.qikqiak.com/post/containerd-usage/">https://www.qikqiak.com/post/containerd-usage/</a></p>]]></content>
    
    
    <categories>
      
      <category>container</category>
      
    </categories>
    
    
    <tags>
      
      <tag>container</tag>
      
      <tag>containerd</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CRI详解</title>
    <link href="/2023/11/30/CRI%E8%AF%A6%E8%A7%A3/"/>
    <url>/2023/11/30/CRI%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p><code>CRI</code>（Container Runtime Interface 容器运行时接口）本质上就是 Kubernetes 定义的一组与容器运行时进行交互的接口，所以只要实现了这套接口的容器运行时都可以对接到 Kubernetes 平台上来。不过 Kubernetes 推出 CRI 这套标准的时候还没有现在的统治地位，所以有一些容器运行时可能不会自身就去实现 CRI 接口，于是就有了 <code>shim（垫片）</code>， 一个 shim 的职责就是作为适配器将各种容器运行时本身的接口适配到 Kubernetes 的 CRI 接口上，其中 <code>dockershim</code> 就是 Kubernetes 对接 Docker 到 CRI 接口上的一个垫片实现。</p><p><img src="https://picdn.youdianzhishi.com/images/20210809172030.png" alt="cri shim"></p><p>Kubelet 通过 gRPC 框架与容器运行时或 shim 进行通信，其中 kubelet 作为客户端，CRI shim（也可能是容器运行时本身）作为服务器。</p><p>CRI定义的 API(<a href="https://github.com/kubernetes/kubernetes/blob/release-1.5/pkg/kubelet/api/v1alpha1/runtime/api.proto">RuntimeService</a>) 主要包括两个 gRPC 服务，<code>ImageService</code> 和 <code>RuntimeService</code>，<code>ImageService</code> 服务主要是拉取镜像、查看和删除镜像等操作，<code>RuntimeService</code> 则是用来管理 Pod 和容器的生命周期，以及与容器交互的调用（exec&#x2F;attach&#x2F;port-forward）等操作，可以通过 kubelet 中的标志 <code>--container-runtime-endpoint</code> 和 <code>--image-service-endpoint</code> 来配置这两个服务的套接字。</p><p><img src="https://picdn.youdianzhishi.com/images/20210809173134.png" alt="kubelet cri"></p><p>不过这里同样也有一个例外，那就是 Docker，由于 Docker 当时的江湖地位很高，Kubernetes 是直接内置了 <code>dockershim</code> 在 kubelet 中的，所以如果你使用的是 Docker 这种容器运行时的话是不需要单独去安装配置适配器之类的，当然这个举动似乎也麻痹了 Docker 公司。</p><p><img src="https://picdn.youdianzhishi.com/images/20210809173555.png" alt="dockershim"></p><p>现在如果我们使用的是 Docker 的话，当我们在 Kubernetes 中创建一个 Pod 的时候，首先就是 kubelet 通过 CRI 接口调用 <code>dockershim</code>，请求创建一个容器，kubelet 可以视作一个简单的 CRI Client, 而 dockershim 就是接收请求的 Server，不过他们都是在 kubelet 内置的。</p><p><code>dockershim</code> 收到请求后, 转化成 Docker Daemon 能识别的请求, 发到 Docker Daemon 上请求创建一个容器，请求到了 Docker Daemon 后续就是 Docker 创建容器的流程了，去调用 <code>containerd</code>，然后创建 <code>containerd-shim</code> 进程，通过该进程去调用 <code>runc</code> 去真正创建容器。</p><p>其实我们仔细观察也不难发现使用 Docker 的话其实是调用链比较长的，真正容器相关的操作其实 containerd 就完全足够了，Docker 太过于复杂笨重了，当然 Docker 深受欢迎的很大一个原因就是提供了很多对用户操作比较友好的功能，但是对于 Kubernetes 来说压根不需要这些功能，因为都是通过接口去操作容器的，所以自然也就可以将容器运行时切换到 containerd 来。</p><p><img src="https://picdn.youdianzhishi.com/images/20210810094948.png" alt="切换到containerd"></p><p>切换到 containerd 可以消除掉中间环节，操作体验也和以前一样，但是由于直接用容器运行时调度容器，所以它们对 Docker 来说是不可见的。 因此，你以前用来检查这些容器的 Docker 工具就不能使用了。</p><p>你不能再使用 <code>docker ps</code> 或 <code>docker inspect</code> 命令来获取容器信息。由于不能列出容器，因此也不能获取日志、停止容器，甚至不能通过 <code>docker exec</code> 在容器中执行命令。</p><p>当然我们仍然可以下载镜像，或者用 <code>docker build</code> 命令构建镜像，但用 Docker 构建、下载的镜像，对于容器运行时和 Kubernetes，均不可见。为了在 Kubernetes 中使用，需要把镜像推送到镜像仓库中去。</p><p>从上图可以看出在 containerd 1.0 中，对 CRI 的适配是通过一个单独的 <code>CRI-Containerd</code> 进程来完成的，这是因为最开始 containerd 还会去适配其他的系统（比如 swarm），所以没有直接实现 CRI，所以这个对接工作就交给 <code>CRI-Containerd</code> 这个 shim 了。</p><p>然后到了 containerd 1.1 版本后就去掉了 <code>CRI-Containerd</code> 这个 shim，直接把适配逻辑作为插件的方式集成到了 containerd 主进程中，现在这样的调用就更加简洁了。</p><p><img src="https://picdn.youdianzhishi.com/images/20210810095546.png" alt="containerd cri"></p><p>与此同时 Kubernetes 社区也做了一个专门用于 Kubernetes 的 CRI 运行时 <a href="https://cri-o.io/">CRI-O</a>，直接兼容 CRI 和 OCI 规范。</p><p><img src="https://picdn.youdianzhishi.com/images/20210810100752.png" alt="cri-o"></p><p>这个方案和 containerd 的方案显然比默认的 dockershim 简洁很多，不过由于大部分用户都比较习惯使用 Docker，所以大家还是更喜欢使用 <code>dockershim</code> 方案。</p><p>但是随着 CRI 方案的发展，以及其他容器运行时对 CRI 的支持越来越完善，Kubernetes 社区在 2020 年 7 月份就开始着手移除 dockershim 方案了：<a href="https://github.com/kubernetes/enhancements/tree/master/keps/sig-node/2221-remove-dockershim%EF%BC%8C%E7%8E%B0%E5%9C%A8%E7%9A%84%E7%A7%BB%E9%99%A4%E8%AE%A1%E5%88%92%E6%98%AF%E5%9C%A8">https://github.com/kubernetes/enhancements/tree/master/keps/sig-node/2221-remove-dockershim，现在的移除计划是在</a> 1.20 版本中将 kubelet 中内置的 dockershim 代码分离，将内置的 dockershim 标记为<code>维护模式</code>，当然这个时候仍然还可以使用 dockershim，目标是在 1.23&#x2F;1.24 版本发布没有 dockershim 的版本（代码还在，但是要默认支持开箱即用的 docker 需要自己构建 kubelet，会在某个宽限期过后从 kubelet 中删除内置的 dockershim 代码）。</p><p>那么这是否就意味这 Kubernetes 不再支持 Docker 了呢？当然不是的，这只是废弃了内置的 <code>dockershim</code> 功能而已，Docker 和其他容器运行时将一视同仁，不会单独对待内置支持，如果我们还想直接使用 Docker 这种容器运行时应该怎么办呢？可以将 dockershim 的功能单独提取出来独立维护一个 <code>cri-dockerd</code> 即可，就类似于 containerd 1.0 版本中提供的 <code>CRI-Containerd</code>，当然还有一种办法就是 Docker 官方社区将 CRI 接口内置到 Dockerd 中去实现。</p><p>但是我们也清楚 Dockerd 也是去直接调用的 Containerd，而 containerd 1.1 版本后就内置实现了 CRI，所以 Docker 也没必要再去单独实现 CRI 了，当 Kubernetes 不再内置支持开箱即用的 Docker 的以后，最好的方式当然也就是直接使用 Containerd 这种容器运行时，而且该容器运行时也已经经过了生产环境实践的，接下来我们就来学习下 Containerd 的使用。</p><p>转载自：<a href="https://www.qikqiak.com/post/containerd-usage/">https://www.qikqiak.com/post/containerd-usage/</a></p>]]></content>
    
    
    <categories>
      
      <category>container</category>
      
    </categories>
    
    
    <tags>
      
      <tag>container</tag>
      
      <tag>kubernetes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker简介</title>
    <link href="/2023/11/30/docker%E6%9E%B6%E6%9E%84/"/>
    <url>/2023/11/30/docker%E6%9E%B6%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h2 id="Docker-Architecutre"><a href="#Docker-Architecutre" class="headerlink" title="Docker Architecutre"></a>Docker Architecutre</h2><p>Docker uses a client-server architecture. The Docker client talks to the Docker daemon, which does the heavy lifting of building, running, and distributing your Docker containers. The Docker client and daemon can run on the same system, or you can connect a Docker client to a remote Docker daemon. The Docker client and daemon communicate using a REST API, over UNIX sockets or a network interface. </p><p><img src="https://docs.docker.com/get-started/images/docker-architecture.webp" alt="Docker Architecture diagram"></p><h3 id="The-Docker-daemon"><a href="#The-Docker-daemon" class="headerlink" title="The Docker daemon"></a><a href="https://docs.docker.com/get-started/overview/#the-docker-daemon">The Docker daemon</a></h3><p>The Docker daemon (<code>dockerd</code>) listens for Docker API requests and manages Docker objects such as images, containers, networks, and volumes. A daemon can also communicate with other daemons to manage Docker services.</p><h3 id="The-Docker-client"><a href="#The-Docker-client" class="headerlink" title="The Docker client"></a><a href="https://docs.docker.com/get-started/overview/#the-docker-client">The Docker client</a></h3><p>The Docker client (<code>docker</code>) is the primary way that many Docker users interact with Docker. When you use commands such as <code>docker run</code>, the client sends these commands to <code>dockerd</code>, which carries them out. The <code>docker</code> command uses the Docker API. The Docker client can communicate with more than one daemon.</p><h3 id="Docker-registries"><a href="#Docker-registries" class="headerlink" title="Docker registries"></a><a href="https://docs.docker.com/get-started/overview/#docker-registries">Docker registries</a></h3><p>A Docker registry stores Docker images. Docker Hub is a public registry that anyone can use, and Docker looks for images on Docker Hub by default. You can even run your own private registry.</p><p>When you use the <code>docker pull</code> or <code>docker run</code> commands, Docker pulls the required images from your configured registry. When you use the <code>docker push</code> command, Docker pushes your image to your configured registry.</p><h3 id="Docker-objects"><a href="#Docker-objects" class="headerlink" title="Docker objects"></a><a href="https://docs.docker.com/get-started/overview/#docker-objects">Docker objects</a></h3><p>When you use Docker, you are creating and using images, containers, networks, volumes, plugins, and other objects. This section is a brief overview of some of those objects.</p><h4 id="Images"><a href="#Images" class="headerlink" title="Images"></a><a href="https://docs.docker.com/get-started/overview/#images">Images</a></h4><p>An image is a read-only template with instructions for creating a Docker container. Often, an image is based on another image, with some additional customization. For example, you may build an image which is based on the <code>ubuntu</code> image, but installs the Apache web server and your application, as well as the configuration details needed to make your application run.</p><p>You might create your own images or you might only use those created by others and published in a registry. To build your own image, you create a Dockerfile with a simple syntax for defining the steps needed to create the image and run it. Each instruction in a Dockerfile creates a layer in the image. When you change the Dockerfile and rebuild the image, only those layers which have changed are rebuilt. This is part of what makes images so lightweight, small, and fast, when compared to other virtualization technologies.</p><h4 id="Containers"><a href="#Containers" class="headerlink" title="Containers"></a><a href="https://docs.docker.com/get-started/overview/#containers">Containers</a></h4><p>A container is a runnable instance of an image. You can create, start, stop, move, or delete a container using the Docker API or CLI. You can connect a container to one or more networks, attach storage to it, or even create a new image based on its current state.</p><p>By default, a container is relatively well isolated from other containers and its host machine. You can control how isolated a container’s network, storage, or other underlying subsystems are from other containers or from the host machine.</p><p>A container is defined by its image as well as any configuration options you provide to it when you create or start it. When a container is removed, any changes to its state that aren’t stored in persistent storage disappear.</p><h5 id="Example-docker-run-command"><a href="#Example-docker-run-command" class="headerlink" title="Example docker run command"></a><a href="https://docs.docker.com/get-started/overview/#example-docker-run-command">Example docker run command</a></h5><p>The following command runs an <code>ubuntu</code> container, attaches interactively to your local command-line session, and runs <code>/bin/bash</code>.</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">$ docker <span class="hljs-keyword">run</span><span class="language-bash"> -i -t ubuntu /bin/bash</span><br></code></pre></td></tr></table></figure><p>When you run this command, the following happens (assuming you are using the default registry configuration):</p><ol><li><p>If you don’t have the <code>ubuntu</code> image locally, Docker pulls it from your configured registry, as though you had run <code>docker pull ubuntu</code> manually.</p></li><li><p>Docker creates a new container, as though you had run a <code>docker container create</code> command manually.</p></li><li><p>Docker allocates a read-write filesystem to the container, as its final layer. This allows a running container to create or modify files and directories in its local filesystem.</p></li><li><p>Docker creates a network interface to connect the container to the default network, since you didn’t specify any networking options. This includes assigning an IP address to the container. By default, containers can connect to external networks using the host machine’s network connection.</p></li><li><p>Docker starts the container and executes <code>/bin/bash</code>. Because the container is running interactively and attached to your terminal (due to the <code>-i</code> and <code>-t</code> flags), you can provide input using your keyboard while Docker logs the output to your terminal.</p></li><li><p>When you run <code>exit</code> to terminate the <code>/bin/bash</code> command, the container stops but isn’t removed. You can start it again or remove it.</p></li></ol><hr><h2 id="Docker完整架构"><a href="#Docker完整架构" class="headerlink" title="Docker完整架构"></a>Docker完整架构</h2><p>从 Docker 1.11 版本开始，Docker 容器运行就不是简单通过 Docker Daemon 来启动了，而是通过集成 containerd、runc 等多个组件来完成的。虽然 Docker Daemon 守护进程模块在不停的重构，但是基本功能和定位没有太大的变化，一直都是 CS 架构，守护进程负责和 Docker Client 端交互，并管理 Docker 镜像和容器。现在的架构中组件 containerd 就会负责集群节点上容器的生命周期管理，并向上为 Docker Daemon 提供 gRPC 接口。</p><p><img src="https://picdn.youdianzhishi.com/images/20210809154608.png" alt="docker 架构"></p><p>当我们要创建一个容器的时候，现在 Docker Daemon 并不能直接帮我们创建了，而是请求 <code>containerd</code> 来创建一个容器，containerd 收到请求后，也并不会直接去操作容器，而是创建一个叫做 <code>containerd-shim</code> 的进程，让这个进程去操作容器，我们指定容器进程是需要一个父进程来做状态收集、维持 stdin 等 fd 打开等工作的，假如这个父进程就是 containerd，那如果 containerd 挂掉的话，整个宿主机上所有的容器都得退出了，而引入 <code>containerd-shim</code> 这个垫片就可以来规避这个问题了。</p><p>然后创建容器需要做一些 namespaces 和 cgroups 的配置，以及挂载 root 文件系统等操作，这些操作其实已经有了标准的规范，那就是 OCI（开放容器标准），<code>runc</code> 就是它的一个参考实现.这个标准其实就是一个文档，主要规定了容器镜像的结构、以及容器需要接收哪些操作指令，比如 create、start、stop、delete 等这些命令。<code>runc</code> 就可以按照这个 OCI 文档来创建一个符合规范的容器，既然是标准肯定就有其他 OCI 实现，比如 Kata、gVisor 这些容器运行时都是符合 OCI 标准的。</p><p>所以真正启动容器是通过 <code>containerd-shim</code> 去调用 <code>runc</code> 来启动容器的，<code>runc</code> 启动完容器后本身会直接退出，<code>containerd-shim</code> 则会成为容器进程的父进程, 负责收集容器进程的状态, 上报给 containerd, 并在容器中 pid 为 1 的进程退出后接管容器中的子进程进行清理, 确保不会出现僵尸进程。</p>]]></content>
    
    
    <categories>
      
      <category>container</category>
      
    </categories>
    
    
    <tags>
      
      <tag>container</tag>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iptables详解</title>
    <link href="/2023/11/30/iptables%E8%AF%A6%E8%A7%A3/"/>
    <url>/2023/11/30/iptables%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p>防火墙，其实说白了讲，就是用于实现Linux下访问控制的功能的，它分为硬件的或者软件的防火墙两种。无论是在哪个网络中，防火墙工作的地方一定是在网络的边缘。而我们的任务就是需要去定义到底防火墙如何工作，这就是防火墙的策略，规则，以达到让它对出入网络的IP、数据进行检测。</p><p>目前市面上比较常见的有3、4层的防火墙，叫网络层的防火墙，还有7层的防火墙，其实是代理层的网关。</p><p>对于TCP&#x2F;IP的七层模型来讲，我们知道第三层是网络层，三层的防火墙会在这层对源地址和目标地址进行检测。但是对于七层的防火墙，不管你源端口或者目标端口，源地址或者目标地址是什么，都将对你所有的东西进行检查。所以，对于设计原理来讲，七层防火墙更加安全，但是这却带来了效率更低。所以市面上通常的防火墙方案，都是两者结合的。而又由于我们都需要从防火墙所控制的这个口来访问，所以防火墙的工作效率就成了用户能够访问数据多少的一个最重要的控制，配置的不好甚至有可能成为流量的瓶颈。</p><p><img src="https://2716750027-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-LlaUBNni4_0TG9UuF4O%2F-LlaUC6_aT-jhYVzesvT%2F-LlaUCpdSjavmSa4XDlu%2F1.png?generation=1565087556310544&alt=media"></p><p>iptables的前身叫ipfirewall （内核1.x时代）,这是一个作者从freeBSD上移植过来的，能够工作在内核当中的，对数据包进行检测的一款简易访问控制工具。但是ipfirewall工作功能极其有限(它需要将所有的规则都放进内核当中，这样规则才能够运行起来，而放进内核，这个做法一般是极其困难的)。当内核发展到2.x系列的时候，软件更名为ipchains，它可以定义多条规则，将他们串起来，共同发挥作用，而现在，它叫做iptables，可以将规则组成一个列表，实现绝对详细的访问控制功能。</p><p>他们都是工作在用户空间中，定义规则的工具，本身并不算是防火墙。它们定义的规则，可以让在内核空间当中的netfilter来读取，并且实现让防火墙工作。而放入内核的地方必须要是特定的位置，必须是tcp&#x2F;ip的协议栈经过的地方。而这个tcp&#x2F;ip协议栈必须经过的地方，可以实现读取规则的地方就叫做 netfilter.(网络过滤器)</p><ul><li><ol><li></li></ol><p>内核空间中：从一个网络接口进来，到另一个网络接口去的</p></li></ul><p>从上面的发展我们知道了作者选择了5个位置，来作为控制的地方，但是你有没有发现，其实前三个位置已经基本上能将路径彻底封锁了，但是为什么已经在进出的口设置了关卡之后还要在内部卡呢？ 由于数据包尚未进行路由决策，还不知道数据要走向哪里，所以在进出口是没办法实现数据过滤的。所以要在内核空间里设置转发的关卡，进入用户空间的关卡，从用户空间出去的关卡。那么，既然他们没什么用，那我们为什么还要放置他们呢？因为我们在做NAT和DNAT的时候，目标地址转换必须在路由之前转换。所以我们必须在外网而后内网的接口处进行设置关卡。</p><p>这五个位置也被称为五个钩子函数（hook functions）,也叫五个规则链。</p><p>这是NetFilter规定的五个规则链，任何一个数据包，只要经过本机，必将经过这五个链中的其中一个链。</p><p><img src="https://2716750027-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-LlaUBNni4_0TG9UuF4O%2F-LlaUC6_aT-jhYVzesvT%2F-LlaUCpfP6PsaTbNSWEH%2F2.png?generation=1565087556441446&alt=media"></p><ul><li><ol><li></li></ol><p>一个数据包进入网卡时，它首先进入PREROUTING链，内核根据数据包目的IP判断是否需要转发出去。</p></li><li><ol start="2"><li></li></ol><p>如果数据包就是进入本机的，它就会沿着图向下移动，到达INPUT链。数据包到了INPUT链后，任何进程都会收到它。本机上运行的程序可以发送数据包，这些数据包会经 过OUTPUT链，然后到达POSTROUTING链输出。</p></li><li><ol start="3"><li></li></ol><p>如果数据包是要转发出去的，且内核允许转发，数据包就会如图所示向右移动，经过 FORWARD链，然后到达POSTROUTING链输出。</p></li></ul><p>规则（rules）其实就是网络管理员预定义的条件，规则一般的定义为“如果数据包头符合这样的条件，就这样处理这个数据包”。规则存储在内核空间的信息包过滤表中，这些规则分别指定了源地址、目的地址、传输协议（如TCP、UDP、ICMP）和服务类型（如HTTP、FTP和SMTP）等。当数据包与规则匹配时，iptables就根据规则所定义的方法来处理这些数据包，如放行（accept）、拒绝（reject）和丢弃（drop）等。配置防火墙的主要工作就是添加、修改和删除这些规则。</p><p>链（chains）是数据包传播的路径，每一条链其实就是众多规则中的一个检查清单，每一条链中可以有一条或数条规则。当一个数据包到达一个链时，iptables就会从链中第一条规则开始检查，看该数据包是否满足规则所定义的条件。如果满足，系统就会根据该条规则所定义的方法处理该数据包；否则iptables将继续检查下一条规则，如果该数据包不符合链中任一条规则，iptables就会根据该链预先定义的默认策略来处理数据包。</p><p>表（tables）提供特定的功能，iptables内置了4个表，即raw表、filter表、nat表和mangle表，分别用于实现包过滤，网络地址转换和包重构的功能。</p><ul><li><p>RAW表：只使用在PREROUTING链和OUTPUT链上,因为优先级最高，从而可以对收到的数据包在连接跟踪前进行处理。一但用户使用了RAW表,在 某个链上,RAW表处理完后,将跳过NAT表和 ip_conntrack处理,即不再做地址转换和数据包的链接跟踪处理了.</p></li><li><p>filter表：主要用于过滤数据包，该表根据系统管理员预定义的一组规则过滤符合条件的数据包。对于防火墙而言，主要利用在filter表中指定的规则来实现对数据包的过滤。Filter表是默认的表，如果没有指定哪个表，iptables 就默认使用filter表来执行所有命令，filter表包含了INPUT链（处理进入的数据包），RORWARD链（处理转发的数据包），OUTPUT链（处理本地生成的数据包）在filter表中只能允许对数据包进行接受，丢弃的操作，而无法对数据包进行更改</p></li><li><p>nat表：主要用于网络地址转换NAT，该表可以实现一对一，一对多，多对多等NAT 工作，iptables就是使用该表实现共享上网的，NAT表包含了PREROUTING链（修改即将到来的数据包），POSTROUTING链（修改即将出去的数据包），OUTPUT链（修改路由之前本地生成的数据包）</p></li><li><p>mangle表：主要用于对指定数据包进行更改，在内核版本2.4.18 后的linux版本中该表包含的链为：INPUT链（处理进入的数据包），RORWARD链（处理转发的数据包），OUTPUT链（处理本地生成的数据包）POSTROUTING链（修改即将出去的数据包），PREROUTING链（修改即将到来的数据包）</p></li></ul><p><strong>Raw——&gt;mangle——&gt;nat——&gt;filter</strong></p><p>从外界到达防火墙的数据包，先被PREROUTING规则链处理（是否修改数据包地址等），之后会进行路由选择（判断该数据包应该发往何处），如果数据包 的目标主机是防火墙本机（比如说Internet用户访问防火墙主机中的web服务器的数据包），那么内核将其传给INPUT链进行处理（决定是否允许通 过等），通过以后再交给系统上层的应用程序（比如Apache服务器）进行响应。</p><p>来自外界的数据包到达防火墙后，首先被PREROUTING规则链处理，之后会进行路由选择，如果数据包的目标地址是其它外部地址（比如局域网用户通过网 关访问QQ站点的数据包），则内核将其传递给FORWARD链进行处理（是否转发或拦截），然后再交给POSTROUTING规则链（是否修改数据包的地 址等）进行处理。</p><p>防火墙本机向外部地址发送的数据包（比如在防火墙主机中测试公网DNS服务器时），首先被OUTPUT规则链处理，之后进行路由选择，然后传递给POSTROUTING规则链（是否修改数据包的地址等）进行处理。</p><p>iptables的命令格式较为复杂，一般的格式如下：</p><p>iptables [-t 表] -命令 匹配 操作</p><p>表选项用于指定命令应用于哪个iptables内置表。</p><p>命令选项用于指定iptables的执行方式，包括插入规则，删除规则和添加规则，如下表所示</p><p>-L –list &lt;链名&gt; 查看iptables规则列表</p><p>-A –append &lt;链名&gt; 在规则列表的最后增加1条规则</p><p>-I –insert &lt;链名&gt; 在指定的位置插入1条规则</p><p>-D –delete &lt;链名&gt; 从规则列表中删除1条规则</p><p>-R –replace &lt;链名&gt; 替换规则列表中的某条规则</p><p>-Z –zero &lt;链名&gt; 将表中数据包计数器和流量计数器归零</p><p>-X –delete-chain &lt;链名&gt; 删除自定义链</p><p>-v –verbose &lt;链名&gt; 与-L他命令一起使用显示更多更详细的信息</p><p>匹配选项指定数据包与规则匹配所具有的特征，包括源地址，目的地址，传输协议和端口号，如下表所示</p><p>-i –in-interface 网络接口名&gt; 指定数据包从哪个网络接口进入，</p><p>-o –out-interface 网络接口名&gt; 指定数据包从哪个网络接口输出</p><p>-p —proto 协议类型 指定数据包匹配的协议，如TCP、UDP和ICMP等</p><p>-s –source 源地址或子网&gt; 指定数据包匹配的源地址</p><p>--sport 源端口号&gt; 指定数据包匹配的源端口号</p><p>--dport 目的端口号&gt; 指定数据包匹配的目的端口号</p><p>-m –match 匹配的模块 指定数据包规则所使用的过滤模块</p><p>前面我们说过iptables处理动作除了 ACCEPT、REJECT、DROP、REDIRECT 、MASQUERADE 以外，还多出 LOG、ULOG、DNAT、RETURN、TOS、SNAT、MIRROR、QUEUE、TTL、MARK等。我们只说明其中最常用的动作：</p><ul><li>REJECT 拦阻该数据包，并返回数据包通知对方，可以返回的数据包有几个选择：ICMP port-unreachable、ICMP echo-reply 或是tcp-reset（这个数据包包会要求对方关闭联机），进行完此处理动作后，将不再比对其它规则，直接中断过滤程序。范例如下：</li></ul><p>iptables -A INPUT -p TCP –dport 22 -j REJECT –reject-with ICMP echo-reply</p><ul><li><p>DROP 丢弃数据包不予处理，进行完此处理动作后，将不再比对其它规则，直接中断过滤程序。</p></li><li><p>REDIRECT 将封包重新导向到另一个端口（PNAT），进行完此处理动作后，将会继续比对其它规则。这个功能可以用来实作透明代理 或用来保护web 服务器。例如：</p></li></ul><p>iptables -t nat -A PREROUTING -p tcp –dport 80 -j REDIRECT–to-ports 8081</p><ul><li>MASQUERADE 改写封包来源IP为防火墙的IP，可以指定port 对应的范围，进行完此处理动作后，直接跳往下一个规则链（mangle:postrouting）。这个功能与 SNAT 略有不同，当进行IP 伪装时，不需指定要伪装成哪个 IP，IP 会从网卡直接读取，当使用拨接连线时，IP 通常是由 ISP 公司的 DHCP服务器指派的，这个时候 MASQUERADE 特别有用。范例如下：</li></ul><p>iptables -t nat -A POSTROUTING -p TCP -j MASQUERADE –to-ports 21000-31000</p><ul><li>LOG 将数据包相关信息纪录在 &#x2F;var&#x2F;log 中，详细位置请查阅 &#x2F;etc&#x2F;syslog.conf 配置文件，进行完此处理动作后，将会继续比对其它规则。例如：</li></ul><p>iptables -A INPUT -p tcp -j LOG –log-prefix “input packet”</p><ul><li>SNAT 改写封包来源 IP 为某特定 IP 或 IP 范围，可以指定 port 对应的范围，进行完此处理动作后，将直接跳往下一个规则炼（mangle:postrouting）。范例如下：</li></ul><p>iptables -t nat -A POSTROUTING -p tcp-o eth0 -j SNAT –to-source 192.168.10.15-192.168.10.160:2100-3200</p><ul><li>DNAT 改写数据包包目的地 IP 为某特定 IP 或 IP 范围，可以指定 port 对应的范围，进行完此处理动作后，将会直接跳往下一个规则链（filter:input 或 filter:forward）。范例如下：</li></ul><p>iptables -t nat -A PREROUTING -p tcp -d 15.45.23.67 –dport 80 -j DNAT –to-destination 192.168.10.1-192.168.10.10:80-100</p><ul><li><p>MIRROR 镜像数据包，也就是将来源 IP与目的地IP对调后，将数据包返回，进行完此处理动作后，将会中断过滤程序。</p></li><li><p>QUEUE 中断过滤程序，将封包放入队列，交给其它程序处理。透过自行开发的处理程序，可以进行其它应用，例如：计算联机费用等。</p></li><li><p>RETURN 结束在目前规则链中的过滤程序，返回主规则链继续过滤，如果把自订规则炼看成是一个子程序，那么这个动作，就相当于提早结束子程序并返回到主程序中。</p></li><li><p>MARK 将封包标上某个代号，以便提供作为后续过滤的条件判断依据，进行完此处理动作后，将会继续比对其它规则。范例如下：</p></li></ul><p>iptables -t mangle -A PREROUTING -p tcp –dport 22 -j MARK –set-mark 22</p><p>iptables -L -n -v –line-numbers</p><p>iptables -L INPUT -n –line-numbers</p><p>iptables -L OUTPUT -n –line-numbers</p><p>iptables -L OUTPUT -n –line-numbers | less</p><p>iptables -L OUTPUT -n –line-numbers | grep 202.54.1.1</p><p>iptables -I INPUT 2 -s 202.54.1.2 -j DROP</p><p>iptables-restore &lt; &#x2F;root&#x2F;my.active.firewall.rules</p><p>iptables -A INPUT -i eth1 -s 192.168.0.0&#x2F;24 -j DROP</p><p>iptables -A INPUT -i eth1 -s 10.0.0.0&#x2F;8 -j DROP</p><p>iptables -A INPUT -s 1.2.3.4 -j DROP</p><p>iptables -A INPUT -s 192.168.0.0&#x2F;24 -j DROP</p><p>iptables -A INPUT -p tcp -s 1.2.3.4 –dport 80 -j DROP</p><p>iptables -A INPUT -i eth1 -p tcp -s 192.168.1.0&#x2F;24 –dport 80 -j DROP</p><p>iptables -A OUTPUT -d 192.168.1.0&#x2F;24 -j DROP</p><p>iptables -A OUTPUT -o eth1 -d 192.168.1.0&#x2F;24 -j DROP</p><p>iptables -A INPUT -i eth1 -s 10.0.0.0&#x2F;8 -j LOG –log-prefix “IP_SPOOF A: “</p><p>iptables -A INPUT -i eth1 -s 10.0.0.0&#x2F;8 -j DROP</p><p>iptables -A INPUT -m mac –mac-source 00:0F:EA:91:04:08 -j DROP</p><p>只接收MAC地址为00:0F:EA:91:04:07的TCP流量</p><p>iptables -A INPUT -p tcp –destination-port 22 -m mac –mac-source 00:0F:EA:91:04:07 -j ACCEPT</p><p>iptables -A INPUT -p icmp –icmp-type echo-request -j DROP</p><p>iptables -A INPUT -i eth1 -p icmp –icmp-type echo-request -j DROP</p><p>iptables -A INPUT -m state –state NEW -m tcp -p tcp –dport 7000:7010 -j ACCEPT</p><p>iptables -A INPUT -p tcp –destination-port 80 -m iprange –src-range 192.168.1.100-192.168.1.200 -j ACCEPT</p><p>如果想要删除一条规则，那么可以直接使用序号，例如 INPUT 的第 4 条可以直接这么删除</p>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
      <category>network</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>network</tag>
      
      <tag>iptables</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>容器网络模型</title>
    <link href="/2023/11/29/%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/"/>
    <url>/2023/11/29/%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="构建容器网络模型"><a href="#构建容器网络模型" class="headerlink" title="构建容器网络模型"></a>构建容器网络模型</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>在上一节中，通过 Linux 的网络虚拟化技术构建了一个网络，连接了容器的网络Namespace 和宿主机网络，其中做了命名空间创建、设备创建、地址分配、挂载设备和地址转换配置等操作，本节会将这些操作抽象出网络的模型以便于用代码实现上面一系列流程。</p><h2 id="2-模型"><a href="#2-模型" class="headerlink" title="2. 模型"></a>2. 模型</h2><p>首先，需要抽象出容器网络的两个对象：网络和网络端点。</p><h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><p>网络是容器的一个集合，在这个网络上的容器可以通过这个网络互相通信，就像挂载到同一个 Linux Bridge 设备上的网络设备一样， 可以直接通过 Bridge 设备实现网络互连;连接到同一个网络中的容器也可以通过这个网络和网络中别的容器互连。网络中会包括这个网络相关的配置，比如网络的容器地址段、网络操作所调用的网络驱动等信息。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Network <span class="hljs-keyword">struct</span> &#123;<br>Name    <span class="hljs-type">string</span>     <span class="hljs-comment">// 网络名</span><br>IPRange *net.IPNet <span class="hljs-comment">// 地址段</span><br>Driver  <span class="hljs-type">string</span>     <span class="hljs-comment">// 网络驱动名</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="网络端点"><a href="#网络端点" class="headerlink" title="网络端点"></a>网络端点</h3><p>网络端点是用于连接容器与网络的，保证容器内部与网络的通信。像上一节中用到的 Veth 设备，一端挂载到容器内部，另一端挂载到 Bridge 上，就能使得容器和网络的通信。</p><p>网络端点中会包括连接到网络的一些信息，比如地址、Veth 设备、端口映射、连接的容器和网络等信息。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Endpoint <span class="hljs-keyword">struct</span> &#123;<br>ID          <span class="hljs-type">string</span>           <span class="hljs-string">`json:&quot;id&quot;`</span><br>Device      netlink.Veth     <span class="hljs-string">`json:&quot;dev&quot;`</span><br>IPAddress   net.IP           <span class="hljs-string">`json:&quot;ip&quot;`</span><br>MacAddress  net.HardwareAddr <span class="hljs-string">`json:&quot;mac&quot;`</span><br>Network     *Network<br>PortMapping []<span class="hljs-type">string</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="网络驱动"><a href="#网络驱动" class="headerlink" title="网络驱动"></a>网络驱动</h3><p>网络驱动(Network Driver) 是一个网络功能中的组件，不同的驱动对网络的创建、连接、销毁的策略不同，通过在创建网络时指定不同的网络驱动来定义使用哪个驱动做网络的配置。</p><p>它的接口定义如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Driver <span class="hljs-keyword">interface</span> &#123;<br>Name() <span class="hljs-type">string</span><br>Create(subnet <span class="hljs-type">string</span>, name <span class="hljs-type">string</span>) (*Network, <span class="hljs-type">error</span>)<br>Delete(network Network) <span class="hljs-type">error</span><br>Connect(network *Network, endpoint *Endpoint) <span class="hljs-type">error</span><br>Disconnect(network Network, endpoint *Endpoint) <span class="hljs-type">error</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="IPAM"><a href="#IPAM" class="headerlink" title="IPAM"></a>IPAM</h3><p>IPAM(IP Address Management) 也是网络功能中的一个组件，用于网络 IP 地址的分配和释放，包括容器的IP地址和网络网关的IP地址，它的主要功能如下。</p><ul><li>IPAM.Allocate(subnet *net.IPNet) 从指定的 subnet 网段中分配 IP 地址</li><li>IPAM.Release(subnet net.IPNet, ipaddr net.IP) 从指定的 subnet 网段中释放掉指定的 IP 地址。</li></ul><h2 id="3-调用关系"><a href="#3-调用关系" class="headerlink" title="3. 调用关系"></a>3. 调用关系</h2><h3 id="创建网络"><a href="#创建网络" class="headerlink" title="创建网络"></a>创建网络</h3><p>通过<code>mydocker network create</code>命令创建一个容器网络：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mydocker network create --subset 192.168.0.0/24 --deive bridge testbr<br></code></pre></td></tr></table></figure><p>通过 Bridge 网络驱动创建一个网络，网段是 192.168.0.0&#x2F;24。</p><p>具体流程如下图所示：</p><!-- ![](/source/_posts/容器网络模型/网络创建流程.png) --><p><img src="https://github.com/lixd/daily-notes/raw/master/Golang/mydocker/assets/%E7%BD%91%E7%BB%9C%E5%88%9B%E5%BB%BA%E6%B5%81%E7%A8%8B.png"></p><p>在调用命令创建网络时，先通过 IPAM 获取网络的网关 IP,然后再调用网络驱动去设置网络的信息，比如 Bridge 的驱动将会创建 Linux Bridge 网络设备和相应的<br>iptables规则，最终将网络的信息返回给调用者。</p><p>上图中的 IPAM 和 Network Driver 是两个组件，IPAM 负责通过传入的IP网段去分配一个可用的 IP 地址给容器和网络的网关，比如网络的网段是 192.168.0.0&#x2F;16， 那么通过 IPAM 获取这个网段的容器地址就是在这个网段中的一个 IP 地址，然后用于分配给容器的连接端点，保证网络中的容器 IP 不会冲突。</p><p>而 Network Driver 是用于网络的管理的，例如在创建网络时完成网络初始化动作及在容器启动时完成网络端点配置。像 Bridge 的驱动对应的动作就是创建 Linux Bridge 和挂载 Veth 设备。</p><h3 id="创建容器并连接网络"><a href="#创建容器并连接网络" class="headerlink" title="创建容器并连接网络"></a>创建容器并连接网络</h3><p>通过创建容器时指定<code>-net</code> 参数，指定容器启动时连接的网络。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mydocker run -it -p 80:80 --net testbridgenet xxxx<br></code></pre></td></tr></table></figure><p>这样创建出的容器便可以通过 testbridgenet 这个网络与网络中的其他容器进行通信了。</p><p>具体流程图如下：<br><img src="https://github.com/lixd/daily-notes/raw/master/Golang/mydocker/assets/%E5%AE%B9%E5%99%A8%E5%8A%A0%E5%85%A5%E7%BD%91%E7%BB%9C%E6%B5%81%E7%A8%8B.png"><br>在调用创建容器时指定网络，首先会调用IPAM,通过网络中定义的网段找到未分配的 IP 分配给容器，然后创建容器的网络端点，并调用这个网络的网络驱动连接网络与网络端点，最终完成网络端点的连接和配置。比如在 Bridge 驱动中就会将Veth 设备挂载到 Linux Bridge 网桥上。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Connect</span><span class="hljs-params">(networkName <span class="hljs-type">string</span>, info *container.Info)</span></span> <span class="hljs-type">error</span> &#123;<br><span class="hljs-comment">// 从networks字典中取到容器连接的网络的信息，networks字典中保存了当前己经创建的网络</span><br>network, ok := networks[networkName]<br><span class="hljs-keyword">if</span> !ok &#123;<br><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;no Such Network: %s&quot;</span>, networkName)<br>&#125;<br><br><span class="hljs-comment">// 分配容器IP地址</span><br>ip, err := ipAllocator.Allocate(network.IpRange)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><br><span class="hljs-comment">// 创建网络端点</span><br>ep := &amp;Endpoint&#123;<br>ID:          fmt.Sprintf(<span class="hljs-string">&quot;%s-%s&quot;</span>, cinfo.Id, networkName),<br>IPAddress:   ip,<br>Network:     network,<br>PortMapping: info.PortMapping,<br>&#125;<br><span class="hljs-comment">// 调用网络驱动挂载和配置网络端点</span><br><span class="hljs-keyword">if</span> err = drivers[network.Driver].Connect(network, ep); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><span class="hljs-comment">// 到容器的namespace配置容器网络设备IP地址</span><br><span class="hljs-keyword">if</span> err = configEndpointIpAddressAndRoute(ep, info); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><br><span class="hljs-keyword">return</span> configPortMapping(ep, info)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="展示网络列表"><a href="#展示网络列表" class="headerlink" title="展示网络列表"></a>展示网络列表</h3><p>通过 <code>mydocker network list</code>命令显示当前创建了哪些网络。</p><p>首先从网络配置的目录中加载所有的网络配置信息到 networks 字典中，如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Init</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span> &#123;<br><span class="hljs-comment">// 加载网络驱动</span><br><span class="hljs-keyword">var</span> bridgeDriver = BridgeNetworkDriver&#123;&#125;<br>drivers[bridgeDriver.Name()] = &amp;bridgeDriver<br><span class="hljs-comment">// 文件不存在则创建</span><br><span class="hljs-keyword">if</span> _, err := os.Stat(defaultNetworkPath); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">if</span> !os.IsNotExist(err) &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><span class="hljs-keyword">if</span> err = os.MkdirAll(defaultNetworkPath, constant.Perm0644); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br>&#125;<br><span class="hljs-comment">// 检查网络配置目录中的所有文件,并执行第二个参数中的函数指针去处理目录下的每一个文件</span><br>err := filepath.Walk(defaultNetworkPath, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(nwPath <span class="hljs-type">string</span>, info os.FileInfo, err <span class="hljs-type">error</span>)</span></span> <span class="hljs-type">error</span> &#123;<br><span class="hljs-comment">// 如果是目录则跳过</span><br><span class="hljs-keyword">if</span> info.IsDir() &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><span class="hljs-comment">// if strings.HasSuffix(nwPath, &quot;/&quot;) &#123;</span><br><span class="hljs-comment">// return nil</span><br><span class="hljs-comment">// &#125;</span><br><span class="hljs-comment">//  加载文件名作为网络名</span><br>_, nwName := path.Split(nwPath)<br>nw := &amp;Network&#123;<br>Name: nwName,<br>&#125;<br><span class="hljs-comment">// 调用前面介绍的 Network.load 方法加载网络的配置信息</span><br><span class="hljs-keyword">if</span> err = nw.load(nwPath); err != <span class="hljs-literal">nil</span> &#123;<br>logrus.Errorf(<span class="hljs-string">&quot;error load network: %s&quot;</span>, err)<br>&#125;<br><span class="hljs-comment">// 将网络的配置信息加入到 networks 字典中</span><br>networks[nwName] = nw<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;)<br><span class="hljs-keyword">return</span> err<br>&#125;<br></code></pre></td></tr></table></figure><p>上面己经把网络配置目录中的所有网络配置加载到了 networks 典中， 然后通过遍历这个字典来展示创建的网络，如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ListNetwork</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 通过tabwriter库把信息打印到屏幕上</span><br>w := tabwriter.NewWriter(os.Stdout, <span class="hljs-number">12</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-number">0</span>)<br>fmt.Fprint(w, <span class="hljs-string">&quot;NAME\tIpRange\tDriver\n&quot;</span>)<br><span class="hljs-keyword">for</span> _, nw := <span class="hljs-keyword">range</span> networks &#123;<br>fmt.Fprintf(w, <span class="hljs-string">&quot;%s\t%s\t%s\n&quot;</span>,<br>nw.Name,<br>nw.IPRange.String(),<br>nw.Driver,<br>)<br>&#125;<br><span class="hljs-keyword">if</span> err := w.Flush(); err != <span class="hljs-literal">nil</span> &#123;<br>logrus.Errorf(<span class="hljs-string">&quot;Flush error %v&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="删除网络"><a href="#删除网络" class="headerlink" title="删除网络"></a>删除网络</h3><p>通过使用命令 <code>mydocker network remove</code>命令删除己经创建的网络。</p><p>具体流程如下图：</p><p><img src="https://github.com/lixd/daily-notes/blob/master/Golang/mydocker/assets/%E7%BD%91%E7%BB%9C%E5%88%A0%E9%99%A4%E6%B5%81%E7%A8%8B.png"></p><ul><li>1）先调用 IPAM 去释放网络所占用的网关 IP</li><li>2）然后调用网络驱动去删除该网络创建的一些设备与配置</li><li>3）最终从网络配置目录中删除网络对应的配置文</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">DeleteNetwork</span><span class="hljs-params">(networkName <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">error</span> &#123;<br><span class="hljs-comment">// 网络不存在直接返回一个error</span><br>nw, ok := networks[networkName]<br><span class="hljs-keyword">if</span> !ok &#123;<br><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;no Such Network: %s&quot;</span>, networkName)<br>&#125;<br><span class="hljs-comment">// 调用IPAM的实例ipAllocator释放网络网关的IP</span><br><span class="hljs-keyword">if</span> err := ipAllocator.Release(nw.IpRange, &amp;nw.IpRange.IP); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> errors.Wrap(err, <span class="hljs-string">&quot;remove Network gateway ip failed&quot;</span>)<br>&#125;<br><span class="hljs-comment">// 调用网络驱动删除网络创建的设备与配置 后面会以 Bridge 驱动删除网络为例子介绍如何实现网络驱动删除网络</span><br><span class="hljs-keyword">if</span> err := drivers[nw.Driver].Delete(*nw); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> errors.Wrap(err, <span class="hljs-string">&quot;remove Network DriverError failed&quot;</span>)<br>&#125;<br><span class="hljs-comment">// 最后从网络的配直目录中删除该网络对应的配置文件</span><br><span class="hljs-keyword">return</span> nw.remove(defaultNetworkPath)<br>&#125;<br><br></code></pre></td></tr></table></figure><p>其中 network remove 会从网络配置目录中删除网络的配置文件。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(nw *Network)</span></span> remove(dumpPath <span class="hljs-type">string</span>) <span class="hljs-type">error</span> &#123;<br><span class="hljs-comment">// 检查网络对应的配置文件状态，如果文件己经不存在就直接返回</span><br>fullPath := path.Join(dumpPath, nw.Name)<br><span class="hljs-keyword">if</span> _, err := os.Stat(fullPath); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">if</span> !os.IsNotExist(err) &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><span class="hljs-comment">// 否则删除这个网络对应的配置文件</span><br><span class="hljs-keyword">return</span> os.Remove(fullPath)<br>&#125;<br></code></pre></td></tr></table></figure><p>转载自：<a href="https://github.com/lixd/mydocker">https://github.com/lixd/mydocker</a></p>]]></content>
    
    
    <categories>
      
      <category>container</category>
      
    </categories>
    
    
    <tags>
      
      <tag>container</tag>
      
      <tag>virtual network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux虚拟网络设备</title>
    <link href="/2023/11/29/linux%E8%99%9A%E6%8B%9F%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/"/>
    <url>/2023/11/29/linux%E8%99%9A%E6%8B%9F%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/</url>
    
    <content type="html"><![CDATA[<h2 id="Linux-虚拟网络设备"><a href="#Linux-虚拟网络设备" class="headerlink" title="Linux 虚拟网络设备"></a>Linux 虚拟网络设备</h2><h3 id="Linux-Veth"><a href="#Linux-Veth" class="headerlink" title="Linux Veth"></a>Linux Veth</h3><h4 id="veth-pair"><a href="#veth-pair" class="headerlink" title="veth-pair"></a>veth-pair</h4><p>顾名思义，veth-pair 就是一对的虚拟设备接口，和 tap&#x2F;tun 设备不同的是，它都是成对出现的。一端连着协议栈，一端彼此相连着。</p><p>一般用于跨 namespace 通信。</p><blockquote><p>Linux 中默认不同 net namespace 设备无法通信。</p></blockquote><h4 id="网络命名空间"><a href="#网络命名空间" class="headerlink" title="网络命名空间"></a>网络命名空间</h4><p>为了支持网络协议栈的多个实例，Linux在网络栈中引入了网络命名空间。这些独立的协议栈被隔离到不同的命名空间中。</p><h4 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h4><p>本次演示中，先创建一个网络命名空间，然后创建一个 veth 设备对，将设备对分别切换到不同的命名空间中，实现不同命名空间的互相通信。</p><p>准备一个 net namespace</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 1创建 namespace</span><br>$ ip netns add netns1<br><span class="hljs-comment"># 查询</span><br>$ ip netns list<br>netns1 (<span class="hljs-built_in">id</span>: 0)<br></code></pre></td></tr></table></figure><p>创建两个Veth设备对</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># ip link add &lt;veth name&gt; type veth peer name &lt;peer name&gt;</span><br>$ ip <span class="hljs-built_in">link</span> add veth0 <span class="hljs-built_in">type</span> veth peer name veth1<br><span class="hljs-comment"># 查询</span><br>$ ip <span class="hljs-built_in">link</span> show<br></code></pre></td></tr></table></figure><p>此时两个 veth 都在默认 net namespace 中，为了测试，先将其中一个切换到 netns1</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> veth1 netns netns1<br><span class="hljs-comment"># 此时再看就只能看到一个了</span><br>$ ip <span class="hljs-built_in">link</span> show<br><span class="hljs-comment"># 去 netns 中查询</span><br>$ ip netns <span class="hljs-built_in">exec</span> netns1 ip <span class="hljs-built_in">link</span> show<br></code></pre></td></tr></table></figure><p>至此，两个不同的命名空间各自有一个Veth，不过还不能通信，因为我们还没给它们分配IP</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ ip netns <span class="hljs-built_in">exec</span> netns1 ip addr add 10.1.1.1/24 dev veth1<br>$ ip addr add 10.1.1.2/24 dev veth0<br></code></pre></td></tr></table></figure><p>再启动它们</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ ip netns <span class="hljs-built_in">exec</span> netns1 ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> dev veth1 up<br>$ ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> dev veth0 up<br></code></pre></td></tr></table></figure><p>现在两个网络命名空间可以互相通信了</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ ping 10.1.1.1<br></code></pre></td></tr></table></figure><p>至此，Veth设备对的基本原理和用法演示结束。</p><blockquote><p>Docker 内部，Veth设备对也是连通容器与宿主机的主要网络设备。</p></blockquote><h3 id="Linux-Bridge"><a href="#Linux-Bridge" class="headerlink" title="Linux Bridge"></a>Linux Bridge</h3><p>Bridge 虚拟设备是用来桥接的网络设备，它相当于现实世界中的交换机，可以连接不同的网络设备，当请求到达 Bridge 设备时，可以通过报文中的 Mac 地址进行广播或转发。</p><p>例如，我们可以创建一个 Bridge 设备来连接 Namespace 中的网络设备和宿主机上的网络。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">创建veth设备并将一端移动到指定Namespace中</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo ip netns add ns1</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo ip <span class="hljs-built_in">link</span> add veth0 <span class="hljs-built_in">type</span> veth peer name veth1</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> veth1 netns ns1</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">先安装bridge-utils</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo apt-get install bridge-utils</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">创建网桥,</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo brctl addbr br0</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">挂载网络设备</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo brctl addif br0 eth0</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo brctl addif br0 veth0</span><br></code></pre></td></tr></table></figure><p><a href="https://zhuanlan.zhihu.com/p/339070912">linux bridge实践</a></p><h2 id="3-Linux-路由表"><a href="#3-Linux-路由表" class="headerlink" title="3. Linux 路由表"></a>3. Linux 路由表</h2><p>路由表是 Linux 内核的一个模块，通过定义路由表来决定在某个网络Namespace 中包的流向，从而定义请求会到哪个网络设备上。</p><p>继续以上面的例子演示</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">启动宿主机上的虚拟网络设备，</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> veth0 up</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> br0 up</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">给ns1中的虚拟网络设备设置IP并启动它</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo ip netns <span class="hljs-built_in">exec</span> ns1 ip addr add 172.18.0.2/24 dev veth1</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo ip netns <span class="hljs-built_in">exec</span> ns1 ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> dev veth1 up</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">分别设置ns1网络空间的路由和宿主机上的路由</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">default代表0.0.0.0/0,即在Net Namespace中的所有流量都经过veth1的网络设备流出</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo apt-get install net-tools</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo ip netns <span class="hljs-built_in">exec</span> ns1  route add default dev veth1</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">在宿主机上将172.18.0.0/24网段的请求路由到br0网桥</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo route add -net 172.18.0.0/24 dev br0</span><br></code></pre></td></tr></table></figure><p>通过设置路由，对IP地址的请求就能正确被路由到对应的网络设备上，从而实现通信，如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">查看宿主机的IP地址</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo ip addr show eth0</span><br>6: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq master br0 state UP group default qlen 1000<br>    link/ether 00:15:5d:ff:cd:9a brd ff:ff:ff:ff:ff:ff<br>    inet 172.20.160.67/20 brd 172.20.175.255 scope global eth0<br>       valid_lft forever preferred_lft forever<br>    inet6 fe80::215:5dff:feff:cd9a/64 scope link<br>       valid_lft forever preferred_lft forever<br><span class="hljs-meta prompt_">#</span><span class="language-bash">从Namespace中访问宿主机的地址</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo ip netns <span class="hljs-built_in">exec</span> ns1 ping -c 1 172.20.160.67</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">从宿主机访问Namespace中的网络地址</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">ping -c 1 172.18.0.2</span><br></code></pre></td></tr></table></figure><p>到此就实现了通过网桥连接不同Namespace网络了。</p><h2 id="4-Linux-iptables"><a href="#4-Linux-iptables" class="headerlink" title="4. Linux iptables"></a>4. Linux iptables</h2><p>iptables 是对 Linux 内核的 netfilter 模块进行操作和展示的工具，用来管理包的流动和转送。iptables 定义了一套链式处理的结构，在网络包传输的各个阶段可以使用不同的策略对包进行加工、传送或丢弃。</p><p>在容器虚拟化的技术中，经常会用到两种策略 MASQUERADE 和 DNAT，用于容器和宿主机外部的网络通信。</p><h3 id="MASQUERADE"><a href="#MASQUERADE" class="headerlink" title="MASQUERADE"></a>MASQUERADE</h3><p>iptables 中的 MASQUERADE 策略可以将请求包中的源地址转换成一个网络设备的地址。</p><p>比如上述例子中的那个 Namespace 中网络设备的地址是 172.18.0.2, 这个地址虽然在宿主机上可以路由到 br0 网桥，但是到达宿主机外部之后，是不知道如何路由到这个 IP 地址的，所以如果要请求外部地址的话，需要先通过MASQUERADE 策略将这个 IP 转换成宿主机出口网卡的 IP。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">打开IP转发</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo sysctl -w net.ipv4.conf.all.forwarding=1</span><br>net.ipv4.conf.all.forwarding = 1<br><span class="hljs-meta prompt_">#</span><span class="language-bash">对Namespace中发出的包添加网络地址转换</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo iptables -t nat -A POSTROUTING -s 172.18.0.0/24 -o eth0 -j MASQUERADE</span><br></code></pre></td></tr></table></figure><p>在 Namespace 中请求宿主机外部地址时，将 Namespace 中的源地址转换成宿主机的地址作为源地址，就可以在 Namespace 中访问宿主机外的网络了。</p><h3 id="DNAT"><a href="#DNAT" class="headerlink" title="DNAT"></a>DNAT</h3><p>iptables 中的 DNAT 策略也是做网络地址的转换，不过它是要更换目标地址，经常用于将内部网络地址的端口映射到外部去。</p><p>比如，上面那个例子中的 Namespace 如果需要提供服务给宿主机之外的应用去请求要怎么办呢?</p><p>外部应用没办法直接路由到 172.18.0.2 这个地址，这时候就可以用到 DNAT 策略。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">将宿主机上80端口的请求转发到Namespace里的IP上</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo iptables -t nat -A PREROUTING -p tcp -m tcp --dport 80 -j DNAT --to-destination 172.18.0.2:80</span><br></code></pre></td></tr></table></figure><p>这样就可以把宿主机上 80 端口的 TCP 请求转发到 Namespace 中的地址172.18.0.2:80,从而实现外部的应用调用。</p><h2 id="5-Go语言网络库"><a href="#5-Go语言网络库" class="headerlink" title="5. Go语言网络库"></a>5. Go语言网络库</h2><p>容器网络用到的技术就是上面提到的几个点，不过用 Go 语言该怎么配置呢？</p><p>Go 中需要用到的几个网络库介绍。</p><h3 id="net-库"><a href="#net-库" class="headerlink" title="net 库"></a>net 库</h3><p>net 库是 Go 语言内置的库，提供了跨平台支持的网络地址处理，以及各种常见协议的IO支持，比如TCP、UDP、DNS、Unix Socket等。</p><h3 id="netlink库"><a href="#netlink库" class="headerlink" title="netlink库"></a>netlink库</h3><p><a href="https://github.com/vishvananda/netlink">netlink库</a> 是Go 语言的操作网络接口、路由表等配置的库 ，使用它的调用相当于我们通过 IP 命令去管理网络接口。</p><h3 id="netns库"><a href="#netns库" class="headerlink" title="netns库"></a>netns库</h3><p><a href="https://github.com/vishvananda/netns">netns库</a> 就是 Go 语言版的<code>ip netns exec</code> 命令实现。通过这个库可以让 netlink 库中配置网络接口的代码在某个容器的 Net amespace 中执行。</p><h3 id="单节点容器相互访问"><a href="#单节点容器相互访问" class="headerlink" title="单节点容器相互访问"></a>单节点容器相互访问</h3><p><img src="https://pic2.zhimg.com/v2-b3b33ed53fdfd86fff8ace576528f671_b.jpg"></p><p><img src="https://pic2.zhimg.com/80/v2-b3b33ed53fdfd86fff8ace576528f671_1440w.webp"></p><p>veth pair的一端在network namespace中，另一端接在了linux bridge上，所以图中的veth00&#x2F;veth01就变为了从设备（linux bridge），即他们就变为了网线，没有了处理数据包的能力，只能转发数据包。</p><p>以192.268.3.101（container1） → 192.268.3.106（container2）为例：</p><p>1、 container1发送APR请求得到container2的mac地址</p><p>2、 container1的这个请求出现在了docker0网桥</p><p>3、 docker0网桥将ARP广播转发到其他接在docker0上的设备</p><p>4、 container2收到这个ARP请求，响应给container1</p><p>5、 container1拿到mac地址封装ICMP请求</p><p>6、 同样这个请求也会经由docker0出现在宿主机上</p><p>7、 docker0查到container2属于自己就转发给了container2</p><h3 id="容器访问外部网络"><a href="#容器访问外部网络" class="headerlink" title="容器访问外部网络"></a>容器访问外部网络</h3><p><img src="https://pic3.zhimg.com/v2-f7891b35584bd9a960fb042e1a651206_b.jpg"></p><p><img src="https://pic3.zhimg.com/80/v2-f7891b35584bd9a960fb042e1a651206_1440w.webp"></p><p>以图中的container2要访问百度为例：</p><p>1、 container2 ping 220.181.38.148</p><p>2、 数据包同样会到达docker0网桥，即到达了宿主机</p><p>3、宿主机发现目的目的网段要交给eth0处理</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">~# route -n<br>Kernel IP routing table<br>Destination     Gateway         Genmask         Flags Metric Ref    Use Iface<br>0.0.0.0         172.28.143.253  0.0.0.0         UG    100    0        0 eth0<br>172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 docker0<br></code></pre></td></tr></table></figure><p>4、 由于源ip是内网ip还要进行一个NAT，通过eth0发到外网</p><p>转载自: <a href="https://github.com/lixd/daily-notes/blob/master/Golang/mydocker/06-1-%E7%BD%91%E7%BB%9C%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF.md">https://github.com/lixd/daily-notes/blob/master/Golang/mydocker/06-1-%E7%BD%91%E7%BB%9C%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF.md</a></p>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
      <category>network</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux mount用法</title>
    <link href="/2023/11/28/systemcall-mount%E5%88%86%E7%B1%BB/"/>
    <url>/2023/11/28/systemcall-mount%E5%88%86%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="mount-–bind"><a href="#mount-–bind" class="headerlink" title="mount –bind"></a>mount –bind</h2><p>我们可以通过mount –bind命令来将两个目录连接起来，mount –bind命令是将前一个目录挂载到后一个目录上，所有对后一个目录的访问其实都是对前一个目录的访问，如下所示：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-comment">## test1 test2为两个不同的目录</span><br>linux-<span class="hljs-title class_">UMLhEm</span><span class="hljs-symbol">:/home/test/linux</span> <span class="hljs-comment"># ls test1</span><br><span class="hljs-number">11</span>.test  <span class="hljs-number">1</span>.test<br>linux-<span class="hljs-title class_">UMLhEm</span><span class="hljs-symbol">:/home/test/linux</span> <span class="hljs-comment"># ls test2</span><br><span class="hljs-number">22</span>.test  <span class="hljs-number">2</span>.test<br>linux-<span class="hljs-title class_">UMLhEm</span><span class="hljs-symbol">:/home/test/linux</span> <span class="hljs-comment"># ls -lid test1</span><br><span class="hljs-number">1441802</span> drwx------ <span class="hljs-number">2</span> root root <span class="hljs-number">4096</span> <span class="hljs-title class_">Feb</span> <span class="hljs-number">13</span> 09<span class="hljs-symbol">:</span><span class="hljs-number">50</span> test1<br>linux-<span class="hljs-title class_">UMLhEm</span><span class="hljs-symbol">:/home/test/linux</span> <span class="hljs-comment"># ls -lid test2</span><br><span class="hljs-number">1441803</span> drwx------ <span class="hljs-number">2</span> root root <span class="hljs-number">4096</span> <span class="hljs-title class_">Feb</span> <span class="hljs-number">13</span> 09<span class="hljs-symbol">:</span><span class="hljs-number">51</span> test2<br><br><span class="hljs-comment">## 执行mount --bind 将test1挂载到test2上，inode号都变为test1的inode</span><br>linux-<span class="hljs-title class_">UMLhEm</span><span class="hljs-symbol">:/home/test/linux</span> <span class="hljs-comment"># mount --bind test1 test2</span><br>linux-<span class="hljs-title class_">UMLhEm</span><span class="hljs-symbol">:/home/test/linux</span> <span class="hljs-comment"># ls -lid test1</span><br><span class="hljs-number">1441802</span> drwx------ <span class="hljs-number">2</span> root root <span class="hljs-number">4096</span> <span class="hljs-title class_">Feb</span> <span class="hljs-number">13</span> 09<span class="hljs-symbol">:</span><span class="hljs-number">50</span> test1<br>linux-<span class="hljs-title class_">UMLhEm</span><span class="hljs-symbol">:/home/test/linux</span> <span class="hljs-comment"># ls -lid test2</span><br><span class="hljs-number">1441802</span> drwx------ <span class="hljs-number">2</span> root root <span class="hljs-number">4096</span> <span class="hljs-title class_">Feb</span> <span class="hljs-number">13</span> 09<span class="hljs-symbol">:</span><span class="hljs-number">50</span> test2<br>linux-<span class="hljs-title class_">UMLhEm</span><span class="hljs-symbol">:/home/test/linux</span> <span class="hljs-comment"># ls test2</span><br><span class="hljs-number">11</span>.test  <span class="hljs-number">1</span>.test<br><br><span class="hljs-comment">## 对test2的访问或修改实际上是改动test1目录</span><br>linux-<span class="hljs-title class_">UMLhEm</span><span class="hljs-symbol">:/home/test/linux</span> <span class="hljs-comment"># cd test2</span><br>linux-<span class="hljs-title class_">UMLhEm</span><span class="hljs-symbol">:/home/test/linux/test2</span> <span class="hljs-comment"># touch 3.test</span><br>linux-<span class="hljs-title class_">UMLhEm</span><span class="hljs-symbol">:/home/test/linux/test2</span> <span class="hljs-comment"># ls</span><br><span class="hljs-number">11</span>.test  <span class="hljs-number">1</span>.test  <span class="hljs-number">3</span>.test<br>linux-<span class="hljs-title class_">UMLhEm</span><span class="hljs-symbol">:/home/test/linux/test2</span> <span class="hljs-comment"># cd ..</span><br>linux-<span class="hljs-title class_">UMLhEm</span><span class="hljs-symbol">:/home/test/linux</span> <span class="hljs-comment"># ls test1</span><br><span class="hljs-number">11</span>.test  <span class="hljs-number">1</span>.test  <span class="hljs-number">3</span>.test<br><br><span class="hljs-comment">## 解挂载后，test1目录保持修改，test2保持不变</span><br>linux-<span class="hljs-title class_">UMLhEm</span><span class="hljs-symbol">:/home/test/linux</span> <span class="hljs-comment"># umount test2</span><br>linux-<span class="hljs-title class_">UMLhEm</span><span class="hljs-symbol">:/home/test/linux</span> <span class="hljs-comment"># ls test1</span><br><span class="hljs-number">11</span>.test  <span class="hljs-number">1</span>.test  <span class="hljs-number">3</span>.test<br>linux-<span class="hljs-title class_">UMLhEm</span><span class="hljs-symbol">:/home/test/linux</span> <span class="hljs-comment"># ls test2</span><br><span class="hljs-number">22</span>.test  <span class="hljs-number">2</span>.test<br><br><span class="hljs-comment">## 将test2挂载到test1上</span><br>linux-<span class="hljs-title class_">UMLhEm</span><span class="hljs-symbol">:/home/test/linux</span> <span class="hljs-comment"># ls -lid test2</span><br><span class="hljs-number">1441803</span> drwx------ <span class="hljs-number">2</span> root root <span class="hljs-number">4096</span> <span class="hljs-title class_">Feb</span> <span class="hljs-number">13</span> 09<span class="hljs-symbol">:</span><span class="hljs-number">51</span> test2<br>linux-<span class="hljs-title class_">UMLhEm</span><span class="hljs-symbol">:/home/test/linux</span> <span class="hljs-comment"># mount --bind test2 test1</span><br>linux-<span class="hljs-title class_">UMLhEm</span><span class="hljs-symbol">:/home/test/linux</span> <span class="hljs-comment"># ls -lid test1</span><br><span class="hljs-number">1441803</span> drwx------ <span class="hljs-number">2</span> root root <span class="hljs-number">4096</span> <span class="hljs-title class_">Feb</span> <span class="hljs-number">13</span> 09<span class="hljs-symbol">:</span><span class="hljs-number">51</span> test1<br>linux-<span class="hljs-title class_">UMLhEm</span><span class="hljs-symbol">:/home/test/linux</span> <span class="hljs-comment"># ls -lid test2</span><br><span class="hljs-number">1441803</span> drwx------ <span class="hljs-number">2</span> root root <span class="hljs-number">4096</span> <span class="hljs-title class_">Feb</span> <span class="hljs-number">13</span> 09<span class="hljs-symbol">:</span><span class="hljs-number">51</span> test2<br>linux-<span class="hljs-title class_">UMLhEm</span><span class="hljs-symbol">:/home/test/linux</span> <span class="hljs-comment"># ls test1</span><br><span class="hljs-number">22</span>.test  <span class="hljs-number">2</span>.test<br></code></pre></td></tr></table></figure><p>以mount –bind test1 test2为例，当mount –bind命令执行后，Linux将会把被挂载目录的目录项（也就是该目录文件的block，记录了下级目录的信息）屏蔽，即test2的下级路径被隐藏起来了（注意，只是隐藏不是删除，数据都没有改变，只是访问不到了）。同时，内核将挂载目录（test1）的目录项记录在内存里的一个s_root对象里，在mount命令执行时，VFS会创建一个vfsmount对象，这个对象里包含了整个文件系统所有的mount信息，其中也会包括本次mount中的信息，这个对象是一个HASH值对应表（HASH值通过对路径字符串的计算得来），表里就有 &#x2F;test1 到 &#x2F;test2 两个目录的HASH值对应关系。</p><p>命令执行完后，当访问 &#x2F;test2下的文件时，系统会告知 &#x2F;test2 的目录项被屏蔽掉了，自动转到内存里找VFS，通过vfsmount了解到 &#x2F;test2 和 &#x2F;test1 的对应关系，从而读取到 &#x2F;test1 的inode，这样在 &#x2F;test2 下读到的全是 &#x2F;test1 目录下的文件。</p><blockquote><ul><li>.mount –bind连接的两个目录的inode号码并不一样，只是被挂载目录的block被屏蔽掉，inode被重定向到挂载目录的inode（被挂载目录的inode和block依然没变）。</li><li>.两个目录的对应关系存在于内存里，一旦重启挂载关系就不存在了。</li></ul></blockquote><p>在固件开发过程中常常遇到这样的情况：为测试某个新功能，必需修改某个系统文件。而这个文件在只读文件系统上（总不能为一个小小的测试就重刷固件吧），或者是虽然文件可写，但是自己对这个改动没有把握，不愿意直接修改。这时候mount –bind就是你的好帮手。 <br>假设我们要改的文件是&#x2F;etc&#x2F;hosts，可按下面的步骤操作： <br>1. 把新的hosts文件放在&#x2F;tmp下。当然也可放在硬盘或U盘上。 <br>2. mount –bind &#x2F;tmp&#x2F;hosts &#x2F;etc&#x2F;hosts       此时的&#x2F;etc目录是可写的，所做修改不会应用到原来的&#x2F;etc目录，可以放心测试。测试完成了执行 umount &#x2F;etc&#x2F;hosts 断开绑定。</p><p>通过执行下面的命令可以创建一个挂载点：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">mount <span class="hljs-comment">--bind foo foo</span><br></code></pre></td></tr></table></figure><p>在挂载后可以通过mount命令查看所有的挂载点.这样就可以使用一些mount的属性，最简单的例子，例如：</p><blockquote><p>sudo mount,ro –bind test_dir test_dir</p></blockquote><p>可以让test_dir成为一个是read only的目录。无论改目录中的文件夹或者文件的权限是什么，这个文件夹都是只读的。</p><p>如果要递归的挂载一个目录可以使用如下命令.<br>mount –rbind olddir newdir<br>递归的挂载是指如果挂载的olddir内有挂载点，会把这个挂载点也一起挂载到newdir下。</p><h2 id="flags"><a href="#flags" class="headerlink" title="flags"></a>flags</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * These are the fs-independent mount-flags: up to 32 flags are supported </span><br><span class="hljs-comment"> */</span>  <br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_RDONLY        1         <span class="hljs-comment">/* 对应-o ro/rw */</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_NOSUID        2         <span class="hljs-comment">/* 对应-o suid/nosuid */</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_NODEV         4         <span class="hljs-comment">/* 对应-o dev/nodev */</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_NOEXEC        8         <span class="hljs-comment">/* 对应-o exec/noexec */</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_SYNCHRONOUS  16         <span class="hljs-comment">/* 对应-o sync/async */</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_REMOUNT      32         <span class="hljs-comment">/* 对应-o remount，告诉mount这是一次remount操作 */</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_MANDLOCK     64         <span class="hljs-comment">/* 对应-o mand/nomand */</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_DIRSYNC      128        <span class="hljs-comment">/* 对应-o dirsync */</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_NOATIME      1024       <span class="hljs-comment">/* 对应-o atime/noatime */</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_NODIRATIME   2048       <span class="hljs-comment">/* 对应-o diratime/nodiratime */</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_BIND         4096       <span class="hljs-comment">/* 对应-B/--bind选项，告诉mount这是一次bind操作 */</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_MOVE         8192       <span class="hljs-comment">/* 对应-M/--move，告诉mount这是一次move操作 */</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_REC          16384      <span class="hljs-comment">/* rec是recursive的意思，这个flag一般不单独出现，都是伴随这其它flag，表示递归的进行操作 */</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_VERBOSE      32768      <span class="hljs-comment">/* 对应-v/--verbose */</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_SILENT       32768      <span class="hljs-comment">/* 对应-o silent/loud */</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_POSIXACL     (1&lt;&lt;16)    <span class="hljs-comment">/* 让VFS不应用umask，如NFS */</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_UNBINDABLE   (1&lt;&lt;17)    <span class="hljs-comment">/* 对应--make-unbindable */</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_PRIVATE      (1&lt;&lt;18)    <span class="hljs-comment">/* 对应--make-private */</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_SLAVE        (1&lt;&lt;19)    <span class="hljs-comment">/* 对应--make-slave */</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_SHARED       (1&lt;&lt;20)    <span class="hljs-comment">/* 对应--make-shared */</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_RELATIME     (1&lt;&lt;21)    <span class="hljs-comment">/* 对应-o relatime/norelatime */</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_KERNMOUNT    (1&lt;&lt;22)    <span class="hljs-comment">/* 这个一般不在应用层使用，一般内核挂载的文件系统如sysfs使用，表示使用kern_mount()进行挂载 */</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_I_VERSION    (1&lt;&lt;23)    <span class="hljs-comment">/* 对应-o iversion/noiversion */</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_STRICTATIME  (1&lt;&lt;24)    <span class="hljs-comment">/* 对应-o strictatime/nostrictatime */</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_LAZYTIME     (1&lt;&lt;25)    <span class="hljs-comment">/* 对应 -o lazytime/nolazytime*/</span></span><br><br><span class="hljs-comment">/* 下面这几个flags都是内核内部使用的，不由mount系统调用传递 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_SUBMOUNT     (1&lt;&lt;26)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_NOREMOTELOCK (1&lt;&lt;27)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_NOSEC        (1&lt;&lt;28)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_BORN         (1&lt;&lt;29)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_ACTIVE       (1&lt;&lt;30)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_NOUSER       (1&lt;&lt;31)</span><br><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * Superblock flags that can be altered by MS_REMOUNT </span><br><span class="hljs-comment"> */</span>  <br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_RMT_MASK     (MS_RDONLY|MS_SYNCHRONOUS|MS_MANDLOCK|MS_I_VERSION|\                   </span><br>                         MS_LAZYTIME)  <span class="hljs-comment">// 可以在remount时改变的flags  </span><br>  <br><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * Old magic mount flag and mask </span><br><span class="hljs-comment"> */</span>  <br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_MGC_VAL 0xC0ED0000      <span class="hljs-comment">/* magic number */</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MS_MGC_MSK 0xffff0000      <span class="hljs-comment">/* flags mask */</span></span><br></code></pre></td></tr></table></figure><p>除了上面这些flags对应的mount选项，剩下的基本就是data来传递。</p><h2 id="mount-umount函数详解"><a href="#mount-umount函数详解" class="headerlink" title="mount&#x2F;umount函数详解"></a>mount&#x2F;umount函数详解</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp">功能描述：<br>mount挂上文件系统，umount执行相反的操作。<br>  <br>用法：  <br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mount.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">mount</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *source, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *target,</span></span><br><span class="hljs-params"><span class="hljs-function">   <span class="hljs-type">const</span> <span class="hljs-type">char</span> *filesystemtype, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> mountflags, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *data)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">umount</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *target)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">umount2</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *target, <span class="hljs-type">int</span> flags)</span></span>;<br></code></pre></td></tr></table></figure><p>参数</p><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig"><span class="hljs-string">source</span>：将要挂上的文件系统，通常是一个设备名。<br><span class="hljs-string">target</span>：文件系统所要挂在的目标目录。<br><span class="hljs-string">filesystemtype</span>：文件系统的类型，可以是<span class="hljs-string">&quot;ext2&quot;</span>，<span class="hljs-string">&quot;msdos&quot;</span>，<span class="hljs-string">&quot;proc&quot;</span>，<span class="hljs-string">&quot;nfs&quot;</span>，<span class="hljs-string">&quot;iso9660&quot;</span> 。。。<br><span class="hljs-string">mountflags</span>：指定文件系统的读写访问标志，可能值有以下<br><br><span class="hljs-string">MS_BIND</span>：执行<span class="hljs-string">bind</span>挂载，使文件或者子目录树在文件系统内的另一个点上可视。<br><span class="hljs-string">MS_DIRSYNC</span>：同步目录的更新。<br><span class="hljs-string">MS_MANDLOCK</span>：允许在文件上执行强制锁。<br><span class="hljs-string">MS_MOVE</span>：移动子目录树。<br><span class="hljs-string">MS_NOATIME</span>：不要更新文件上的访问时间。<br><span class="hljs-string">MS_NODEV</span>：不允许访问设备文件。<br><span class="hljs-string">MS_NODIRATIME</span>：不允许更新目录上的访问时间。<br><span class="hljs-string">MS_NOEXEC</span>：不允许在挂上的文件系统上执行程序。<br><span class="hljs-string">MS_NOSUID</span>：执行程序时，不遵照<span class="hljs-built_in">set-user-ID</span> 和 <span class="hljs-built_in">set-group-ID位。</span><br><span class="hljs-string">MS_RDONLY</span>：指定文件系统为只读。<br><span class="hljs-string">MS_REMOUNT</span>：重新加载文件系统。这允许你改变现存文件系统的<span class="hljs-string">mountflag</span>和数据，而无需使用先卸载，再挂上文件系统的方式。<br><span class="hljs-string">MS_SYNCHRONOUS</span>：同步文件的更新。<br><span class="hljs-string">MNT_FORCE</span>：强制卸载，即使文件系统处于忙状态。<br><span class="hljs-string">MNT_EXPIRE</span>：将挂载点标志为过时<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
      <category>filesystem</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>mount</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
